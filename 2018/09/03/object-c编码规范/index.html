<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="段雨田的Blog" type="application/atom+xml" />






<meta name="description" content="总览参考资料Google Objective-C Style Guide       老大是一位重度代码洁癖的处女座，对代码规范非常苛刻，以前经常改动我的代码就为了他能看的顺眼。我记得曾在我提交的茫茫代码行中愣是指出某处的空格少了一个(囧)。    其实我们花时间在某一方面，必然在某一方面有所收获，在代码上花时间，那么必然对技术有所提升，对泡妞上花时间，必然在泡妞上有更多的心得。。。  写博客也是">
<meta property="og:type" content="article">
<meta property="og:title" content="object-c编码规范">
<meta property="og:url" content="http://yoursite.com/2018/09/03/object-c编码规范/index.html">
<meta property="og:site_name" content="段雨田的Blog">
<meta property="og:description" content="总览参考资料Google Objective-C Style Guide       老大是一位重度代码洁癖的处女座，对代码规范非常苛刻，以前经常改动我的代码就为了他能看的顺眼。我记得曾在我提交的茫茫代码行中愣是指出某处的空格少了一个(囧)。    其实我们花时间在某一方面，必然在某一方面有所收获，在代码上花时间，那么必然对技术有所提升，对泡妞上花时间，必然在泡妞上有更多的心得。。。  写博客也是">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-09-04T09:16:32.051Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="object-c编码规范">
<meta name="twitter:description" content="总览参考资料Google Objective-C Style Guide       老大是一位重度代码洁癖的处女座，对代码规范非常苛刻，以前经常改动我的代码就为了他能看的顺眼。我记得曾在我提交的茫茫代码行中愣是指出某处的空格少了一个(囧)。    其实我们花时间在某一方面，必然在某一方面有所收获，在代码上花时间，那么必然对技术有所提升，对泡妞上花时间，必然在泡妞上有更多的心得。。。  写博客也是">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/09/03/object-c编码规范/"/>





  <title>object-c编码规范 | 段雨田的Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
<!--     <a href="https://github.com/476139183"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_darkblue_121621.png" alt="Fork me on GitHub"></a>
 -->
    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">段雨田的Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">一个不知所云的人</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/09/03/object-c编码规范/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Duan yutian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/localImage/background.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="段雨田的Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">object-c编码规范</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-09-03T11:02:54+08:00">
                2018-09-03
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/09/03/object-c编码规范/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2018/09/03/object-c编码规范/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>参考资料<a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-objc-styleguide/" target="_blank" rel="noopener">Google Objective-C Style Guide</a>   </p>
<p>   老大是一位重度代码洁癖的处女座，对代码规范非常苛刻，以前经常改动我的代码就为了他能看的顺眼。我记得曾在我提交的茫茫代码行中愣是指出某处的空格少了一个(囧)。<br>    其实我们花时间在某一方面，必然在某一方面有所收获，在代码上花时间，那么必然对技术有所提升，对泡妞上花时间，必然在泡妞上有更多的心得。。。  写博客也是因为老大的建议，即便写的不深，很是粗糙，但是经常写博客，花时间总结，可以记录自己的整个学习过程，也有助于自我思考，自我表达。&lt; 屁话太多了吧(路过人员的心声) &gt;      </p>
<pre><code>前沿：其实 每一门开发语言都有自己的代码规范，我们应该遵循它的代码规范去使用它，这就是这篇文章的来源。    
</code></pre><a id="more"></a> 
<h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p> Objective-C是一个C语言的扩展语言，非常动态，非常的“面向对象”，它被设计成既拥有复杂的面向对象设计理念又可以轻松使用与阅读的语言，也是Mac OS X和iPhone开发的首选语言。</p>
<p>   Cocoa是Mac OS X的主要应用框架，提供迅速开发各种功能的Mac OS X应用的Objective-C类集合。</p>
<p>  Apple已经有一个很好也被广泛接受的Objective-C的编码规范，Google也有类似的C++编码规范，这份Objective-C编码规范很自然是Apple和Google的共同推荐的组合。所以，在阅读本规范前，确保你已经阅读了:</p>
<ul>
<li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/FrameworkImpl.html" target="_blank" rel="noopener">Apple’s Cocoa Coding Guidelines</a>     </li>
<li><p><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/" target="_blank" rel="noopener">Google’s Open Source C++ Style Guide</a> </p>
<blockquote>
<p>注意所有已在Google的C++编码规范里的禁用条款在Objective-C里也适用，除非本文档明确指出反对意见。 </p>
</blockquote>
</li>
</ul>
<p>本文档旨在描述可供可适用于所有Mac OS X代码的Objective-C(包括Objective-C++)编码规范和实践。规范中的许多条款已经改进也不断的被其他的项目和团队所证明其指导性。Google的相关开源项目都遵守此规范。</p>
<p>  Google已经发布了一份作为<a href="https://code.google.com/p/google-toolbox-for-mac/" target="_blank" rel="noopener">Google Toolbox for Mac project</a> (文档中简称为<code>GTM</code>)的组成部分的遵守本规范的开源代码。这份开放代码也是本文很好的例证(原文看不太懂－－Code meant to be shared across different projects is a good candidate to be included in this repository. )</p>
<p>  注意本文不是Objective-C的教学指南，我们假设读者已经了解语言。如果你是一个Objective-C的初学者或需要重温，请阅读<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html" target="_blank" rel="noopener">The Objective-C Programming Language</a> .</p>
<p>示例 </p>
<p> 人们说一个例子胜过千言万语，所以就让我们用例子来让你感受以下编码规范的风格，留间距，命名等等。</p>
<p> 下例是一份头文件，展示对@interface 声明正确的注释和留间距    </p>
<p>iOS代码 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  GTMFoo.h  </span></span><br><span class="line"><span class="comment">//  FooProject  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">//  Created by Greg Miller on 6/13/08.  </span></span><br><span class="line"><span class="comment">//  Copyright 2008 Google, Inc. All rights reserved.  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">``` objc</span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// A sample class demonstrating good Objective-C style. All interfaces,  </span></span><br><span class="line"><span class="comment">// categories, and protocols (read: all top-level declarations in a header)  </span></span><br><span class="line"><span class="comment">// MUST be commented. Comments must also be adjacent to the object they're  </span></span><br><span class="line"><span class="comment">// documenting.  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// (no blank line between this comment and the interface)  </span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GTMFoo</span> : <span class="title">NSObject</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">@private</span>  </span><br><span class="line">  <span class="built_in">NSString</span> *foo_;  </span><br><span class="line">  <span class="built_in">NSString</span> *bar_;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Returns an autoreleased instance of GMFoo. See -initWithString: for details  </span></span><br><span class="line"><span class="comment">// about the argument.  </span></span><br><span class="line">+ (<span class="keyword">id</span>)fooWithString:(<span class="built_in">NSString</span> *)string;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Designated initializer. |string| will be copied and assigned to |foo_|.  </span></span><br><span class="line">- (<span class="keyword">id</span>)initWithString:(<span class="built_in">NSString</span> *)string;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Gets and sets the string for |foo_|.  </span></span><br><span class="line">- (<span class="built_in">NSString</span> *)foo;  </span><br><span class="line">- (<span class="keyword">void</span>)setFoo:(<span class="built_in">NSString</span> *)newFoo;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Does some work on |blah| and returns YES if the work was completed  </span></span><br><span class="line"><span class="comment">// successfuly, and NO otherwise.  </span></span><br><span class="line">- (<span class="built_in">BOOL</span>)doWorkWithString:(<span class="built_in">NSString</span> *)blah;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p> <strong>注意：有朋友喜欢在全局变量命名时以_开头，其实我不建议，比如 NSString *_foo; 因为在阅读时很容易让人误会是property属性，我们应该尽量让阅读者可以方便的理解代码，而不是出现诱导因素。</strong></p>
<p>  下例是一份源文件，展示对接口的@implementation 的实现的正确注释和留间隔。它也包括了主要方法如getters,setters,init ,和dealloc 的相关实现。  </p>
<p>iOS代码    </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">//  GTMFoo.m  </span></span><br><span class="line"><span class="comment">//  FooProject  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">//  Created by Greg Miller on 6/13/08.  </span></span><br><span class="line"><span class="comment">//  Copyright 2008 Google, Inc. All rights reserved.  </span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"GTMFoo.h"</span>  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">GTMFoo</span>  </span></span><br><span class="line">  </span><br><span class="line">+ (<span class="keyword">id</span>)fooWithString:(<span class="built_in">NSString</span> *)string &#123;  </span><br><span class="line">  <span class="keyword">return</span> [[[<span class="keyword">self</span> alloc] initWithString:string] autorelease];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Must always override super's designated initializer.  </span></span><br><span class="line">- (<span class="keyword">id</span>)init &#123;  </span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">self</span> initWithString:<span class="literal">nil</span>];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">- (<span class="keyword">id</span>)initWithString:(<span class="built_in">NSString</span> *)string &#123;  </span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;  </span><br><span class="line">    foo_ = [string <span class="keyword">copy</span>];  </span><br><span class="line">    bar_ = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"hi %d"</span>, <span class="number">3</span>];  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;    </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;  </span><br><span class="line">  [foo_ release];  </span><br><span class="line">  [bar_ release];  </span><br><span class="line">  [<span class="keyword">super</span> dealloc];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">- (<span class="built_in">NSString</span> *)foo &#123;  </span><br><span class="line">  <span class="keyword">return</span> foo_;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">- (<span class="keyword">void</span>)setFoo:(<span class="built_in">NSString</span> *)newFoo &#123;  </span><br><span class="line">  [foo_ autorelease];  </span><br><span class="line">  foo_ = [newFoo <span class="keyword">copy</span>];    </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">- (<span class="built_in">BOOL</span>)doWorkWithString:(<span class="built_in">NSString</span> *)blah &#123;  </span><br><span class="line">  <span class="comment">// ...  </span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NO</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h2 id="间隔与格式化"><a href="#间隔与格式化" class="headerlink" title="间隔与格式化"></a>间隔与格式化</h2><h3 id="空格对tab键"><a href="#空格对tab键" class="headerlink" title="空格对tab键"></a>空格对tab键</h3><p>  仅使用空格，缩进两个。</p>
<p>  我们使用空格用于缩进，不要在编码时使用tab键，你应该设置你的编辑器将tab键转换成对应的空格。</p>
<h3 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h3><p>  代码中的每行文本不要超过80个字符的长度。</p>
<p>  尽管Objective-C正变得比C++更加繁冗，为了保持规范的互通性，我们还是决定保持80字符长度的限制。这比你想象中的更容易做到。</p>
<p>  我们知道本条款是有争议的，但已有此多的代码已经遵从了本条款，即使只是保持一致性也是一个充足的理由。</p>
<p>  你可以在Xcode里清楚地发现代码中的违规，设置  Xcode &gt; Preferences &gt; Text Editing &gt; Show page guide. (之后就可以在代码编辑区域里看到一条指定字符长度的指示线了)</p>
<h2 id="方法声明与定义"><a href="#方法声明与定义" class="headerlink" title="方法声明与定义"></a>方法声明与定义</h2><p>  留一个空格在 - 或 + 和 返回类型 之间，但参数列表里的参数之间不要留间隔。<br> 方法应该写成这样:    </p>
<p>iOS代码 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doSomethingWithString:(<span class="built_in">NSString</span> *)theString &#123;  </span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>星号前的空格是可选的，你可以根据原来的代码风格自行决定。</p>
<p>如果参数过多，推荐每个参数各占一行。使用多行的情况下，以参数前的冒号用于对齐:<br>        (很遗憾这里仅有Google Chrome浏览器能看出是冒号对齐的……)     </p>
<p>iOS代码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doSomethingWith:(GTMFoo *)theFoo  </span><br><span class="line">                   rect:(<span class="built_in">NSRect</span>)theRect  </span><br><span class="line">               interval:(<span class="keyword">float</span>)theInterval &#123;  </span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当第一个关键字比其他的短时，后续行至少缩进四个空格。这样你可以让后续的关键字垂直对齐，而不是用冒号对齐:<br>iOS代码 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)short:(GTMFoo *)theFoo  </span><br><span class="line">    longKeyword:(NSRect)theRect  </span><br><span class="line">    evenLongerKeyword:(float)theInterval &#123;  </span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p> 方法调用的格式和方法声明时的格式时一致的，如果格式风格可选，遵从原有代码的风格。</p>
<p> 调用应该将所有参数写在一行:   </p>
<p>iOS代码 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[myObject doFooWith:arg1 name:arg2 error:arg3];</span><br></pre></td></tr></table></figure>
<p> 或者每个参数一行，用冒号对齐:(对齐效果如前说明)    </p>
<p>iOS代码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[myObject doFooWith:arg1  </span><br><span class="line">               name:arg2  </span><br><span class="line">              error:arg3];</span><br></pre></td></tr></table></figure>
<p>注意:不要使用如下风格的写法</p>
<p>iOS代码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[myObject doFooWith:arg1 name:arg2  <span class="comment">// some lines with &gt;1 arg  </span></span><br><span class="line">              error:arg3];  </span><br><span class="line">  </span><br><span class="line">[myObject doFooWith:arg1  </span><br><span class="line">               name:arg2 error:arg3];  </span><br><span class="line">  </span><br><span class="line">[myObject doFooWith:arg1  </span><br><span class="line">          name:arg2  <span class="comment">// aligning keywords instead of colons  </span></span><br><span class="line">          error:arg3];</span><br></pre></td></tr></table></figure>
<p>在声明和定义时，如果因为关键字长度使就算有四个空格在前仍然无法用冒号对齐，那么就让后续行缩进四个空格而不是冒号对齐:    </p>
<p>iOS代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[myObj short:arg1  </span><br><span class="line">    longKeyword:arg2  </span><br><span class="line">    evenLongerKeyword:arg3];</span><br></pre></td></tr></table></figure>
<h3 id="public-和-private"><a href="#public-和-private" class="headerlink" title="@public 和 @private"></a>@public 和 @private</h3><p>权限控制符@public 和@private 缩进一个空格.</p>
<p>类似C++的public,protected,private:</p>
<p>iOS代码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">@public</span>  </span><br><span class="line">  ...  </span><br><span class="line"> <span class="keyword">@private</span>  </span><br><span class="line">  ...  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>每个异常标签的@ 和开括号({ )写在统一行，标签和开括号间隔一个空格，同样适用于@catch 语句。</p>
<p>如果你决定使用Objective-C的异常，那么就按如下格式，不过你最好先看看Avoid Throwing Exceptions(见后)条款，了解为何你不应使用异常。    </p>
<p>iOS代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@try &#123;  </span><br><span class="line">  foo();  </span><br><span class="line">&#125;  </span><br><span class="line">@catch (NSException *ex) &#123;  </span><br><span class="line">  bar(ex);  </span><br><span class="line">&#125;  </span><br><span class="line">@finally &#123;  </span><br><span class="line">  baz();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>命名规则对于维护代码来说是非常重要的。Objective-C方法名往往很长，不过这也有好处，读代码就像读散文(放屁),让很多注释变得毫无意义。</p>
<p>写纯Objective-C代码时，我们基本上遵守标准Objective-C naming rules ，这些规则和C++的规则有很大的不同。比如Google的C++代码规范推荐变量名构词之间使用下划线隔开，而本文档推荐驼峰法，也是Objective-C社区的标准。</p>
<p>所有类，类别, 方法，以及变量如包括缩写，则缩写部分使用全大写的缩写(Initialisms )形式。这遵守Apple的标准，比如URL,TIFF以及EXIF。</p>
<p>  当写Objective-C++代码时，情况就不是那么单一了。许多项目需要实现带一些Objective-C代码的跨平台的C++APIs或者连接后台的C++代码与前台的原生Cocoa代码.这会造成两种规范直接冲突。</p>
<p>  我们的解决方法是根据方法/函数风格来决定。如果在@implementation 块，就使用Objective-C的命名规则；如果在C++的方法实现块，就使用C++的命名规则。避免了实体变量和本地变量在一个函数内命名规则冲突的情况，而这种情况是对可读性的极大损害。</p>
<h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><p>  文件名反映了它所包含的实现类的名字，遵从你所在项目的习惯。</p>
<p>  文件扩展名使用如下规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.h     	C/C++/Objective-C header file</span><br><span class="line"> </span><br><span class="line">.m     	Objective-C implementation file</span><br><span class="line"> </span><br><span class="line">.mm    	Objective-C++ implementation file</span><br><span class="line"> </span><br><span class="line">.cc    	Pure C++ implementation file</span><br><span class="line"> </span><br><span class="line">.c     	C implementation file</span><br></pre></td></tr></table></figure>
<p>类别的文件名应该包含扩展类的名字，比如 <code>GTMNSString+Utils.h</code> or <code>GTMNSTextView+Autocomplete.h</code> </p>
<h3 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective-C++"></a>Objective-C++</h3><p>在一份源文件里，Objective-C++代码遵守当前方法/函数的风格</p>
<p>为了尽量减少不同命名风格间的冲突，使用当前方法的风格。如果在@implementation块，使用Objective-C命名规则，如果在C++类的函数实现块，使用C++命名规则。    </p>
<p>iOS代码 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: cross_platform_header.h  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> CrossPlatformAPI &#123;  </span><br><span class="line"> public:  </span><br><span class="line">  ...  </span><br><span class="line">  <span class="keyword">int</span> DoSomethingPlatformSpecific();  <span class="comment">// impl on each platform  </span></span><br><span class="line"> private:  </span><br><span class="line">  <span class="keyword">int</span> an_instance_var_;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: mac_implementation.mm  </span></span><br><span class="line"><span class="meta">#include <span class="meta-string">"cross_platform_header.h"</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// A typical Objective-C class, using Objective-C naming.  </span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyDelegate</span> : <span class="title">NSObject</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">@private</span>  </span><br><span class="line">  <span class="keyword">int</span> instanceVar_;  </span><br><span class="line">  CrossPlatformAPI* backEndObject_;  </span><br><span class="line">&#125;  </span><br><span class="line">- (<span class="keyword">void</span>)respondToSomething:(<span class="keyword">id</span>)something;  </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyDelegate</span>  </span></span><br><span class="line">- (<span class="keyword">void</span>)respondToSomething:(<span class="keyword">id</span>)something &#123;  </span><br><span class="line">  <span class="comment">// bridge from Cocoa through our C++ backend  </span></span><br><span class="line">  instanceVar_ = backEndObject-&gt;DoSomethingPlatformSpecific();  </span><br><span class="line">  <span class="built_in">NSString</span>* tempString = [<span class="built_in">NSString</span> stringWithInt:instanceVar_];  </span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, tempString);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// The platform-specific implementation of the C++ class, using  </span></span><br><span class="line"><span class="comment">// C++ naming.  </span></span><br><span class="line"><span class="keyword">int</span> CrossPlatformAPI::DoSomethingPlatformSpecific() &#123;  </span><br><span class="line">  <span class="built_in">NSString</span>* temp_string = [<span class="built_in">NSString</span> stringWithInt:an_instance_var_];  </span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, temp_string);  </span><br><span class="line">  <span class="keyword">return</span> [temp_string intValue];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类命名"><a href="#类命名" class="headerlink" title="类命名"></a>类命名</h3><p>   类名(不包括类别和协议名)应该用大写开头的驼峰命名法。</p>
<p>   在应用级别的代码里，尽量不要使用带前缀的类名。每个类都有相同的前缀不能提高可读性。不过如果是编写多个应用间的共享代码，前缀就是可接受并推荐的做法了(型如 GTMSendMessage )。（注：笔者建议加入前缀，因为这并不是单单为了提高可读性，也为了与引入进来的类做区分，所以合适的前缀是有必要的）</p>
<h3 id="类别命名"><a href="#类别命名" class="headerlink" title="类别命名"></a>类别命名</h3><p>   类别命名应该以两三个字符的分类前缀作为一个项目或通用的公用部分。类别名应该包含类的扩展。</p>
<p>   举个例子，如果我们想要创建一个基于NSString 的类别用于解析，我们应该把类别放到名字是GTMNSString+Parsing.h 的文件里，而类别本身的名字则是GTMStringParsingAdditions (是的，我们明白这个类别和其文件名字不匹配，但这个文件可能还包括其他用于解析相关的类别)。类别的方法应该都使用一个前缀(型如gtm_myCategoryMethodOnAString ),以防止Objective-C代码在单名空间里冲突。如果代码本来就不考虑共享或在不同的地址空间(address-space)，方法命名规则就没必要恪守了。</p>
<h3 id="Objective-C-方法命名"><a href="#Objective-C-方法命名" class="headerlink" title="Objective-C 方法命名"></a>Objective-C 方法命名</h3><p>   方法使用小写开头的驼峰法命名，每个参数都应该小写开头。</p>
<p>   方法名应该尽可能读起来像一句话，参数名就相对方法名的补充说明(比如convertPoing:fromRect: 或者 replaceCharactersInRange:withString: )，详见Apple’s Guide to Naming Methods </p>
<p>   存取(Accessor)方法应该一致的在”取(getting)”的时候直接用变量名而不是在签名加”get”,如下:    </p>
<p>iOS代码 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (id)getDelegate;  // AVOID  </span><br><span class="line">  </span><br><span class="line">- (id)delegate;    // GOOD</span><br></pre></td></tr></table></figure>
<p>   不过这仅针对Objective-C代码，C++代码仍然遵循自己的代码规范。</p>
<h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><p>   变量名使用小写开头的驼峰法，类成员变量名最后加一个下划线，比如:myLovalVariable, myInstanceVariable_ . 下面看不懂，原文Members used for KVO/KVC bindings may begin with a leading underscore iff use of Objective-C 2.0’s @property isn’t allowed. </p>
<h4 id="一般变量命名"><a href="#一般变量命名" class="headerlink" title="一般变量命名"></a>一般变量命名</h4><p>   不要使用匈牙利命名法去标记语法，比如静态类型或变量类型(int或pointer之类的)。使变量名尽量可以推测其用途属性具有描述性。别一心想着少打几个字母，让你的代码可以迅速被理解更加重要。比如:</p>
<p>iOS代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// AVOID  </span><br><span class="line">int w;  </span><br><span class="line">int nerr;  </span><br><span class="line">int nCompConns;  </span><br><span class="line">tix = [[NSMutableArray alloc] init];  </span><br><span class="line">obj = [someObject object];  </span><br><span class="line">p = [network port];  </span><br><span class="line">  </span><br><span class="line">// GOOD  </span><br><span class="line">int numErrors;  </span><br><span class="line">int numCompletedConnections;  </span><br><span class="line">tickets = [[NSMutableArray alloc] init];  </span><br><span class="line">userInfo = [someObject object];  </span><br><span class="line">port = [network port];</span><br></pre></td></tr></table></figure>
<h4 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h4><p>   实例变量用驼峰法命名并后缀下划线，就像 <code>usernameTextField_</code> . 然而我们允许一种例外就是用KVO/KVC去绑定一个实体变量而Objective-C 2.0 不能用(因为操作系统的限制)的情况，此时也可用前缀下划线的方法给每个变量命名。如果可以使用Objective-C 2.0，<code>@property</code> 和 <code>@synthesize</code> 提供了遵守命名规范的解决方法。</p>
<h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>   常量(预定义，枚举，局部常量等)使用小写k开头的驼峰法，比如 <code>kInvalidHandle</code> , <code>kWritePerm</code> . </p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>尽管写起来很痛苦，但注释仍然是使代码保持可读性的极端重要的方式。下面的条款描述了你应该注释什么以及在哪里做注释。但是记住:即使注释是如此重要，最好的代码还是自说明式的。起一个有意义的名字比起一个晦涩的名字然后在用注释去解释它好的多。</p>
<p>   当你写注释的时候，记住注释是写给读者，即下一个要理解你的代码并继续开发的人。”下一个”完全可能就是你自己。</p>
<p>   同样，所有C++编码规范的条款仍然适用，只是增加了一些条款，如下.</p>
<h3 id="文件注释"><a href="#文件注释" class="headerlink" title="文件注释"></a>文件注释</h3><p>   每个文件的开头都是版权声明，接着是文件内容的描述。</p>
<p>   法律声明和作者栏 </p>
<p>   每个文件都应该包含如下信息:</p>
<p>   一份版权声明(比如 Copyright 2008 Google Inc .)<br>   许可版本 为项目选择合适的许可版本(比如Apache 2.0, BSD, LGPL, GPL)</p>
<p>   如果你把别人写的文件做了相当大的改动，就把自己添加到作者栏去。这样别的开发者就方便联系这个文件的实际开发人员了。</p>
<h3 id="声明部分注释"><a href="#声明部分注释" class="headerlink" title="声明部分注释"></a>声明部分注释</h3><p>   每个接口，类别，协议都必须伴随描述它的用途以及如何整合的注释。</p>
<p>iOS代码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A delegate for NSApplication to handle notifications about app  </span></span><br><span class="line"><span class="comment">// launch and shutdown. Owned by the main app controller.  </span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyAppDelegate</span> : <span class="title">NSObject</span> </span>&#123;  </span><br><span class="line">  ...  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>   如果已经在文件的顶部写了接口的详细描述，你也可以简单的写如”见文件顶部的完整描述”，当然要有这些注释的顺序安排。</p>
<p>   此外public接口的每个方法都应该添加关于函数，参数，返回值以及副作用的注释。       </p>
<p>   文档默认类都是同步的，如果类实例可以多线程访问，必须要加上额外的说明。     </p>
<h3 id="实现部分注释"><a href="#实现部分注释" class="headerlink" title="实现部分注释"></a>实现部分注释</h3><p>  使用竖线引用变量或符号，而不是用引号。    </p>
<p>   这可以减少歧义，特别是当符号本身就是个常见的词时，可能使句子显得支离破碎，比如符号是”count”:    </p>
<p>iOS代码     </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// Sometimes we need |count| to be less than zero.</span><br></pre></td></tr></table></figure>
<p>   或者是对于那些已经存在引号的情况     </p>
<p>iOS代码    </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remember to call |StringWithoutSpaces("foo bar baz")|</span></span><br></pre></td></tr></table></figure>
<h3 id="对象所有权"><a href="#对象所有权" class="headerlink" title="对象所有权"></a>对象所有权</h3><p>   使指针所有权的模型尽可能清晰，当它属于Objective-C的使用惯例时(不懂，原文是Make the pointer ownership model as explicit as possible when it falls outside the most common Objective-C usage idioms. )</p>
<p>   实例变量指向NSObject派生类的对象时都假定是retain的，如果它们不是retain的则需要加上”weak”的文档说明。对应的，实体变量如果标记上IBOutlets则是假定为非retain的，若实际上用了retain，就必须加上”strong”的说明。</p>
<p>   当实例变量指向核心库，C++或其他非Objective-C对象时，必须永远用注释说明是strong还是weak的。必须注意为了支持Objective-C对象里的自动化C++对象的封装是默认被关闭的的(这句话有歧义，原文是Be mindful that support for automatic C++ objects encapsulated in Objective-C objects is disabled by default)，这里 有说明。</p>
<p>  strong和weak说明的文档示例:</p>
<p>  iOS代码 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyDelegate</span> : <span class="title">NSObject</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">@private</span>  </span><br><span class="line">  <span class="keyword">IBOutlet</span> <span class="built_in">NSButton</span>* okButton_;  <span class="comment">// normal NSControl  </span></span><br><span class="line">  <span class="keyword">IBOutlet</span> <span class="built_in">NSMenu</span>* myContextMenu_;  <span class="comment">// manually-loaded menu (strong)  </span></span><br><span class="line">  </span><br><span class="line">  AnObjcObject* doohickey_;  <span class="comment">// my doohickey  </span></span><br><span class="line">  MyController* controller_;  <span class="comment">// so we can send msgs back (weak, owns me)  </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// non-NSObject pointers...  </span></span><br><span class="line">  CWackyCPPClass* wacky_;  <span class="comment">// some cross-platform object (strong)  </span></span><br><span class="line">  <span class="built_in">CFDictionaryRef</span>* dict_;  <span class="comment">// (strong)  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strong</span><br><span class="line">对象会在类中retain </span><br><span class="line">weak</span><br><span class="line">对象不会在类中retain   (比如一个委托)</span><br></pre></td></tr></table></figure>
<h2 id="Cocoa和Objective-C特性"><a href="#Cocoa和Objective-C特性" class="headerlink" title="Cocoa和Objective-C特性"></a>Cocoa和Objective-C特性</h2><h3 id="成员变量应该定义为-private"><a href="#成员变量应该定义为-private" class="headerlink" title="成员变量应该定义为@private"></a>成员变量应该定义为@private</h3><p>iOS代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface MyClass : NSObject &#123;  </span><br><span class="line"> @private  </span><br><span class="line">  id myInstanceVariable_;  </span><br><span class="line">&#125;  </span><br><span class="line">// public accessors, setter takes ownership  </span><br><span class="line">- (id)myInstanceVariable;  </span><br><span class="line">- (void)setMyInstanceVariable:(id)theVar;  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<h3 id="明确指定初始化函数"><a href="#明确指定初始化函数" class="headerlink" title="明确指定初始化函数"></a>明确指定初始化函数</h3><ul>
<li><p>注释并说明指定的初始化。</p>
<p>明确指定初始化对想要子类化你的类的时候时很重要的。那样，子类化时只需要做一个或多个初始化去保证初值即可。这也有助于在以后调试你的类时明了初始化流程。</p>
</li>
</ul>
<h3 id="重写指定初始化函数"><a href="#重写指定初始化函数" class="headerlink" title="重写指定初始化函数"></a>重写指定初始化函数</h3><p>   当重写一个子类并需要init… 方法，注意要重写父类的指定初始化方法。</p>
<p>   如果你没有正确重写父类的指定初始化方法，你的初始化方法可能不会被调用，这会导致很多微妙而难以排除的错误。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>   没必要在初始化方法里把变量初始化为0 或者nil ,这是多余的。</p>
<p>   所有新分配内存的对象内容都初始化为0(除了 isa )，所以不要在init 方法里做无谓的重初始化为0的操作。</p>
<h3 id="保持公有API简明"><a href="#保持公有API简明" class="headerlink" title="保持公有API简明"></a>保持公有API简明</h3><p>   保持你的类简单，避免”厨房水槽”似的APIs，如果一个方法没必要公开就不要公开。使用私有类别保证公开头文件的简洁。</p>
<p>   和C++不同，Objective-C无法区分公有私有方法，因为它全是公有的。因此，除非就是为了让用户调用所设计，不要把其他的方法放到公有API里。这样可以减少不期调用的可能性。这还包括重写父类的方法。对于那些内部实现的方法，在实现文件里使用类别而不是将方法定义在公有头文件里。</p>
<p>iOS代码    </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GTMFoo.m  </span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"GTMFoo.h"</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GTMFoo</span> (<span class="title">PrivateDelegateHandling</span>)  </span></span><br><span class="line">- (<span class="built_in">NSString</span> *)doSomethingWithDelegate;  <span class="comment">// Declare private method  </span></span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">GTMFoo</span>(<span class="title">PrivateDelegateHandling</span>)  </span></span><br><span class="line">...  </span><br><span class="line">- (<span class="built_in">NSString</span> *)doSomethingWithDelegate &#123;  </span><br><span class="line">  <span class="comment">// Implement this method  </span></span><br><span class="line">&#125;  </span><br><span class="line">...  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>   在Objective-C 2.0之前，如果你在私有@interface 里声明了一个方法，但忘记在主@implementation 文件里实现了，编译器不会有什么反应(这是因为你没有在不同的类别里实现这些私有方法)。解决方案在是把函数写到@implementation 里并指明类别。</p>
<p>   如果你用的是 Objective-C 2.0，你应该使用类扩展 而不是声明私有类别，如下:</p>
<p>iOS代码    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface GMFoo () &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>   如此就可以保证函数做了声明但没有在@implememtation 里实现的时候编译器会警报。</p>
<p>   再者，”private”方法并不是真正的private，你可能会无意间重写了父类的一个”private”方法，这回导致bug的涌现。总的来说，私有方法应该使用更特别的名字以阻止子类化时并不期望的重写。</p>
<p>   最后，对于绝大多数类而言，Objective-C的类别是将@implelemtation做可理解的分块，添加新的应用级别的功能的最佳途径。比如，与其在你的项目里随便找个类来实现字符串的”中间截断”功能，不如创建一个新的NSString 类别。</p>
<h2 id="import-和-include"><a href="#import-和-include" class="headerlink" title="#import 和 #include"></a>#import 和 #include</h2><p>   用 #import 导入Objective-C 或 Objective-C++头 文件，用 #include 导入C或C++头 文件</p>
<h3 id="根据头文件的语言去选择合适的导入方式。"><a href="#根据头文件的语言去选择合适的导入方式。" class="headerlink" title="根据头文件的语言去选择合适的导入方式。"></a>根据头文件的语言去选择合适的导入方式。</h3><p>   当导入的头文件使用Objective-C或Objective-C++语言时，使用#import .<br>   当导入标准C或 C++头文件时，使用#include . 头文件应该使用自己的#define 重加载保护</p>
<p>   有些Objective-C头文件没有#define 重加载保护，所以只应该用#import 导入。因此Objective-C头文件只应该被Objective-C源文件或其他的Objective-C头文件所导入。这种情况下全部使用#import 是合适的。</p>
<p>   标准C和C++头文件不包含任何Objective-C元素都可以被一般的C或C++文件导入。因为标准C和C++里根本没有#import ，所以也只能用#include 导入。在Objective-C代码中使用#include 一致的导入这些头文件。</p>
<p>   本条款有助于跨平台项目的无意错误。一位Mac开发者引入一份新C或C++头文件时可能会忘记添加#define重加载保护，因为在Mac上用#import 导入文件不会引发问题，但在别的使用#include 的平台就可能出问题。在所有平台一致的使用#include 意味着要么全部成功要么全部失败，避免了那种另人沮丧的一些平台上可以运作而另一些不行的情况。</p>
<p> iOS代码 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#include <span class="meta-string">&lt;CoreFoundation/CoreFoundation.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"GTMFoo.h"</span>  </span></span><br><span class="line"><span class="meta">#include <span class="meta-string">"base/basictypes.h"</span></span></span><br></pre></td></tr></table></figure>
<h3 id="使用框架根"><a href="#使用框架根" class="headerlink" title="使用框架根"></a>使用框架根</h3><p>   导入框架根的头文件而不是分别导入框架头文件</p>
<p>   看起来从Cocoa或Foundation这些框架里导入个别的文件很不错，但实际上你直接导入框架根头文件效率更高。框架根已经被预编译故可更快的被加载。还有，记住用#import 指令而不是#include 导入Objective-C的框架。</p>
<p>iOS代码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span>     // good  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/NSArray.h&gt;</span>        // avoid  </span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/NSString.h&gt;</span>  </span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">### 构建时即设定autorelease ###</span></span><br><span class="line"></span><br><span class="line">   当创建新的临时对象时，在同一行代码里就设定autorelease而不是写到这个方法的后面几行去</span><br><span class="line"></span><br><span class="line">   即使这样可能会造成一些轻微的延迟，但这样避免了谁不小心把release 去掉，或在release 之前就<span class="keyword">return</span> 而造成的内存泄露，如下</span><br><span class="line">   </span><br><span class="line">iOS代码    </span><br><span class="line"></span><br><span class="line">``` objc </span><br><span class="line"><span class="comment">// AVOID (unless you have a compelling performance reason)  </span></span><br><span class="line">MyController* controller = [[MyController alloc] init];  </span><br><span class="line"><span class="comment">// ... code here that might return ...  </span></span><br><span class="line">[controller release];  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// BETTER  </span></span><br><span class="line">MyController* controller = [[[MyController alloc] init] autorelease];</span><br></pre></td></tr></table></figure>
<p>   优先autorelease而非retain </p>
<h3 id="对象赋值时尽量采用autorelease-而不是retian-模式。"><a href="#对象赋值时尽量采用autorelease-而不是retian-模式。" class="headerlink" title="对象赋值时尽量采用autorelease 而不是retian 模式。"></a>对象赋值时尽量采用autorelease 而不是retian 模式。</h3><p>   当把一个新创建的对象赋予一个变量的时候，第一件要做的事情就是先释放原来变量指向的对象以防止内存泄露。这里也有很多”正确的”方法去做这件事。我们选择autorelease时因为它更不倾向于出错。小心在密集的循环里可能会很快填满autorelease池，而且它也确实会降低效率，但权衡下来还是可以接受的。</p>
<p>iOS代码  </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setFoo:(GMFoo *)aFoo &#123;  </span><br><span class="line">  [foo_ autorelease];  <span class="comment">// Won't dealloc if |foo_| == |aFoo|  </span></span><br><span class="line">  foo_ = [aFoo <span class="keyword">retain</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   以声明时的顺序dealloc处理实例变量 </p>
<p>   dealloc 应该用在@interface 声明时同样的顺序处理实例变量，这也有助于评审者鉴别。</p>
<p>   代码评审者检查或修正dealloc 的实现要确保所有retain 的实例变量都获得了释放。</p>
<p>   为了简化评审dealloc ，将释放retain 的实例变量代码保持和@interface 里声明的顺序一致。如果dealloc 调用了其他方法去释放实例变量，添加注释说明那些实例变量被这些方法所处理了。</p>
<h3 id="Setters-copy-NSStrings"><a href="#Setters-copy-NSStrings" class="headerlink" title="Setters copy NSStrings"></a>Setters copy NSStrings</h3><p>   在NSString 上调用Setters 方法时，永远使用copy 方式。(不太懂，原文是Setters taking an NSString, should always copy  the string it accepts. )</p>
<p>   永远不要retain 一个字符串，这可以防止调用者在你不知到的情况下修改了字符串。不要以为你可以改变NSString 的值，只有NSMutableString 才能做到。</p>
<p>iOS代码 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setFoo:(<span class="built_in">NSString</span> *)aFoo &#123;  </span><br><span class="line">  [foo_ autorelease];  </span><br><span class="line">  foo_ = [aFoo <span class="keyword">copy</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 避免抛出异常 </p>
<p>   不要 @throw Objective-C的异常，不过你还是要做好准备捕获第三方以及系统调用抛出的异常。</p>
<p>   我们的确在编译时加入了-fobjc-exceptions 指令(主要是为了获得@synchronized )，但我们并不@throw 。当然在使用第三方库的时候是允许使用@try，@catch, 以及@finally 的。如果你确实使用了，请务必明确到文档中哪个方向你想抛出什么异常。</p>
<p>   除非你写的代码想要泡在MacOS 10.2或更之前，否则不要使用NS_DURING, NS_HANDLER, NS_ENDHANDLER, NS_VALUERETURN and NS_VOIDRETURN 这些宏。</p>
<p>   另外你要小心当写Objective-C++代码的时候，如果抛出Objective-C异常，那些栈上的对象不会被清理。示例:</p>
<p>iOS代码 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> exceptiontest &#123;  </span><br><span class="line"> public:  </span><br><span class="line">  exceptiontest() &#123; <span class="built_in">NSLog</span>(<span class="string">@"Created"</span>); &#125;  </span><br><span class="line">  ~exceptiontest() &#123; <span class="built_in">NSLog</span>(<span class="string">@"Destroyed"</span>); &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">void</span> foo() &#123;  </span><br><span class="line">  exceptiontest a;  </span><br><span class="line">  <span class="built_in">NSException</span> *exception = [<span class="built_in">NSException</span> exceptionWithName:<span class="string">@"foo"</span>  </span><br><span class="line">                                                   reason:<span class="string">@"bar"</span>  </span><br><span class="line">                                                 userInfo:<span class="literal">nil</span>];  </span><br><span class="line">  <span class="keyword">@throw</span> exception;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) &#123;  </span><br><span class="line">  GMAutoreleasePool pool;  </span><br><span class="line">  <span class="keyword">@try</span> &#123;  </span><br><span class="line">    foo();  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">@catch</span>(<span class="built_in">NSException</span> *ex) &#123;  </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"exception raised"</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   将会有如下输出:    </p>
<p>   iOS代码    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2006-09-28 12:34:29.244 exceptiontest[23661] Created         </span><br><span class="line">2006-09-28 12:34:29.244 exceptiontest[23661] exception raised</span><br></pre></td></tr></table></figure>
<p>   注意这里的析构函数永远没有机会被调用。这是在你想用栈上的智能指针比如shared_ptr,linked_ptr ,还有STL对象的时候不得不关注的一个核心问题。我们不得不痛心地说，如果你一定要在Objective-C++代码里抛出异常，那就请一定使用C++的异常。永远不要重新抛出一个Objective-C的异常，也不允许在异常块即@try,@catch,@finally 里生成栈上的 C++对象(比如std::string, std::vector 等).</p>
<h3 id="nil检查"><a href="#nil检查" class="headerlink" title="nil检查"></a>nil检查</h3><p>   仅在校验逻辑流程时做nil检查。</p>
<p>   使用nil检查不是为了防止程序崩溃，而是校验逻辑流程。向一个空对象发送一条消息是由Objective-C运行时处理的。方法没有返回结果，你也可以安心走下去.然而这里也有一种，依执行架构不同而返回尺寸和OS X的版本(这段不懂)(见)Apple’s documentation for specifics 。</p>
<p>   注意这里和C/C++的空指针检查是完全不同的，在那些环境里，并不处理空指针情况并可能导致你的应用程序崩溃。不过你仍要自己确保提领的指针不为空。</p>
<h3 id="BOOL类型陷阱"><a href="#BOOL类型陷阱" class="headerlink" title="BOOL类型陷阱"></a>BOOL类型陷阱</h3><p>  整形的转换为 BOOL 型的时候要小心。不要直接和YES做比较。</p>
<p>   BOOL 在Objective-C里被定义为unsigned char，这意味着它不仅仅只有YES (1)和NO (0)两个值。不要直接把整形强制转换为BOOL 型。常见的错误发生在把数组大小，指针的值或者逻辑位运算的结果赋值到BOOL型中，而这样就导致BOOL 值的仅取决于之前整形值的最后一个字节，有可能出现整形值不为0但被转为NO的情况。应此把整形转为BOOL型的时候请使用ternery操作符，保证返回YES 或NO 值。</p>
<p>   在BOOL，_BOOL 以及bool (见C++ Std 4.7.4, 4.12以及C99 Std 6.3.1.2)之间可以安全的交换值或转型。但BOOL 和Boolean 之间不可，所以对待Boolean 就像上面讲的整形一样就可以了。在Objective-C函数签名里仅使用BOOL 。</p>
<p>   对BOOL值使用逻辑运算(&amp;&amp;, ||, ! )都是有效的，返回值也可以安全的转为BOOL型而不需要ternery操作符。</p>
<p>iOS代码 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// AVOID  </span><br><span class="line">- (BOOL)isBold &#123;  </span><br><span class="line">  return [self fontTraits] &amp; NSFontBoldTrait;  </span><br><span class="line">&#125;  </span><br><span class="line">- (BOOL)isValid &#123;  </span><br><span class="line">  return [self stringValue];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// GOOD  </span><br><span class="line">- (BOOL)isBold &#123;  </span><br><span class="line">  return ([self fontTraits] &amp; NSFontBoldTrait) ? YES : NO;  </span><br><span class="line">&#125;  </span><br><span class="line">- (BOOL)isValid &#123;  </span><br><span class="line">  return [self stringValue] != nil;  </span><br><span class="line">&#125;  </span><br><span class="line">- (BOOL)isEnabled &#123;  </span><br><span class="line">  return [self isValid] &amp;&amp; [self isBold];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   还有，不要把 BOOL 型变量直接与 YES 比较。这样不仅对于精通C的人很有难度，而且此条款的第一点也说明了这样做未必能得到你想要的结果。</p>
<p>iOS代码 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// AVOID  </span><br><span class="line">BOOL great = [foo isGreat];  </span><br><span class="line">if (great == YES)  </span><br><span class="line">  // ...be great!  </span><br><span class="line">  </span><br><span class="line">// GOOD  </span><br><span class="line">BOOL great = [foo isGreat];  </span><br><span class="line">if (great)  </span><br><span class="line">  // ...be great!</span><br></pre></td></tr></table></figure>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>   属性总的来说是遵循如下告诫的: 属性是Objective-C 2.0的特性，所以只能跑在iPhone以及MacOS X 10.5(leopard)或更高的版本。点表示法访问属性是不被允许的。</p>
<h3 id="命名-1"><a href="#命名-1" class="headerlink" title="命名"></a>命名</h3><p>   一个有属性关联实例变量都要在后面加下划线，而该属性的名称就是实例变量不加尾部的下划线的名字。</p>
<p>   使用@synthesize 标识以正确的重命名属性。</p>
<p>iOS代码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">@private</span>  </span><br><span class="line">  <span class="built_in">NSString</span> *name_;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;  </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span>  </span></span><br><span class="line"><span class="keyword">@synthesize</span> name = name_;  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p>   在类接口声明里，属性的声明必须紧挨着实例变量块声明之后。类定义里，属性的定义必须紧挨着@implementation块。缩进和@interface或@implementation是一样的。    </p>
<p>iOS代码 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">@private</span>  </span><br><span class="line">  <span class="built_in">NSString</span> *name_;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;  </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span>  </span></span><br><span class="line"><span class="keyword">@synthesize</span> name = name_;  </span><br><span class="line">- (<span class="keyword">id</span>)init &#123;  </span><br><span class="line">...  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="对字符串使用拷贝特性"><a href="#对字符串使用拷贝特性" class="headerlink" title="对字符串使用拷贝特性"></a>对字符串使用拷贝特性</h3><p>   NSString 类型的属性应该永远声明为带有copy attribute </p>
<p>   这点是因为NSString 的setters 永远使用copy 而不是retain 。</p>
<p>   永远不要对CFType属性使用synthesize </p>
<p>   CFType类型应该永远遵守@dynamic的实现规则。</p>
<p>   因为CFType类型不能有reatin 属性特性，开发者必须自己维护。(下面不懂，原文In the rare case that you do actually want assignment it is better to make that completely clear by actually implementing the setter and getter and commenting why that is the case. )</p>
<p>  列出所有的实现指令 </p>
<p>  为所有属性使用实现指令，即使默认是@dynamic</p>
<p>  尽管@dynamic是默认的，显式的列出所有属性实现指令还是让类中的每个属性更加清楚。</p>
<p>iOS代码 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AVOID  </span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span>  </span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name;  </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span>  </span></span><br><span class="line">.  </span><br><span class="line">.  </span><br><span class="line">.  </span><br><span class="line">- (<span class="built_in">NSString</span>*)name &#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="string">@"foo"</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// GOOD  </span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span>  </span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name;  </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span>  </span></span><br><span class="line"><span class="keyword">@dynamic</span> name;  </span><br><span class="line">.  </span><br><span class="line">.  </span><br><span class="line">.  </span><br><span class="line">- (<span class="built_in">NSString</span>*)name &#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="string">@"foo"</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>   属性使用过犹不及。默认情况，所有的synthesized setters 以及 getters  默认都是原子性的，显然所有的get，set方法都过度使用了同步方法。所以除非你确实需要原子性，否则都将你的属性声明为nonatomic </p>
<h3 id="点表示法"><a href="#点表示法" class="headerlink" title="点表示法"></a>点表示法</h3><p>   我们禁止使用点表示法是基于如下理由的:      </p>
<ul>
<li>点表示法不过是标准函数调用的语法糖，它的可读性很有争议。也不过就是换个形式调用函数而已。      </li>
<li>它使得提领操作含糊不请.首先看: [foo setBar:1] 很清楚你就明白这是Objective-C对象上的操作。那么看 foo.bar = 1 就不太清楚到底是对Objective-C的对象还是结构体/公用体/C++类进行操作了。      </li>
<li>它使得函数调用看起来就像getters         </li>
</ul>
<p>iOS代码 </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *upperCase = <span class="string">@"foo"</span>.uppercaseString;</span><br></pre></td></tr></table></figure>
<p>   不仅使人困惑，也很难在代码审核的时候检查出来。     </p>
<ul>
<li><p>它隐藏了函数调用</p>
<p>iOS代码 </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar.value += 10;</span><br></pre></td></tr></table></figure>
<p> 这实际上做了两次函数调用(一次get一次set)，而如果你的类很复杂的话，你发现一大堆事都在幕后做完了。</p>
<h2 id="Cocoa模式"><a href="#Cocoa模式" class="headerlink" title="Cocoa模式"></a>Cocoa模式</h2><h3 id="委托模式"><a href="#委托模式" class="headerlink" title="委托模式"></a>委托模式</h3><p> 委托对象不应该是retain </p>
<p> 一个实现委托模式的类应该:    </p>
<ol>
<li>实例变量命名为delegate_ 以显示这是个委托       </li>
<li>因此，访存方法名就为delegate 和setDelegate      </li>
<li>delegate_ 变量不能设为retain       </li>
</ol>
<h3 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h3><ul>
<li><p>将模型与视图分离，将控制器从视图和模型中分离，回调APIs使用@protocol </p>
</li>
<li><p>模型与视图分离: 不要对模型或数据源的表现形式做任何假设。保持数据与表现层的接口的抽象性。模型不对视图有任何了解(一个好的实践就是询问你自己是否能对数据有多个不同形式的表现方法)</p>
</li>
<li><p>控制器从视图和模型中分离: 不要把”业务逻辑”放到视图相关的类；这会导致代码可复用性下降。让控制器的类承管代码，但不要对表现形式做太多假设。</p>
</li>
<li><p>用@protocol 定义回调APIs: 如果不是所有的方法都必须实现就使用@optional (例外:在Objecitve-C 1.0的时候，@optional 还不可用，所以用类别去定义一个”非标准协议(informal protocol)”)</p>
</li>
</ul>
<p>最后的最后，这篇文章会尽量的完善，不停的矫正，以便让自己形成一个良好的代码习惯</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/09/03/c函数实用函数/" rel="next" title="c函数实用函数">
                <i class="fa fa-chevron-left"></i> c函数实用函数
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/09/03/iOS-架构思想漫谈/" rel="prev" title="iOS 组件化+热切换+热更新+MVVM 架构思想漫谈">
                iOS 组件化+热切换+热更新+MVVM 架构思想漫谈 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
        
  <script>
    window._bd_share_config = {
      "common": {
        "bdText": "",
        "bdMini": "1",
        "bdMiniList": false,
        "bdPic": ""
      },
      "image": {
        "viewList": ["tsina", "douban", "sqq", "qzone", "weixin", "twi", "fbook"],
        "viewText": "分享到：",
        "viewSize": "16"
      },
      "slide": {
        "bdImg": "5",
        "bdPos": "left",
        "bdTop": "100"
      }
    }
  </script>

<script>
  with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/static/api/js/share.js?cdnversion='+~(-new Date()/36e5)];
</script>

      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/localImage/background.png"
                alt="Duan yutian" />
            
              <p class="site-author-name" itemprop="name">Duan yutian</p>
              <p class="site-description motion-element" itemprop="description">雾里看花</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://lx.nextdev.cn/" title="凌霄的博客" target="_blank">凌霄的博客</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#总览"><span class="nav-number">1.</span> <span class="nav-text">总览</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#背景知识"><span class="nav-number">1.1.</span> <span class="nav-text">背景知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#间隔与格式化"><span class="nav-number">1.2.</span> <span class="nav-text">间隔与格式化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#空格对tab键"><span class="nav-number">1.2.1.</span> <span class="nav-text">空格对tab键</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#行长度"><span class="nav-number">1.2.2.</span> <span class="nav-text">行长度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法声明与定义"><span class="nav-number">1.3.</span> <span class="nav-text">方法声明与定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#方法调用"><span class="nav-number">1.3.1.</span> <span class="nav-text">方法调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#public-和-private"><span class="nav-number">1.3.2.</span> <span class="nav-text">@public 和 @private</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#异常"><span class="nav-number">1.3.3.</span> <span class="nav-text">异常</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命名"><span class="nav-number">1.4.</span> <span class="nav-text">命名</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件命名"><span class="nav-number">1.4.1.</span> <span class="nav-text">文件命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Objective-C"><span class="nav-number">1.4.2.</span> <span class="nav-text">Objective-C++</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类命名"><span class="nav-number">1.4.3.</span> <span class="nav-text">类命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类别命名"><span class="nav-number">1.4.4.</span> <span class="nav-text">类别命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Objective-C-方法命名"><span class="nav-number">1.4.5.</span> <span class="nav-text">Objective-C 方法命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量命名"><span class="nav-number">1.4.6.</span> <span class="nav-text">变量命名</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#一般变量命名"><span class="nav-number">1.4.6.1.</span> <span class="nav-text">一般变量命名</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例变量"><span class="nav-number">1.4.6.2.</span> <span class="nav-text">实例变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#常量"><span class="nav-number">1.4.6.3.</span> <span class="nav-text">常量</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#注释"><span class="nav-number">1.5.</span> <span class="nav-text">注释</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#文件注释"><span class="nav-number">1.5.1.</span> <span class="nav-text">文件注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#声明部分注释"><span class="nav-number">1.5.2.</span> <span class="nav-text">声明部分注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现部分注释"><span class="nav-number">1.5.3.</span> <span class="nav-text">实现部分注释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象所有权"><span class="nav-number">1.5.4.</span> <span class="nav-text">对象所有权</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cocoa和Objective-C特性"><span class="nav-number">1.6.</span> <span class="nav-text">Cocoa和Objective-C特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#成员变量应该定义为-private"><span class="nav-number">1.6.1.</span> <span class="nav-text">成员变量应该定义为@private</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#明确指定初始化函数"><span class="nav-number">1.6.2.</span> <span class="nav-text">明确指定初始化函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重写指定初始化函数"><span class="nav-number">1.6.3.</span> <span class="nav-text">重写指定初始化函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化"><span class="nav-number">1.6.4.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#保持公有API简明"><span class="nav-number">1.6.5.</span> <span class="nav-text">保持公有API简明</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#import-和-include"><span class="nav-number">1.7.</span> <span class="nav-text">#import 和 #include</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#根据头文件的语言去选择合适的导入方式。"><span class="nav-number">1.7.1.</span> <span class="nav-text">根据头文件的语言去选择合适的导入方式。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用框架根"><span class="nav-number">1.7.2.</span> <span class="nav-text">使用框架根</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象赋值时尽量采用autorelease-而不是retian-模式。"><span class="nav-number">1.7.3.</span> <span class="nav-text">对象赋值时尽量采用autorelease 而不是retian 模式。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Setters-copy-NSStrings"><span class="nav-number">1.7.4.</span> <span class="nav-text">Setters copy NSStrings</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#nil检查"><span class="nav-number">1.7.5.</span> <span class="nav-text">nil检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BOOL类型陷阱"><span class="nav-number">1.7.6.</span> <span class="nav-text">BOOL类型陷阱</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#属性"><span class="nav-number">1.8.</span> <span class="nav-text">属性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#命名-1"><span class="nav-number">1.8.1.</span> <span class="nav-text">命名</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#位置"><span class="nav-number">1.8.2.</span> <span class="nav-text">位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对字符串使用拷贝特性"><span class="nav-number">1.8.3.</span> <span class="nav-text">对字符串使用拷贝特性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#原子性"><span class="nav-number">1.8.4.</span> <span class="nav-text">原子性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#点表示法"><span class="nav-number">1.8.5.</span> <span class="nav-text">点表示法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Cocoa模式"><span class="nav-number">1.9.</span> <span class="nav-text">Cocoa模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#委托模式"><span class="nav-number">1.9.1.</span> <span class="nav-text">委托模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MVC模式"><span class="nav-number">1.9.2.</span> <span class="nav-text">MVC模式</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Duan yutian</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://Duan.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://yoursite.com/2018/09/03/object-c编码规范/';
          this.page.identifier = '2018/09/03/object-c编码规范/';
          this.page.title = 'object-c编码规范';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://Duan.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  














  





  

  

  

  
  

  

  

  

  <script type="text/javascript" src="/js/src/crash_cheat.js"></script>
<script src="/live2dw/lib/L2Dwidget.min.js?0c58a1486de42ac6cc1c59c7d98ae887"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":80,"height":150},"mobile":{"show":true},"log":false});</script></body>
</html>

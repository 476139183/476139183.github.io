<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>段雨田的Blog</title>
  
  <subtitle>一个不知所云的人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-25T14:45:17.457Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Duan yutian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>是它，是它，就是它！--&lt;小丑回魂&gt;</title>
    <link href="http://yoursite.com/2018/09/25/%E6%98%AF%E5%AE%83%EF%BC%8C%E6%98%AF%E5%AE%83%EF%BC%8C%E5%B0%B1%E6%98%AF%E5%AE%83%EF%BC%81/"/>
    <id>http://yoursite.com/2018/09/25/是它，是它，就是它！/</id>
    <published>2018-09-25T08:29:09.000Z</published>
    <updated>2018-09-25T14:45:17.457Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>二零一七年九月份，北美炸出一部现象级电影，一举打破北美九月份票房影史纪录，完全碾压之前开启招魂恐怖电影宇宙的《安娜贝尔2》！成本仅3500万美元，上映两周票房已跻身R级恐怖片影史第三。影片改编自恐怖大师史蒂芬·金的同名作品，名字只有一个字：它（It）。</p></blockquote><p>是它，是它，就是它！2017年度恐怖最佳！</p><a id="more"></a><p>《小丑回魂》，英文名It，原译“它”，<code>从英文直译角度来说，更让人浮想联翩：这部恐怖片面对的是什么“鬼”</code>。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvm5gl3jsij30go0am0uv.jpg" alt=""></p><p>影片改编自恐怖大师 <em>史蒂芬·金</em>（<code>著有肖申克的救赎，魔女嘉莉，迷雾，1408幻影凶间等</code>）1986年的同名经典小说，一经上映便成黑马，打破多项票房纪录：</p><h3 id="北美恐怖片票房首映日影史最高，9月北美票房影史最高……"><a href="#北美恐怖片票房首映日影史最高，9月北美票房影史最高……" class="headerlink" title="北美恐怖片票房首映日影史最高，9月北美票房影史最高……"></a>北美恐怖片票房首映日影史最高，9月北美票房影史最高……</h3><p>从9月8日公映至今，评分人数已超8万人，IMDb评分仍保持8.0分。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm5h2zhizj30fq05hmxq.jpg" alt=""></p><p>就是这货：</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvm5hwg11wg307z03r1kx.gif" alt=""></p><blockquote><p> 放慢0.5倍速，截自预告</p></blockquote><p>烂番茄85分，Metacritic70分，都表现不俗。但你要知道，在IMDb，评分过7的恐怖片就是佳作，评分超8分，人数超2.5万人的恐怖片更<em>不超过20部</em>。恐怖类型片下，《小丑回魂》<em>跻身第五</em>，排在它前面的是两部经典：[闪灵]和[怪形]（[闪灵]也是根据史蒂芬·金小说改编）。</p><p>作为一部成本仅3500万美元的R级恐怖片，《小丑回魂》票房现在已挤进<em>影史第三</em>。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvm5imnbw7j30gb0g90uq.jpg" alt=""></p><p>别猜了，第一是[异形]，第二是希胖的[精神病患者]</p><p><a href="https://baike.baidu.com/tashuo/authorcenter?authorId=465f421a9dfba9bbf1492220" target="_blank" rel="noopener"> 秋裤 </a>(本文作者)是恐怖片变态级粉丝，刷完长篇巨制的原著和90年代的剧集之后，今天跟大家解析下这个票房和口碑都爆炸的“它”。</p><h2 id="小丑"><a href="#小丑" class="headerlink" title="小丑"></a>小丑</h2><h3 id="来自超级宇宙的死光"><a href="#来自超级宇宙的死光" class="headerlink" title="来自超级宇宙的死光"></a>来自超级宇宙的死光</h3><h3 id="故事简介"><a href="#故事简介" class="headerlink" title="故事简介"></a>故事简介</h3><h4 id="德里镇儿童失踪案"><a href="#德里镇儿童失踪案" class="headerlink" title="德里镇儿童失踪案"></a>德里镇儿童失踪案</h4><p>故事发生在虚构的缅因州小镇德里（Derry），它已经被诡异的恐怖事件笼罩了上百年。</p><p>这些诡异的恐怖事件就是神秘的儿童失踪案。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvm5kxhzdjg307s030awu.gif" alt=""></p><blockquote><p>预告</p></blockquote><p>男主弟弟乔治·邓布洛的失踪是影片故事的开端，这也是原著中开篇经典场景，预告中就可以看到：</p><p>雨中乔治拿着哥哥威廉做的纸船玩耍，而纸船SS.乔治号顺着水流坠入下水管道。</p><p>在下水管道中，乔治遇到了自称潘尼歪斯Pennywise（又译“小气鬼”）的小丑。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvm5liydcrg306v02p7rn.gif" alt=""></p><blockquote><p>预告</p><blockquote><p>小丑演员：<br><code>比尔.斯科斯佳</code>,<code>导演需要小丑翻白眼，但这不是一般的眼珠子往上翻这么简单，而是需要两个眼珠子分别往左右方向翻</code>.本来导演说做特效完成，但<code>比尔.斯科斯佳</code>说不需要，因为他居然能做到两个眼珠子往左右不同方向翻白眼。这真是#@*&amp;%牛^#B啊。</p></blockquote></blockquote><p>诡异的不是孩子的失踪，而是留下的<code>被肢解的尸体</code>。乔治胳膊被撕下，有的遇难者的遗体甚至散落各处。影片开始不到5分钟就呈现了这个经典的场景，不少观众寒毛竖起。</p><p>和镇上一些其他孩子一样，哥哥威廉开始看到可怕的东西，原著中有的孩子看到巨型飞鸟，有的看到木乃伊和狼人，这些元素在影片中被改编，成为致敬的彩蛋。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvm5lu74e4j30ga08rq3d.jpg" alt=""></p><blockquote><p>预告中小丑变化出狼人的手</p></blockquote><p>小女孩贝弗莉从盥洗池中听到失踪的孩子的惨叫，靠近去听却看到鲜血喷涌，这是原著中最惊悚的场景之一，在影片中被完美呈现。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm5mbj8shg307o0337e2.gif" alt=""></p><blockquote><p>预告</p></blockquote><p>然而最让人恐惧的还不是这怪异的血崩，而是所有的大人对此都视而不见。想象一下，你眼睁睁的看着亲人用鲜血淋漓的洗手槽洗脸是什么样的感受？</p><p>[小丑回魂]的恐惧来源于<code>未知与无助</code>——最能给你安全感的人对你的恐惧的无视。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm5mbj8shg307o0337e2.gif" alt=""></p><blockquote><p>小丑回魂1990</p></blockquote><h4 id="窝囊废联盟Losers’-Club"><a href="#窝囊废联盟Losers’-Club" class="headerlink" title="窝囊废联盟Losers’ Club"></a>窝囊废联盟Losers’ Club</h4><p>Losers’ Club是影片主角，有些翻译成“失败者俱乐部”，但感觉还是国内早期原版翻译的比较好——窝囊废联盟。</p><p>小镇上无数的孩子被这种恐怖折磨。其中有7个孩子，命中注定要走到一起，他们就是窝囊废联盟Loser’s club。</p><p>可以看到石膏上写的Loser（窝囊废）字样，但被改成Lover（情人），原著中他们都在埃迪手臂的石膏上签名，代表着联盟的约定与承诺。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm5p5oc8og308h03j7sm.gif" alt=""></p><blockquote><p>预告</p></blockquote><p>他们是德里镇最普通的孩子，是每个成年人曾经的自己。</p><p>他们有的出生在贫民区，有的被同学骂作肥猪，有的被大孩子欺负，而欺负他们的人称他们为窝囊废Loser，这是原著中他们名字的由来。但他们长大后都很成功，绝不是什么窝囊废或失败者。</p><p>他们在暑假相遇，尽情的玩耍，终于，他们都谈到自己看到的恐怖形象。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvm5pu1ekqg30cn056hdt.gif" alt=""></p><blockquote><p>预告</p></blockquote><p>虽然每个人看到的景象各不相同，但恐怖之源都指向同一个东西—— <code>它（it）</code>，也就是乔治的弟弟在下水管道中看到潘尼歪斯小丑。</p><p>也就是乔治的弟弟在下水管道中看到 <code>潘尼歪斯小丑</code>。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvm5qgjaaqg30gm0bc7g6.gif" alt=""></p><blockquote><p>预告</p></blockquote><p>七个人袒露心扉，成为挚友，互相支持，他们组成了窝囊废联盟，决定和这个魔鬼小丑战斗到底。</p><p>然而事情并没有这么简单。</p><h4 id="潘尼歪斯小丑"><a href="#潘尼歪斯小丑" class="headerlink" title="潘尼歪斯小丑"></a>潘尼歪斯小丑</h4><p>如何击败小丑，窝囊废联盟毫无头绪。他们甚至不知道这个东西到底是什么，只好管它叫做</p><p><code>“它”</code>。</p><p>窝囊废联盟发现不仅孩子们饱受它的折磨，整个小镇都被它玩弄鼓掌，而且玩弄了很久，至少有 <code>200年</code> 。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm5qrrx5sj30q90ao3zr.jpg" alt=""></p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvm5qy1xu9j30qc0al0tj.jpg" alt=""></p><blockquote><p>预告，小胖墩本在德里史料中发现久远的意外事件</p></blockquote><p>从1900年，这个恶魔就开始吞噬德里。他们发现，<code>每过27年</code>，德里的失踪案和死亡率就会出现一个峰值。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm5shfh71g308203uwsd.gif" alt=""></p><blockquote><p>预告</p></blockquote><p>更令人感到脊背发凉的是，2017年版的[小丑回魂]和1990年版相隔27年，1990年版男主角威廉的扮演者乔纳森·布兰迪斯于2003年自杀身亡，正好也是27岁。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvm5ss6mzdj30co063jrx.jpg" alt=""></p><blockquote><p>乔纳森·布兰迪斯</p></blockquote><p>2017年版的小丑扮演者比尔·斯卡斯加德现在也是27岁。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvm5t04wdbj30i408t75b.jpg" alt=""></p><blockquote><p>比尔·斯卡斯加德</p></blockquote><p>小丑似乎从小镇建立之日起就一直存在，每隔27年，它就会重返人间，残害儿童，更吞噬这个小镇。</p><p>窝囊废联盟的7个孩子决定站出来，和这个东西决斗，不管它是什么……</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvm5tjlwahg307x04n4ly.gif" alt=""></p><blockquote><p>预告</p></blockquote><h3 id="小丑来自何方？"><a href="#小丑来自何方？" class="headerlink" title="小丑来自何方？"></a>小丑来自何方？</h3><p>和[蝙蝠侠]中的小丑Joker一样，潘尼歪斯小丑已经成为一个经典形象。第一部大获成功，[小丑回魂II]已经板上钉钉，第一部中许多疑问将在第二部中揭开，其中最大的疑问就是小丑的身世。</p><p>小丑之所以这么令人恐惧，也是来自他神秘的身世，显然，它在德里已经存在了很久很久。  </p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm5tss5iwj30nt09u75d.jpg" alt=""></p><blockquote><p>预告</p></blockquote><h4 id="吞噬德里镇两百年"><a href="#吞噬德里镇两百年" class="headerlink" title="吞噬德里镇两百年"></a>吞噬德里镇两百年</h4><p>影片中，小胖墩本通过简报发现小丑其实已经在德里镇存在了200多年，在小镇历史上无数的意外和死亡事件中，都有潘尼歪斯的身影。</p><p>比如发生在1906年复活节的 <code>钢铁厂爆炸事件</code> ：102人死亡，其中88人为儿童。</p><p>现场有人目击到小丑。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm5u1kgwhj30qc0al0tj.jpg" alt=""></p><blockquote><p>预告</p></blockquote><p>比如27年后的 <code>黑点酒吧大火</code>，黑人男孩麦克的父亲就目睹了整个事件。</p><p>麦克的父亲看到了小丑。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvm5uhqsaig308q04ktjn.gif" alt=""></p><blockquote><p>预告</p></blockquote><p>镇上的许多大人也都见过小丑，但他们都闭口不谈，选择遗忘，比如麦克的父亲，直到临死前才告诉儿子，大火的那一天，他看到天空中有一只巨鸟，就像后来麦克看到的一样。</p><p>它不是在飞，而是悬停在空中，它在 <code>飘</code>，而它的翅膀上还绑着 <code>气球</code>。</p><blockquote><blockquote><p>“它没有停在空中，”他说，“他是在飘。在飘。它两边翅膀上都绑了一大堆气球，它在飘。”说完他就睡着了。—— 《小丑回魂》穆卓芸译本</p></blockquote></blockquote><p>而 <code>“飘”</code>，像气球一样飘，正是小丑最令人胆寒的台词。</p><p>在小丑的世界，飘意味着死亡。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvm5ur8rmpj30m909pjro.jpg" alt=""></p><blockquote><p>预告</p></blockquote><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvm5uy1wy3j30qo0k0myi.jpg" alt=""></p><blockquote><p>小丑回魂1990</p></blockquote><h4 id="来自宇宙的死光"><a href="#来自宇宙的死光" class="headerlink" title="来自宇宙的死光"></a>来自宇宙的死光</h4><p>原著中，最早的神秘事件发生1741年，德里镇早期的340名居民突然在10月份消失不见。可怕的是，周边城镇对此事没有任何记载。</p><p>小丑似乎已经存在了200多年。</p><p>事实上，小丑已经存在了 <code>数百万年</code> 。</p><p>在原著中，小丑被描述为来自外太空的东西，早在人类诞生之前，它坠落地球，而它是要 <code>“抢夺地球上所有女人和强暴所有男人”</code>。</p><blockquote><blockquote><p>“告诉你的朋友，我是某个灭绝物种的最后幸存者，”它一边说着，一边摇摇晃晃跟着她走下门廊，露出瘦削的狞笑，“是垂死星球上的唯一生还者。我来是为了抢走所有女人……强暴所有男人……”——《小丑回魂》穆卓芸译本</p></blockquote></blockquote><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm5vrx8rbg30710554qp.gif" alt=""></p><blockquote><p>小丑回魂1990中对死光的呈现</p></blockquote><p>它没有实体，只有一个名字—— <code>死光Deadlight</code>。</p><p>它会读懂你的思想，幻化成你内心最害怕的东西，利用你的恐惧从而吸食脆弱的灵魂。</p><p>所以，不同的人看到小丑会看到不同的景象，有的甚至就是条狗。而有时，小丑还能操控他人，让凡人成为诡异事件的替罪羊。</p><p>比如片中的流氓亨利·鲍威尔，原著中，年老的鲍威尔成为小丑的兵卒，到图书馆大开杀戒，这把刀子来自小丑，由神秘人寄送，最后消失不见。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvm5w00ivsj30g907fdg4.jpg" alt=""></p><h2 id="如何与小丑战斗？"><a href="#如何与小丑战斗？" class="headerlink" title="如何与小丑战斗？"></a>如何与小丑战斗？</h2><p>知道了小丑是什么，接着就要知道如何和它战斗。</p><p>和小丑的战斗第一部中就有所体现，不怕剧透，7个孩子肯定打败了小丑。但真正打败它的方法可能要在第二部中揭晓。</p><h4 id="Chud仪式"><a href="#Chud仪式" class="headerlink" title="Chud仪式"></a>Chud仪式</h4><p>在原著中，提到一种喜玛拉雅人用的驱魔仪式——Chud。</p><p>你需要和魔鬼互相咬住舌头，讲笑话和谜语，如果魔鬼先笑，它就会消失一百年。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvm5wrbygmg30am04e4m4.gif" alt=""></p><blockquote><p>小丑回魂1990</p></blockquote><p>原著中，少年时代的窝囊废联盟和小丑由两场大战，一场在下连接水道的枢纽，内波特街29号，一场在小丑的据点——下水道深处。</p><blockquote><p>预告</p></blockquote><p>剧组还为了下水道镜头专门搭建了实景，因为27年后，窝囊废们还要回来再次和小丑决战。  </p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvm5xem8y4j30go06s75h.jpg" alt=""></p><blockquote><p>花絮</p></blockquote><p>实际上，咬住舌头并不是肉体上的咬住，而是心灵和意志的纠缠。通俗了讲就是战胜恐惧的勇气，和不屈的意志。</p><h4 id="而Chud就是勇敢，挺身而出和信念。"><a href="#而Chud就是勇敢，挺身而出和信念。" class="headerlink" title="而Chud就是勇敢，挺身而出和信念。"></a>而Chud就是勇敢，挺身而出和信念。</h4><p>窝囊废联盟是通过一个叫 <code>“乌龟”</code> 的东西知道这个方法，虽然第一部中没有体现，但已埋下彩蛋。</p><p>乌龟彩蛋：</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm5xlf9zaj30hd074jro.jpg" alt=""></p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvm5xrjk3sj30hg075glq.jpg" alt=""></p><blockquote><p>预告，乐高机器人就是个乌龟</p></blockquote><p>原著中，乌龟告诉威廉一句话，那句话成为他对抗小丑的武器：</p><blockquote><p>他上拳砸柱子，坚信自己见到鬼。      </p></blockquote><blockquote><p>He thrusts his fist against the posts and still insists he sees the ghosts.</p></blockquote><p>威廉小时候口吃很厉害，尤其在弟弟乔治死去以后，恐惧，让他口吃更严重。这句话是她妈妈教他的一个用来矫正口吃的绕口令。</p><p>对抗小丑，你越是恐惧，他就越强大。</p><p>当威廉信心满满，无所畏惧时，他可以流利的说出这个句子，而他无畏的勇气和信念就是他对抗小丑的最大力量。</p><h2 id="史蒂夫·金恐怖宇宙"><a href="#史蒂夫·金恐怖宇宙" class="headerlink" title="史蒂夫·金恐怖宇宙"></a>史蒂夫·金恐怖宇宙</h2><p>提到乌龟，就不得不提史蒂芬·金笔下的恢弘宇宙观。他笔下的故事都有着千丝万缕的联系，甚至可以称为史蒂夫·金恐怖宇宙。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvm5xxzqbhj30zk0m841i.jpg" alt=""></p><blockquote><p>电影黑暗塔概念图</p></blockquote><p>而[小丑回魂]是众多作品的纽带。</p><p>比如德里镇许多罪犯，都被送到了 <code>肖申克监狱</code>。而德里镇还被认为是通往众多宇宙的门户，就像[黑暗塔]。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm5y55qxnj30xc0m4q87.jpg" alt=""></p><blockquote><p>肖申克的救赎，同样改编自史蒂芬·金的原作小说</p></blockquote><p>在[黑暗塔]中，宇宙有12个守护神，其中一个就是乌龟。</p><p>在原著中，窝囊废联盟的成员一直感受到有股力量的支持，这个力量有时就来自乌龟。</p><p>但少年时代的窝囊废们并没有杀死小丑，他立下血誓，27年后，如果小丑重生，他们一定都回来续和小丑战斗。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm5yd156yj30ha06sdgf.jpg" alt=""></p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvm5z0792sj30jw0840t8.jpg" alt=""></p><blockquote><p>预告，对原著中手掌两道疤痕的还原</p></blockquote><p>原著中小说的高潮发生在27年后，最感人的故事也在27年后，远离了德里的6个人分别接到电话，除了一个人畏惧自杀，其他人都毫不犹豫的回到故乡，再次回到那个梦魇之地。</p><p>[小丑回魂2]应该会再现这个高潮，让人无比期待。</p><h2 id="小丑带来的恐惧"><a href="#小丑带来的恐惧" class="headerlink" title="小丑带来的恐惧"></a>小丑带来的恐惧</h2><p>虽然小丑就像是来自外太空的邪恶魔鬼，但[小丑回魂]和温子仁式的恐怖不同，这一点从原著可以读出。</p><p>[小丑回魂]描写的是恐怖本身，但它的内核却不是恐惧，而是人的自私与冷漠。</p><h4 id="为什么只有孩子才能看见小丑的行径？"><a href="#为什么只有孩子才能看见小丑的行径？" class="headerlink" title="为什么只有孩子才能看见小丑的行径？"></a>为什么只有孩子才能看见小丑的行径？</h4><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvm5z8do7yj30qo0k0n18.jpg" alt=""></p><blockquote><p>小丑回魂1990</p></blockquote><p>因为孩子最单纯，他们相信眼睛看到的东西。除此之外，他们相信圣诞老人，就像我们小时候相信月食的时候有吃月亮的天狗。</p><p>而窝囊废联盟的力量也来源于此，他们有着无限的想象力，相信自己，就拥有了力量。</p><p>小丑代表着黑暗与邪恶，窝囊废们代表着勇气与美好。</p><p>没有大人的支持，他们瘦弱的手掌连在一起，便拥有了巨大的（原著中称为原始的）力量。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm5znl9oog30af042nc8.gif" alt=""></p><blockquote><p>预告</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvm5zvy45wj30qo0k0n0f.jpg" alt=""></p><blockquote><p>小丑回魂1990</p></blockquote><h4 id="为什么小丑的行径大人们都视而不见？"><a href="#为什么小丑的行径大人们都视而不见？" class="headerlink" title="为什么小丑的行径大人们都视而不见？"></a>为什么小丑的行径大人们都视而不见？</h4><p>其实并不是他们看不见，而是长大成人后的我们，变得太复杂，不敢面对未知的恐惧，选择无视和遗忘，对可怕的事情更是闭口不谈，以为这样它就能消失。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvm6025fknj30js08yab3.jpg" alt=""></p><p>正如现实世界中，面对路边撕心裂肺的求救，有多少人围观？多少人伸出援手？</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvm608no6sj30m20dpjtz.jpg" alt=""></p><blockquote><p>长春一女子街头遭暴打路人冷漠旁观，图片来自网络</p></blockquote><p>[小丑回魂]中就对原著进行了还原（原著是贝弗莉在被欺负时一个邻居视而不见），本在路边被一群大孩子欺负，路过的两个大人只露出冷漠的眼光。</p><h6 id="这时，小丑的气球出现。"><a href="#这时，小丑的气球出现。" class="headerlink" title="这时，小丑的气球出现。"></a>这时，小丑的气球出现。</h6><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvm60mquixg30aj04ckcw.gif" alt=""></p><blockquote><p>预告</p></blockquote><h6 id="有冷漠，有遗忘的地方就有小丑。"><a href="#有冷漠，有遗忘的地方就有小丑。" class="headerlink" title="有冷漠，有遗忘的地方就有小丑。"></a>有冷漠，有遗忘的地方就有小丑。</h6><p>[小丑回魂]得人心的地方，在于他描绘了在复杂的社会中，站出来的几个人，而那几个人却只是十多岁的孩子。</p><p>冷漠的社会只会更加的冰冷恐怖，必须有人站出来，阻止这些“坏”东西吞噬世界。年少单纯的窝囊废们不知道像大人一样躲在别人身后。</p><p>他们坚信，自己不可以袖手旁观。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvm60u90qnj30ju090gmp.jpg" alt=""></p><h4 id="为什么小丑选择27年后重返人间？"><a href="#为什么小丑选择27年后重返人间？" class="headerlink" title="为什么小丑选择27年后重返人间？"></a>为什么小丑选择27年后重返人间？</h4><p>因为 <code>磨掉一个人、一群人的信念，27年够了</code>。</p><p>傻孩子不懂世故，冒着生命危险跑在最前面，然而27年后呢？他们还会坚持当初的承诺么？</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvm60zqzzgj30jp094q3d.jpg" alt=""></p><blockquote><p>史蒂芬·金接受采访</p></blockquote><p>在[小丑回魂]原著中，27年后，6个窝囊废都远离的了德里，远离了儿时的梦魇，他们也选择遗忘，将曾经可怕的回忆永久的封印。</p><p>但一通电话，将他们再次拖回地狱般恐怖的回忆中。他们大可以事不关己，继续过着自己的生活，眼不见心不烦，对德里置之不理。</p><p>但他们没有任何犹豫，都马不停蹄的回到那个带来恐惧与噩梦的地方，选择继续和魔鬼战斗。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm616xs6kj30qo0k0n08.jpg" alt=""></p><blockquote><p>小丑回魂1990</p></blockquote><p>他们都选择回到家乡，选择再一次站出来，即使他们可能永远被留在黑暗的下水道中。</p><p>正如哈维尔的名言：我们坚持一件事情，并不是因为这样做了会有效果，而是坚信，这样做是对的。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm61ds22uj30qo0k0gp1.jpg" alt=""></p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm61jg1uvj30qo0k00vt.jpg" alt=""></p><blockquote><p>小丑回魂1990</p></blockquote><p>窝囊废们长大成人，他们依然坚信当初的选择，选择直面恐惧，更直面社会的不公与冷漠。</p><p>其实，小丑就在我们身边。</p><p>你会选择听他狂笑，还是站出来和它战斗？</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvm61p9a5sj30qo0k040p.jpg" alt=""></p><blockquote><p>小丑回魂1990</p></blockquote><h2 id="我的观后感"><a href="#我的观后感" class="headerlink" title="我的观后感"></a>我的观后感</h2><p>这是一部细思极恐的电影，<code>连斯蒂芬金自己都说，这种《小丑回魂》类型的小说，我只写一次就好，因为他自己写的时候都觉得太恐怖</code>. 但实际上看的时候不感到多恐怖，毕竟不同于那种声乐渲染的鬼片，反而有匪夷所思的感觉，但看完之后会让人有一点点反思，电影被归类恐怖片却是在教人如何面对自身恐惧，如何走进充满邪恶鬼怪深渊的黑屋，不是因为年轻气盛不是因为无聊作死，这一切存在于内心的恐惧每个人都必须克服，你不去直视，它便可以依附你掏空你就跟黑山老妖一样，最终把你变成一具行尸走肉，无论你飘在哪里都只能面无表情。（嗯，鸵鸟心理？）</p><p>当然， 小说比起电影更能吸引人的地方在于主人公们是在27年后的成年时代与27年前的童年时期进行平行空间交叉叙事，小丑27年轮回一次，这两段时空的交横更能刻画出各个人物的性格成长，让读者在对比中发现蛛丝马迹。所以，让我们一起期待下一部吧。</p><p>比如 <code>《小丑回魂2》将于2019年9月6日上映</code>。</p><h2 id="文章主要来源"><a href="#文章主要来源" class="headerlink" title="文章主要来源"></a>文章主要来源</h2><p><a href="https://baike.baidu.com/tashuo/browse/content?id=753cd009c6bf2726a0c031f9" target="_blank" rel="noopener">百度TA说</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;二零一七年九月份，北美炸出一部现象级电影，一举打破北美九月份票房影史纪录，完全碾压之前开启招魂恐怖电影宇宙的《安娜贝尔2》！成本仅3500万美元，上映两周票房已跻身R级恐怖片影史第三。影片改编自恐怖大师史蒂芬·金的同名作品，名字只有一个字：它（It）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是它，是它，就是它！2017年度恐怖最佳！&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="http://yoursite.com/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>推荐两个实用开源项目</title>
    <link href="http://yoursite.com/2018/09/21/%E6%8E%A8%E8%8D%90%E4%B8%A4%E4%B8%AA%E5%AE%9E%E7%94%A8%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    <id>http://yoursite.com/2018/09/21/推荐两个实用开源项目/</id>
    <published>2018-09-21T06:48:43.000Z</published>
    <updated>2018-09-21T07:17:18.405Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/Bm6cwzA2yAxr5kpDwUz9YQ" target="_blank" rel="noopener">文章来源</a></p><p>终于周五了，周末一定要好好休息一波，每逢周五的文章都会较为轻松。</p><p>大家在平时开发过程中，是不是经常要查一些单词的意思，或者某个中文词语、某段中文希望翻译成英文。</p><p>一般情况下，我们可以通过某个翻译app，比如有道；又或者打开浏览器打开web 在线翻译。</p><p>那么这两个操作我还是觉得有点重，我觉得这样翻译才有意思：</p><p><img src="/2018/09/21/推荐两个实用开源项目/640.gif" alt="目录">    </p><a id="more"></a> <p>我们可以不跳出 Studio，直接翻译，或者在自己喜欢的 命令行工具中直接敲英文。</p><p>是不是更加轻量。</p><p>那么还有个场景，例如我正在看源码，看到一段英文注释或者单词想要翻译，当时我正在源码中操作，我并不希望copy 到命令行，再来看结果，你可以这样：</p><p><img src="/2018/09/21/推荐两个实用开源项目/640-1.gif" alt="目录">    </p><p>这样的操作就连贯很多了，而且支持多种语言，还能直接播放声音。</p><p>至于推荐它还有个更大的原因就是，目前有700多次提交，近期还在更新。</p><p>接下来就是详细介绍一哈了。</p><h2 id="1-翻译插件"><a href="#1-翻译插件" class="headerlink" title="1. 翻译插件"></a>1. 翻译插件</h2><p><a href="https://github.com/YiiGuxing/TranslationPlugin" target="_blank" rel="noopener">https://github.com/YiiGuxing/TranslationPlugin</a></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>网络良好的很开心了，搜索安装即可：</p><p><code>Preferences(Settings)</code> &gt; <code>Plugins</code> &gt; <code>Browse repositories...</code> &gt; 搜索并找到 <code>Translation</code> &gt; <code>Install Plugin</code></p><p>网络不太流畅的，可以下载zip 包: </p><p><code>下载最新发布的插件包</code> -&gt; <code>Preferences(Settings)</code> &gt; <code>Plugins</code> &gt; <code>Install plugin from disk...</code></p><p>这个文档写的很清楚，而且还有一些别的功能，比如，我并不是划词查询，我就想查某个单词的意思，也可以唤起翻译面板：</p><p><img src="/2018/09/21/推荐两个实用开源项目/640-2.gif" alt="目录">    </p><p>当然这样就是通过快捷键打开了，具体支持哪些快捷键，自己看文档吧。</p><h2 id="2-命令行翻译"><a href="#2-命令行翻译" class="headerlink" title="2. 命令行翻译"></a>2. 命令行翻译</h2><blockquote><p>项目介绍：不喜欢安装有道词典的应用程序，因为太耗资源还一堆广告，但是用浏览器打开dict.youdao.com也挺麻烦的，不是吗？快来试试我的有道词典命令行工具吧！</p></blockquote><p> <a href="https://github.com/kenshinji/yddict" target="_blank" rel="noopener">https://github.com/kenshinji/yddict</a></p><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install yddict -g</span><br></pre></td></tr></table></figure><blockquote><p>安装如果因为权限为问题失败，可以加上以管理员身份运行；如果安装完成后提示node.js 版本过低，记得升级。</p></blockquote><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><code>yd &lt;要查询的单词&gt;</code></p><p>默认情况下，查出来的单词是白色的文字，如果 AS 是默认主题，那么就会看不到。当然，颜色支持我们自己设置。</p><p>默认在 <em><code>用户主目录下.config/configstore/yddict.json</code></em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.config/configstore/yddict.json </span><br><span class="line">&#123;</span><br><span class="line">    &quot;color&quot;: &quot;green&quot;,</span><br><span class="line">    &quot;spinner&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以自由修改这个字的颜色。</p><p>推荐完毕，祝大家周末愉快！</p><p>推荐阅读：</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650826203&amp;idx=1&amp;sn=4c83f119ae3a7e818a65357cb78e5df5&amp;chksm=80b7b145b7c038538ef46e7b16d41b6dc5d622b6a3c72ce67ce9735c49709f011d334e1366f9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">启动优化提升60%</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650826201&amp;idx=1&amp;sn=3b843ffedf6d8fe56288612b0f9360c9&amp;chksm=80b7b147b7c0385171c9a69668abe86921360adfa123c136b13243a0d09fbd3e80723645397c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">给大家分享一个面试经验</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Bm6cwzA2yAxr5kpDwUz9YQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章来源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;终于周五了，周末一定要好好休息一波，每逢周五的文章都会较为轻松。&lt;/p&gt;
&lt;p&gt;大家在平时开发过程中，是不是经常要查一些单词的意思，或者某个中文词语、某段中文希望翻译成英文。&lt;/p&gt;
&lt;p&gt;一般情况下，我们可以通过某个翻译app，比如有道；又或者打开浏览器打开web 在线翻译。&lt;/p&gt;
&lt;p&gt;那么这两个操作我还是觉得有点重，我觉得这样翻译才有意思：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/09/21/推荐两个实用开源项目/640.gif&quot; alt=&quot;目录&quot;&gt;    &lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>MAC安装JDK及环境变量配置</title>
    <link href="http://yoursite.com/2018/09/19/MAC%E5%AE%89%E8%A3%85JDK%E5%8F%8A%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/09/19/MAC安装JDK及环境变量配置/</id>
    <published>2018-09-19T09:45:36.000Z</published>
    <updated>2018-09-21T07:13:10.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h1><ol><li>访问<a href="http://www.oracle.com" target="_blank" rel="noopener">Oracle官网</a>，浏览到首页的底部菜单 ,然后按下图提示操作:     </li></ol><p><img src="http://images2015.cnblogs.com/blog/877813/201601/877813-20160113135011647-96008710.png" alt=""></p><a id="more"></a><ol start="2"><li>点击“JDK DOWNLOAD”按钮：</li></ol><p><img src="http://images2015.cnblogs.com/blog/877813/201601/877813-20160113135051835-861363050.png" alt=""></p><ol start="3"><li>选择“Accept Lisence Agreement”同意协议:</li></ol><p><img src="http://images2015.cnblogs.com/blog/877813/201601/877813-20160113135219866-685515947.png" alt=""></p><ol start="4"><li>点击Mac OS X x64后面的下载链接：<br><img src="http://images2015.cnblogs.com/blog/877813/201601/877813-20160113135306585-54248836.png" alt=""></li></ol><p>下载完成后点击安装包，按提示即可完成安装。</p><ol start="5"><li>打开Finder,可以在下图所示的路径中找到安装好的jdk 1.8.0_40.jdk:(建议直接使用<code>/Library/Java</code>前往,因为我居然找不到该目录)</li></ol><p><img src="http://images2015.cnblogs.com/blog/877813/201604/877813-20160416153110191-1153954158.png" alt=""></p><ol start="6"><li>其中Contents下的Home文件夹，是该JDK的根目录。</li></ol><p><img src="http://images2015.cnblogs.com/blog/877813/201604/877813-20160416153449941-591903183.png" alt=""></p><blockquote><p>其中：</p></blockquote><blockquote><p><code>bin目录</code>下存放JDK用于开发的一些终端命令工具。常见的工具如：<br>“javac”的作用是将java源文件编译为class文件(即自解码文件)；<br>“java”命令的作用是运行class文件。</p></blockquote><blockquote><p><code>db目录</code>下是java开发的一个开源的关系型数据库；</p></blockquote><blockquote><p><code>include目录</code>下是一些C语言的头文件；</p></blockquote><blockquote><p><code>jre目录</code>下JDK所依赖的java运行时；</p></blockquote><blockquote><p><code>lib目录</code>下存放JDK开发工具所依赖的一些库文件；</p></blockquote><blockquote><p><code>man目录</code>下存放JDK开发工具的说明文档。</p></blockquote><ol start="7"><li>安装好JDK后需要配置JDK的环境变量，方法请参考：<a href="http://www.cnblogs.com/quickcodes/p/5398709.html" target="_blank" rel="noopener">Mac下如何配置环境变量</a>，方法有部分不对，下面以配置JDK的环境变量为例，示范如何配置环境变量，后续在安装Android、Maven、MongoDB等时都会需要配置相应的环境变量。</li></ol><h1 id="配置JDK的环境变量"><a href="#配置JDK的环境变量" class="headerlink" title="配置JDK的环境变量"></a>配置JDK的环境变量</h1><ol><li><p>打开终端。（cd /Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk）</p></li><li><p>如果你是第一次配置环境变量，可以使用 <code>touch ~/.bash_profile</code> 创建一个 <code>.bash_profile</code> 的隐藏配置文件(如果你是为编辑已存在的配置文件，则使用 <code>open -e ~/.bash_profile</code> 命令)：</p></li></ol><p><img src="http://images2015.cnblogs.com/blog/877813/201604/877813-20160416164957082-1418925235.png" alt=""></p><ol start="3"><li>输入 <code>open -e ~/.bash_profile</code> 命令：</li></ol><p><img src="http://images2015.cnblogs.com/blog/877813/201604/877813-20160416165627113-2136824168.png" alt=""></p><blockquote><p>ps:如果没有权限 就使用<code>sudo touch ~/.bash_profile</code>,而编辑的时候我是用sublime打开的。</p></blockquote><ol start="4"><li>输入如下配置：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH:.</span><br><span class="line">CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export PATH</span><br><span class="line">export CLASSPATH</span><br></pre></td></tr></table></figure><p>然后保存关闭该窗口。（我的是jdk-10.0.2.jdk）</p><p><img src="https://ws3.sinaimg.cn/large/0069RVTdgy1fv5of7a721j30zk0mwacf.jpg" alt=""></p><p>5.使用”source ~/.bash_profile”使配置生效 然后输入”java -version”，如果看到jdk版本为10.0.2则说明配置已经生效：</p><p>6.输入 echo $JAVA_HOME 显示刚才配置的路径</p><p><img src="https://ws1.sinaimg.cn/large/0069RVTdgy1fv5jtc8u1ej30fu0a6mxk.jpg" alt=""></p><p><img src="http://images2015.cnblogs.com/blog/877813/201604/877813-20160416170843160-212359895.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装JDK&quot;&gt;&lt;a href=&quot;#安装JDK&quot; class=&quot;headerlink&quot; title=&quot;安装JDK&quot;&gt;&lt;/a&gt;安装JDK&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;访问&lt;a href=&quot;http://www.oracle.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Oracle官网&lt;/a&gt;，浏览到首页的底部菜单 ,然后按下图提示操作:     &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/877813/201601/877813-20160113135011647-96008710.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jenkins 安装</title>
    <link href="http://yoursite.com/2018/09/19/jenkins-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2018/09/19/jenkins-自动化部署/</id>
    <published>2018-09-19T09:39:58.000Z</published>
    <updated>2018-09-21T08:53:12.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><ol><li>Jenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。<br><code>Jenkins</code> 本身是用 <code>java</code> 语言开发的，所以安装 <code>Jenkins</code> 之前，要保证你的电脑有<code>jdk</code>，如果没有，请到参考<a href="">《MAC安装JDK及环境变量配置》</a> ，另外建议git、ant、maven、gradle、groovy等工具也一并安装好，方便与这些构建工具集成。</li></ol><p>根据官方定义，Jenkins有以下的用途：</p><ul><li>构建项目      </li><li>跑测试用例检测bug      </li><li>静态代码检测       </li><li>部署      </li></ul><a id="more"></a> <h2 id="二、Jenkins的安装"><a href="#二、Jenkins的安装" class="headerlink" title="二、Jenkins的安装"></a>二、Jenkins的安装</h2><h3 id="1-1-jenkins-pkg"><a href="#1-1-jenkins-pkg" class="headerlink" title="1.1 jenkins.pkg"></a>1.1 jenkins.pkg</h3><p>进入<a href="https://jenkins.io/index.html" target="_blank" rel="noopener">Jenkins的官网</a> ,然后下载并安装Jenkins</p><blockquote><p>也可以直接点击下载<a href="http://mirrors.jenkins-ci.org/osx/latest" target="_blank" rel="noopener">最新版本</a></p></blockquote><p> <strong><em>1.</em></strong> 点击链接进入官网</p><p> <img src="http://upload-images.jianshu.io/upload_images/3008243-84988033422d9c16.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p> <strong><em>2.</em></strong> 点击download</p><p> <img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fvezxiaiajj31ga11egsn.jpg" alt=""> </p><p> <strong><em>3.</em></strong> 我选择的是Mac OS X下载并安装</p><p> <strong><em>4.</em></strong> 点击直接安装即可，在下图中，选择自定义，取消 <code>start at boot as“jenkins”</code>，一般不需要自启动<br> <img src="http://upload-images.jianshu.io/upload_images/3008243-26bfb9a02d0f5d07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="1-2-命令行安装"><a href="#1-2-命令行安装" class="headerlink" title="1.2 命令行安装"></a>1.2 命令行安装</h3><p>命令行使用 <code>homebrew</code> 安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ brew search jenkins</span><br><span class="line">jenkins</span><br><span class="line">$ brew install jenkins</span><br></pre></td></tr></table></figure><p>启动jenkins    </p><p><code>$ jenkins</code></p><h3 id="2-进入页面"><a href="#2-进入页面" class="headerlink" title="2. 进入页面"></a>2. 进入页面</h3><p>安装完成后，会直接跳转到如下界面，如果没有跳转或者跳转失败，可通过执行如下命令 <code>open /Applications/Jenkins/jenkins.war</code> 进入到该界面<br><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fvfywcg9ewj30ri09tabf.jpg" alt=""></p><blockquote><p>如果打开没有反应，启动不了，就在浏览器直接打开：<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> ，就可以进入到上面界面了。</p></blockquote><blockquote><blockquote><p>发现还是打不开， cd进入到jenkins.war包所在目录,执行以下命令:</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar jenkins.war --httpPort=8080</span><br></pre></td></tr></table></figure><blockquote><p>httpPort指的就是Jenkins所使用的http端口,这里指定8080(默认的就是这个),可根据具体情况来修改。待Jenkins启动后,在浏览器页面输入以下地址:<br><a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></p></blockquote><blockquote><p>这个时候可能会报一个错误。如果出现了上面的问题，原因可能是Java环境有问题，重新安装JDK环境即可。</p></blockquote><p> <strong><em>6.</em></strong> 观察图中的路径，将地址中的文件打开，或者打开你的终端，执行<code>cat</code>命令（注意：该命令仅在安装Jenkins的过程中执行才有效；安装成功后，再在终端中执行是无效的）：    </p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fvfyxf1rl8j30vg054wga.jpg" alt="">     </p><p> <strong><em>7.</em></strong> 然后将我们得到的 <code>password</code> 输入到 <code>Administrator password</code> 中，即可进入如下界面, 选第一个,接着安装一些建议的插件，安装过程中，有的插件可能会安装失败，可以跳过，之后需要对应的插件时，再重新安装即可，具体后面会讲到：</p><p> <img src="http://upload-images.jianshu.io/upload_images/3008243-cf1635160604dc56?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p> <strong><em>8.</em></strong> 插件安装完成后，可能会卡在如下界面，不会自动跳转，刷新下界面即可：</p><p> <img src="http://upload-images.jianshu.io/upload_images/3008243-03f427bb5a3553da?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p> <strong><em>9.</em></strong> 在刷新后的界面中注册，输入用户名和密码，如下：</p><p> <img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fvezybgexnj31iw1byado.jpg" alt=""></p><p> <strong><em>10.</em></strong> 注册成功后，点击”Start using Jenkins”</p><p> <img src="http://upload-images.jianshu.io/upload_images/3008243-bb59d4a3085e0e4c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="三、Jenkins的使用"><a href="#三、Jenkins的使用" class="headerlink" title="三、Jenkins的使用"></a>三、Jenkins的使用</h2><h3 id="安装常用插件"><a href="#安装常用插件" class="headerlink" title="安装常用插件"></a>安装常用插件</h3><ul><li>Xcode</li><li>Keychains and provisioning profiles management</li><li>Git Plugin</li><li>Xcode integration<br>…. </li></ul><p>如下图，进行管理:<br><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fvezz4ovfnj31kw0nxn2d.jpg" alt=""></p><p><img src="http://upload-images.jianshu.io/upload_images/80578-e68106251e4a5eaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h3><h4 id="1-新建一个自由风格的软件项目"><a href="#1-新建一个自由风格的软件项目" class="headerlink" title="1.新建一个自由风格的软件项目"></a>1.新建一个自由风格的软件项目</h4><h4 id="2-配置git地址"><a href="#2-配置git地址" class="headerlink" title="2.配置git地址"></a>2.配置git地址</h4><p><img src="http://upload-images.jianshu.io/upload_images/80578-98eb62f65d91d0b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="立即构建下，提示构建成功"><a href="#立即构建下，提示构建成功" class="headerlink" title="立即构建下，提示构建成功"></a>立即构建下，提示构建成功</h4><p><img src="http://upload-images.jianshu.io/upload_images/80578-747f024d24255bab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>那么构建后的项目在哪里呢？<br>通过系统管理-&gt;系统设置-&gt;主目录 点击高级，可以查看到<br><img src="http://upload-images.jianshu.io/upload_images/80578-a7d73b8be1152ced.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在jenkins的workspace目录中，可以看到构建的项目</p><p><img src="http://upload-images.jianshu.io/upload_images/80578-7398252ed1c1104c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="编译配置（很关键）"><a href="#编译配置（很关键）" class="headerlink" title="编译配置（很关键）"></a>编译配置（很关键）</h4><p>上面虽然编译成功了，但是你发现根本没有看到ipa文件，所以还需要进行下面的配置：增加构建步骤</p><p>这就用到我们上面安装的Xcode插件了</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvh8d0pc1aj30hm0hsmyp.jpg" alt=""></p><p>Xcode插件配置</p><p><img src="http://upload-images.jianshu.io/upload_images/80578-0da04c60564cecca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/80578-60758d04253a56b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>配置完成，点击立即构建，查看ipa所在的路径</p><p><img src="http://upload-images.jianshu.io/upload_images/80578-084d215fb776d43c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>OK，一个简单的打包就完成了。</p><h2 id="结合FastLane"><a href="#结合FastLane" class="headerlink" title="结合FastLane"></a>结合FastLane</h2><p>配置好Git，在 <code>增加构建步骤</code> 的时候，选择脚本</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvh897f6v0j30ii0kw760.jpg" alt=""></p><p>添加 shell 命令：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvh8al45v2j31f80giabm.jpg" alt=""></p><blockquote><p>我这里做了三步，1.cd 到项目路径  2，执行fastlane 打包  3，发送qq邮件</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>Jenkins的安装方式不同（<a href="http://www.cnblogs.com/ihojin/p/mac-install-jenkins.html" target="_blank" rel="noopener">Mac 安装 Jenkins</a>），卸载方法也不同</p><h4 id="一-通过安装包安装的卸载方式"><a href="#一-通过安装包安装的卸载方式" class="headerlink" title="一.通过安装包安装的卸载方式"></a>一.通过安装包安装的卸载方式</h4><ul><li><p>方法1：打开终端，执行命令 /Library/Application Support/Jenkins/Uninstall.command</p></li><li><p>方法2：Finder 前往文件夹：<code>/Library/Application Support/Jenkins</code>，双击 <code>Uninstall.command</code></p></li></ul><h4 id="二-通过-Homebrew-安装的卸载方式"><a href="#二-通过-Homebrew-安装的卸载方式" class="headerlink" title="二.通过 Homebrew 安装的卸载方式"></a>二.通过 Homebrew 安装的卸载方式</h4><ul><li>打开终端 <code>brew uninstall jenkins</code></li></ul><p>完成之后再次打开<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a>  访问不了，说明卸载成功</p><h2 id=""><a href="#" class="headerlink" title="#"></a>#</h2><p>Jenkins做的操作其实很简单，它只是将我们平时做的每一步重复的操作自动化了而已。因此，iOS中Jenkins要做的分为以下几步：</p><ol><li>拉取远端代码      </li><li>由于某种条件触发后开始自动编译，打包     </li><li>将生成的ipa文件上传到指定位置，供测试下载测试      </li></ol><p>这三步中，每一步Jenkins什么都没做，它只是调用了Mac中的一些工具，具体的说就是使用了命令行工具。有的做成了可视化的插件，有的还是要通过自己写命令来实现。典型的就是编译和打包的命令是调用xcodebuild命令。<br>也就是说我们可以也可以结合 <code>Fastlane</code> 来打包，简化 <code>Jenkins</code>的操作和需要安装的插件。</p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="https://www.jianshu.com/p/41ecb06ae95f" target="_blank" rel="noopener">Jenkins持续集成iOS项目</a></p><p><a href="https://www.imooc.com/article/26327?block_id=tuijian_wz#" target="_blank" rel="noopener">Jenkins踩坑记录</a></p><p><a href="https://www.cnblogs.com/Rocky_/p/8297260.html" target="_blank" rel="noopener">Jenkins 构建触发器</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、简述&quot;&gt;&lt;a href=&quot;#一、简述&quot; class=&quot;headerlink&quot; title=&quot;一、简述&quot;&gt;&lt;/a&gt;一、简述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Jenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。&lt;br&gt;&lt;code&gt;Jenkins&lt;/code&gt; 本身是用 &lt;code&gt;java&lt;/code&gt; 语言开发的，所以安装 &lt;code&gt;Jenkins&lt;/code&gt; 之前，要保证你的电脑有&lt;code&gt;jdk&lt;/code&gt;，如果没有，请到参考&lt;a href=&quot;&quot;&gt;《MAC安装JDK及环境变量配置》&lt;/a&gt; ，另外建议git、ant、maven、gradle、groovy等工具也一并安装好，方便与这些构建工具集成。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据官方定义，Jenkins有以下的用途：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建项目      &lt;/li&gt;
&lt;li&gt;跑测试用例检测bug      &lt;/li&gt;
&lt;li&gt;静态代码检测       &lt;/li&gt;
&lt;li&gt;部署      &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Fastlane （二）</title>
    <link href="http://yoursite.com/2018/09/18/Fastlane-%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2018/09/18/Fastlane-（二）/</id>
    <published>2018-09-18T08:59:29.000Z</published>
    <updated>2018-09-21T07:40:27.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="打包到-AppStore"><a href="#打包到-AppStore" class="headerlink" title="打包到 AppStore"></a>打包到 AppStore</h1><p><a href="">上篇文章</a> 我们已经成功的打包app到蒲公英了。那么我们也可以尝试将app上传到AppStore.<br>废话不多说，先简单的打包一个 ipa 到 AppStore 。  </p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">desc &quot;release&quot;</span><br><span class="line">lane :release do</span><br><span class="line">sigh # 更新证书</span><br><span class="line">gym(</span><br><span class="line">      scheme:&quot;your need up schemeName&quot;, # scheme,</span><br><span class="line">    configuration: &quot;Release&quot;, # 配置 Release or Debug</span><br><span class="line">      export_method: &quot;app-store&quot;)       # 打包类型，前文已经讲过</span><br><span class="line"></span><br><span class="line"> deliver(submit_for_review: false, #是否自动提交审核</span><br><span class="line">         skip_screenshots: true,  # 是否跳过截图</span><br><span class="line">       skip_metadata: true,  # 是否跳过元数据（标题，描述）</span><br><span class="line">         force: true)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>关于<code>scheme</code>的设置请查看<a href="https://developer.apple.com/library/archive/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/ConfigureBots.html#//apple_ref/doc/uid/TP40013292-CH9-SW3" target="_blank" rel="noopener">文档</a></p><p>调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane release</span><br></pre></td></tr></table></figure><p>在项目无误的情况下,提交成功！<br><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fvezjej76pj30ve0ge766.jpg" alt="success"></p><h1 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h1><p>在<a href="">上篇文章</a>的基础上，因为我们选择的是自定义，所以并没有创建 <code>Deliverfile</code>，<code>screenshots</code>和<code>metadata</code>目录，也就没有app的更多的设置,比如提交的各种信息，截图等。我们可以使用如下命令进行创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deliver init</span><br></pre></td></tr></table></figure><p>此时会要求输入你的 <code>Your Apple ID Username</code> 和 <code>password</code>,<code>The Bundle Identifier of your App</code>.(因为我已经登录过了。所以并未出现要输入账号的密码，也可以在 <code>Appfile</code> 编辑你的账号和 Bundle Identifier)。</p><p><img src="https://upload-images.jianshu.io/upload_images/1533163-d4cae722f895945e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/787" alt=""></p><blockquote><p>如果开发者账号上没有对应的bundle id的App，会提示是否创建一个新的App,这里我们选择否(n)，因为这样快速创建的App设置的信息有限，只能设置App名称等一些基本信息，我们可以通过produce工具创建一个可以设置更多信息的App</p></blockquote><h1 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h1><p>我们可以通过编辑 <code>Deliverfile</code>来设置app的相关属性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"># Apple ID用户名，账号名称</span><br><span class="line">username &quot;xxxx@xxxxx.com&quot; </span><br><span class="line"></span><br><span class="line"># bundle identifier</span><br><span class="line">app_identifier &quot;xxx.com.cn&quot; # The bundle identifier of your app</span><br><span class="line"></span><br><span class="line"># 版权声明</span><br><span class="line">copyright &quot;深圳xxxx有限公司&quot;</span><br><span class="line"></span><br><span class="line"># 支持的语言</span><br><span class="line">supportedLanguages = &#123;</span><br><span class="line">    &quot;cmn-Hans&quot; =&gt; &quot;zh-Hans&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 副标题</span><br><span class="line">subtitle(</span><br><span class="line">  &apos;zh-Hans&apos; =&gt; &quot;副标题&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># App应用名称</span><br><span class="line">name(</span><br><span class="line">  &apos;zh-Hans&apos; =&gt; &quot;应用名称&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 关键字</span><br><span class="line">keywords(</span><br><span class="line">  &apos;zh-Hans&apos; =&gt; &quot;各种关键字,用逗号隔开&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 支持网址</span><br><span class="line">support_url(&#123;</span><br><span class="line">  &apos;zh-Hans&apos; =&gt; &quot;http://baidu.com&quot;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># App价格</span><br><span class="line">price_tier 0</span><br><span class="line"></span><br><span class="line"># 应用程序图标的路径</span><br><span class="line"># app_icon &apos;./fastlane/metadata/AppIcon.png&apos;</span><br><span class="line"></span><br><span class="line"># 屏幕截图的文件夹的路径</span><br><span class="line">screenshots_path &apos;./fastlane/screenshots&apos;</span><br><span class="line"></span><br><span class="line"># 指定上传ipa路径,</span><br><span class="line">ipa &apos;./Ipa/xxxx.ipa&apos;</span><br><span class="line"></span><br><span class="line"># 自动发布 app: false,则需要手动发布</span><br><span class="line">automatic_release false</span><br><span class="line"></span><br><span class="line"># 提交审核信息:加密, idfa 等，对应的是提交审核的时候，需选择的选项</span><br><span class="line">submission_information(&#123;    </span><br><span class="line">    export_compliance_encryption_updated: false,</span><br><span class="line">    export_compliance_uses_encryption: false,</span><br><span class="line">    content_rights_contains_third_party_content: false,</span><br><span class="line">    add_id_info_uses_idfa: false</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"># 应用审核小组的联系信息 app 审核信息</span><br><span class="line">app_review_information(</span><br><span class="line">  first_name: &quot;姓&quot;,</span><br><span class="line">  last_name: &quot;名字&quot;,</span><br><span class="line">  phone_number: &quot;+86 18237485911&quot;,</span><br><span class="line">  email_address: &quot;xxxx@ apple.com.cn&quot;,</span><br><span class="line">  demo_user: &quot;测试登录账号&quot;,</span><br><span class="line">  demo_password: &quot;测试登录密码&quot;,</span><br><span class="line">  notes: &quot;这里可以写一些备注，完全和网页一致的写法就行了&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>更多 <a href="https://www.jianshu.com/p/867b397c7939" target="_blank" rel="noopener">编辑内容</a></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>等待初始化完成之后，工程目录下就多了一个 fastlane目录，其内容如下：<br><img src="http://cc.cocimg.com/api/uploads/20170519/1495177333947263.png" alt=""></p><blockquote><p><code>metadata</code> 是包含应用在ITC上面的各种信息，可以使用它配置我们的ITC，配置项，宣传文本、app名称、关键字、隐私网址、app的logo, 但建议使用 <code>Deliverfile</code>，因为<code>Deliverfile</code>会覆盖 <code>metadata</code> 的设置<br>screenshots 屏幕截图数据。</p></blockquote><p>咱们来看主要的，Appfile 和 Fastfile, Deliverfile。</p><h2 id="Appfile"><a href="#Appfile" class="headerlink" title="Appfile"></a>Appfile</h2><p>Appfile用来存放 <code>app_identifier</code>，<code>apple_id</code>和 <code>team_id</code>。 了解详情，它的格式是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app_identifier &quot;com.xxx.xxx&quot; # app的bundle identifier</span><br><span class="line">apple_id &quot;xxx@xxx.com&quot; # 你的Apple ID</span><br><span class="line"> </span><br><span class="line">team_id &quot;XXXXXXXXXX&quot; # Team ID</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>你也可以为每个lane(后面会讲到)提供不同的 <code>app_identifier</code>, <code>apple_id</code> 和 <code>team_id</code>，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app_identifier &quot;com.aaa.aaa&quot;</span><br><span class="line">apple_id &quot;aaa@aaa.com&quot;</span><br><span class="line">team_id &quot;AAAAAAAAAA&quot;</span><br><span class="line"> </span><br><span class="line">for_lane :inhouse do</span><br><span class="line">  app_identifier &quot;com.bbb.bbb&quot;</span><br><span class="line">  apple_id &quot;bbb@bbb.com&quot;</span><br><span class="line">  team_id &quot;AAAAAAAAAA&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>配置好<code>Appfile</code>，fastlane就不会每一次都询问你的账号和id了</p><h2 id="Fastfile"><a href="#Fastfile" class="headerlink" title="Fastfile"></a>Fastfile</h2><p>Fastfile 管理你所创建的 lane ，<code>了解详情</code>。它的格式是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line"># 自动更新fastlane 工具</span><br><span class="line"># update_fastlane</span><br><span class="line"> </span><br><span class="line">#需要的fastlane的最小版本，在每次执行之后会检查是否有新版本，如果有会在最后末尾追加新版本提醒</span><br><span class="line">fastlane_version &quot;2.30.1&quot;</span><br><span class="line"> </span><br><span class="line">#默认使用平台是 ios，也就是说文件可以定义多个平台</span><br><span class="line">default_platform :ios</span><br><span class="line"> </span><br><span class="line">platform :ios do</span><br><span class="line">  before_all do</span><br><span class="line">    # ENV[&quot;SLACK_URL&quot;] = &quot;https://hooks.slack.com/services/...&quot;</span><br><span class="line">    cocoapods</span><br><span class="line"> </span><br><span class="line">  end</span><br><span class="line"> </span><br><span class="line">  desc &quot;Runs all the tests&quot;</span><br><span class="line">  lane :test do</span><br><span class="line">    scan</span><br><span class="line">  end</span><br><span class="line"> </span><br><span class="line">  desc &quot;提交一个新的Beta版本到 Apple TestFlight&quot;</span><br><span class="line">  desc &quot;This will also make sure the profile is up to date&quot;</span><br><span class="line">  lane :beta do</span><br><span class="line">    # match(type: &quot;appstore&quot;) # more information: https://codesigning.guide</span><br><span class="line">    gym(scheme: &quot;Docment&quot;) # Build your app - more options available</span><br><span class="line">    pilot</span><br><span class="line"> </span><br><span class="line">    # sh &quot;your_script.sh&quot;</span><br><span class="line">  end</span><br><span class="line"> </span><br><span class="line">  desc &quot;部署一个新版本到App Store&quot;</span><br><span class="line">  lane :release do</span><br><span class="line">    # match(type: &quot;appstore&quot;)</span><br><span class="line">    # snapshot</span><br><span class="line">    gym(scheme: &quot;Docment&quot;) # Build your app - more options available</span><br><span class="line">    deliver(force: true)</span><br><span class="line">    # frameit</span><br><span class="line">  end</span><br><span class="line"> </span><br><span class="line">  # 你可以定义自己的lane</span><br><span class="line"> </span><br><span class="line">  #执行lane成功后的回调</span><br><span class="line">  after_all do |lane|</span><br><span class="line">    # slack(</span><br><span class="line">    #   message: &quot;Successfully deployed new App Update.&quot;</span><br><span class="line">    # )</span><br><span class="line">  end</span><br><span class="line"> </span><br><span class="line">  # 如果流程发生异常会走这里并终止</span><br><span class="line">  error do |lane, exception|</span><br><span class="line">    # slack(</span><br><span class="line">    #   message: exception.message,</span><br><span class="line">    #   success: false</span><br><span class="line">    # )</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>系统级lane      </p><table><thead><tr><th>执行顺序</th><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>before_all</td><td>在执行 lane 之前只执行一次。</td></tr><tr><td>2</td><td>before_each</td><td>每次执行 lane 之前都会执行一次。</td></tr><tr><td>3</td><td>lane</td><td>自定义的任务。</td></tr><tr><td>4</td><td>after_each</td><td>每次执行 lane 之后都会执行一次。</td></tr><tr><td>5</td><td>after_all</td><td>在执行 lane 成功结束之后执行一次。</td></tr><tr><td>6</td><td>error</td><td>在执行上述情况任意环境报错都会中止并执行一次。</td></tr></tbody></table><p>我们也可以定义一个自己的lane：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">desc &quot;企业版&quot;</span><br><span class="line">  lane :inHouse do</span><br><span class="line">  gym(scheme: &quot;XXX&quot;,</span><br><span class="line">      export_method:&quot;enterprise&quot;,</span><br><span class="line">      output_directory &quot;./build&quot;, # 打包后的 ipa 文件存放的目录</span><br><span class="line">      output_name &quot;XXX&quot;  # ipa 文件名</span><br><span class="line">   )</span><br><span class="line">  end</span><br></pre></td></tr></table></figure><p>其中一个lane就是一个任务，里面是一个个的action组成的工作流。<br>利用目前支持的工具可以做所有包含自动化和可持续化构建的每个环节，详情请查看<a href="">上篇文章的工具类</a></p><h2 id="Deliverfile"><a href="#Deliverfile" class="headerlink" title="Deliverfile"></a>Deliverfile</h2><p>交付文件。在这个文件里面可以设置iTunes connect的所有配置项，例如：</p><p>release_notes，此版本新增内容。</p><p>copyright，版权信息。</p><p>submit_for_review，上传完成后是否直接提交新版本进行审查。</p><p>force，跳过HTML报告文件验证。</p><p>…</p><p>请在设置 <code>release_nores</code> 、<code>support_url</code> 、<code>private_url</code> 等配置的时候，采用 hash 的方式写，<a href="https://www.cnblogs.com/Mien/archive/2008/08/22/1273950.html" target="_blank" rel="noopener">国家代码</a>，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">release_notes(</span><br><span class="line"># 中国</span><br><span class="line">&apos;zh-Hans&apos; =&gt; ENV[&apos;RELEASE_NOTES&apos;],</span><br><span class="line"># 澳大利亚</span><br><span class="line">&apos;en-au&apos; =&gt; ENV[&apos;RELEASE_NOTES_AU&apos;],</span><br><span class="line"># 美国</span><br><span class="line">&apos;en-us&apos; =&gt; ENV[&apos;RELEASE_NOTES_US&apos;]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>具体的配置可以在文章最后查看.</p><h1 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h1><h3 id="使用produce，在iTunes-Connect或者Apple-Developer-Center上创建新的iOS应用程序"><a href="#使用produce，在iTunes-Connect或者Apple-Developer-Center上创建新的iOS应用程序" class="headerlink" title="使用produce，在iTunes Connect或者Apple Developer Center上创建新的iOS应用程序"></a>使用produce，在iTunes Connect或者Apple Developer Center上创建新的iOS应用程序</h3><p>进入项目根目录，找到fastlane文件夹下的Fastfile文件， 编辑文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">platform :ios do</span><br><span class="line"> desc &quot;create new app&quot;</span><br><span class="line"> lane :produce_app do</span><br><span class="line">   produce(</span><br><span class="line">     username: &quot;xxxx@gmail.com&quot;,# APPle ID</span><br><span class="line">     app_name: &quot;小鱼小鱼吃虾米&quot;,#App 名称</span><br><span class="line">     app_identifier: &quot;com.test.www.FastlaneTest&quot;,#App bundle id</span><br><span class="line">     app_version: &quot;1.0&quot;,#App 版本</span><br><span class="line">     sku: &quot;10023500&quot;,#App sku</span><br><span class="line">     language: &quot;Simplified Chinese&quot;,#App 语言，默认English</span><br><span class="line">   )</span><br><span class="line"> end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1533163-dabebfdee644cc43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/855" alt=""></p><p><strong>备注：language这个选项不能直接写Chinese，语言选项如下</strong><br><em>[“Brazilian Portuguese”, “Danish”, “Dutch”, “English”, “English_Australian”, “English_CA”, “English_UK”, “Finnish”, “French”, “French_CA”, “German”, “Greek”, “Indonesian”, “Italian”, “Japanese”, “Korean”, “Malay”, “Norwegian”, “Portuguese”, “Russian”, “Simplified Chinese”, “Spanish”, “Spanish_MX”, “Swedish”, “Thai”, “Traditional Chinese”, “Turkish”, “Vietnamese”]</em></p><p>在terminal中执行fastlane produce_app命令，创建成功提示如下：<br><img src="https://upload-images.jianshu.io/upload_images/1533163-ea43827f2e8ffd7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/855" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/1533163-361175ae5018d974.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/949" alt=""></p><h3 id="使用cert创建签名证书-Certificates"><a href="#使用cert创建签名证书-Certificates" class="headerlink" title="使用cert创建签名证书(Certificates)"></a>使用cert创建签名证书(Certificates)</h3><p>在Fastfile中添加以下内容</p><h4 id="生成开发证书"><a href="#生成开发证书" class="headerlink" title="生成开发证书:"></a>生成开发证书:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lane :create_certificates do</span><br><span class="line">    cert(</span><br><span class="line">      username: &quot;xxxx@gmail.com&quot;,# APPle ID</span><br><span class="line">      development: true,# 创建一个开发证书</span><br><span class="line">      force: &quot;false&quot;,#即使存在现有证书，也要创建证书，默认为false</span><br><span class="line">      output_path: &quot;./certs/development&quot;,#存储所有证书和私钥的目录的路径</span><br><span class="line">    )</span><br><span class="line">  end</span><br></pre></td></tr></table></figure><p>结果如下：<br><img src="https://upload-images.jianshu.io/upload_images/1533163-bc94a147af5bdb6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/857" alt=""></p><h4 id="生成生产证书"><a href="#生成生产证书" class="headerlink" title="生成生产证书:"></a>生成生产证书:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lane :create_dcertificates do</span><br><span class="line">    cert(</span><br><span class="line">      username: &quot;xxxx@gmail.com&quot;,# APPle ID</span><br><span class="line">      development: false,# 创建一个开发证书</span><br><span class="line">      force: &quot;false&quot;,#即使存在现有证书，也要创建证书，默认为false</span><br><span class="line">      output_path: &quot;./certs/distribution&quot;,#存储所有证书和私钥的目录的路径</span><br><span class="line">    )</span><br><span class="line">  end</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1533163-cc38aa742b08fc2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/845" alt=""></p><p><strong>开发和生产证书，修改development的boolean值及output_path路径即可</strong></p><h3 id="使用sigh-生成描述文件-mobileprovision"><a href="#使用sigh-生成描述文件-mobileprovision" class="headerlink" title="使用sigh 生成描述文件(mobileprovision)"></a>使用sigh 生成描述文件(mobileprovision)</h3><p>在Fastfile中</p><h4 id="生成开发mobileprovision"><a href="#生成开发mobileprovision" class="headerlink" title="生成开发mobileprovision"></a>生成开发mobileprovision</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lane :get_dev_provisioningProfile do</span><br><span class="line">  get_provisioning_profile(</span><br><span class="line">    username: &quot;xxxx@gmail.com&quot;,# APPle ID</span><br><span class="line">    development: true,# 创建一个开发mobileprovision</span><br><span class="line">    app_identifier: &quot;com.test.www.FastlaneTest&quot;,#bundle identifier</span><br><span class="line">    output_path: &quot;./certs/development&quot;,#存储mobileprovision的目录的路径</span><br><span class="line">    filename: &quot;fastlane_dev.mobileprovision&quot;,#用于生成的供应配置文件的文件名（必须包含.mobileprovision）</span><br><span class="line">  )</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1533163-db43c3e1861439bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/853" alt=""></p><h4 id="生成生产mobileprovision"><a href="#生成生产mobileprovision" class="headerlink" title="生成生产mobileprovision"></a>生成生产mobileprovision</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lane :get_provisioningProfile do</span><br><span class="line">   get_provisioning_profile(</span><br><span class="line">     username: &quot;xxxx@gmail.com&quot;,# APPle ID</span><br><span class="line">     development: false,# 创建一个开发证书</span><br><span class="line">     app_identifier: &quot;com.test.www.FastlaneTest&quot;,#bundle identifier</span><br><span class="line">     output_path: &quot;./certs/distribution&quot;,#存储mobileprovision的目录的路径</span><br><span class="line">     filename: &quot;fastlane_distr.mobileprovision&quot;,#用于生成的供应配置文件的文件名（必须包含.mobileprovision）</span><br><span class="line">   )</span><br><span class="line"> end</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1533163-a5eaaeed82991868.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/853" alt=""><br>找到 <code>certs/development&amp;&amp;distribution</code>目录下的证书及<code>.mobileprovision</code>文件，并安装到电脑上<br><img src="https://upload-images.jianshu.io/upload_images/1533163-de34c42dd8886483.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/595" alt=""></p><h3 id="使用gym来打包ipa"><a href="#使用gym来打包ipa" class="headerlink" title="使用gym来打包ipa"></a>使用gym来打包ipa</h3><p>示例   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lane :inhouse do</span><br><span class="line">  # 以下两个action来自fastlane-plugin-versioning，</span><br><span class="line">  # 第一个递增 Build，第二个设定Version。</span><br><span class="line">  # 如果你有多个target，就必须指定target的值，否则它会直接找找到的第一个plist修改</span><br><span class="line">    increment_build_number_in_plist(target: &apos;FastlaneTest&apos;)</span><br><span class="line">    increment_version_number_in_plist(</span><br><span class="line">      target: &apos;FastlaneTest&apos;,</span><br><span class="line">      version_number: &apos;1.0&apos;</span><br><span class="line">    )</span><br><span class="line">    # gym用来编译ipa</span><br><span class="line">    gym(scheme: &apos;FastlaneTest&apos;,#打包scheme</span><br><span class="line">    export_method:&quot;enterprise&quot;,#打包类型app-store, ad-hoc, enterprise, development</span><br><span class="line">    output_directory: &quot;./build&quot;,#ipa打包存放路径</span><br><span class="line">    output_name: &apos;inhouse.ipa&apos;#ipa名称</span><br><span class="line">    )</span><br><span class="line">  end</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>这里是官方提供的一些 <a href="https://github.com/fastlane/examples" target="_blank" rel="noopener">例子</a>。      </li><li>想了解 fastlane 命令的话可以执行 <code>fastlane --help</code>      </li><li>查看可用任务的列表，可以执行命令 <code>fastlane lanes</code></li><li><p>可以安装一些插件来辅助，查看插件 <code>fastlane search_plugins</code>, 比如修改版本号的 <a href="https://github.com/SiarheiFedartsou/fastlane-plugin-versioning" target="_blank" rel="noopener">versioning</a>,以及 同样功能的 <code>fastlane-plugin-versioning</code><br>安装上面的插件,使用 <code>fastlane add_plugin [name] # 安装方法</code><br>比如      </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane add_plugin versioning</span><br></pre></td></tr></table></figure></li><li><p>多个 lane 的话实际上是可以相互调用的，这个其实特别实用。例如：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">default_platform :ios</span><br><span class="line"> </span><br><span class="line">platform :ios do</span><br><span class="line"> </span><br><span class="line">  lane :prepare do</span><br><span class="line">    cocoapods</span><br><span class="line">    match</span><br><span class="line">  end</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  desc &apos;fastlane build&apos;   &apos;fastlane build type:adhoc&apos;</span><br><span class="line">  lane :build do |options|</span><br><span class="line">    # 调用上面的 prepare 任务</span><br><span class="line">    prepare</span><br><span class="line"> </span><br><span class="line">    case options[:type]</span><br><span class="line">    when &apos;adhoc&apos;</span><br><span class="line">      adhoc</span><br><span class="line">    else</span><br><span class="line">      appstore</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  lane : adhoc do</span><br><span class="line">  ···</span><br><span class="line">  end</span><br><span class="line"> </span><br><span class="line">  lane : appstore do</span><br><span class="line">  ···</span><br><span class="line">  end</span><br><span class="line"> </span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>我们可以在 Fastfile 文件中添加一个函数来设置version号和build号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">default_platform :ios</span><br><span class="line"> </span><br><span class="line">def prepare_version(options)</span><br><span class="line">    increment_version_number(</span><br><span class="line">        version_number: options[:version]</span><br><span class="line">    )</span><br><span class="line"> </span><br><span class="line">    increment_build_number(</span><br><span class="line">        build_number: options[:build]</span><br><span class="line">    )</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>然后可以在一个lane中使用这个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lane :appstore do |options|</span><br><span class="line">   ···</span><br><span class="line">    prepare_version(options)</span><br><span class="line">   ···</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>然后执行这个lane的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane appstore version:2.4.0 build:2.0</span><br></pre></td></tr></table></figure><h1 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h1><p><a href="https://www.jianshu.com/p/ecaca8ac86e3" target="_blank" rel="noopener">相关文章</a></p><p><a href="https://www.jianshu.com/p/44bbe1a31b52" target="_blank" rel="noopener">fastlane 实现自定义Action</a></p><p><a href="https://www.jianshu.com/p/46118a562b5b" target="_blank" rel="noopener">使用fastlane自动增加版本号</a></p><h4 id="Deliverfile-编辑示例"><a href="#Deliverfile-编辑示例" class="headerlink" title="Deliverfile 编辑示例"></a><a href="https://docs.fastlane.tools/actions/deliver/" target="_blank" rel="noopener">Deliverfile 编辑示例</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"># app_identifier</span><br><span class="line">app_identifier ENV[&apos;APP_IDENTIFIER&apos;]</span><br><span class="line"># 用户名,Apple ID电子邮件地址</span><br><span class="line">username ENV[&apos;APPLE_ID&apos;]</span><br><span class="line"># 团队ID</span><br><span class="line">team_id ENV[&apos;TEAM_ID&apos;]</span><br><span class="line"># 团队name</span><br><span class="line">team_name ENV[&apos;TEAM_NAME&apos;]</span><br><span class="line"># copyright</span><br><span class="line">copyright ENV[&apos;COPYRIGHT&apos;]</span><br><span class="line"># 关键字</span><br><span class="line">keywords(</span><br><span class="line">    &apos;zh-Hans&apos; =&gt; ENV[&apos;KEYWORDS&apos;],</span><br><span class="line">)</span><br><span class="line"># 新版本修改记录</span><br><span class="line">release_notes(</span><br><span class="line">    # 中国</span><br><span class="line">    &apos;zh-Hans&apos; =&gt; ENV[&apos;RELEASE_NOTES&apos;],</span><br><span class="line">    # 澳大利亚</span><br><span class="line">    &apos;en-au&apos; =&gt; ENV[&apos;RELEASE_NOTES_AU&apos;],</span><br><span class="line">    # 美国</span><br><span class="line">    &apos;en-us&apos; =&gt; ENV[&apos;RELEASE_NOTES_US&apos;]</span><br><span class="line">)</span><br><span class="line"># 支持网址</span><br><span class="line">support_url(</span><br><span class="line">    # 中国</span><br><span class="line">    &apos;zh-Hans&apos; =&gt; ENV[&apos;SUPPORT_URL&apos;],</span><br><span class="line">    # 澳大利亚</span><br><span class="line">    &apos;en-au&apos; =&gt; ENV[&apos;SUPPORT_URL_AU&apos;],</span><br><span class="line">    # 美国</span><br><span class="line">    &apos;en-us&apos; =&gt; ENV[&apos;SUPPORT_URL_US&apos;]</span><br><span class="line">)</span><br><span class="line"># 隐私政策网址 国家代码 https://www.cnblogs.com/Mien/archive/2008/08/22/1273950.html</span><br><span class="line">privacy_url(</span><br><span class="line">    # 中国</span><br><span class="line">    &apos;zh-Hans&apos; =&gt; ENV[&apos;PRIVACY_URL&apos;],</span><br><span class="line">    # 澳大利亚</span><br><span class="line">    &apos;en-au&apos; =&gt; ENV[&apos;PRIVACY_URL_AU&apos;],</span><br><span class="line">    # 美国</span><br><span class="line">    &apos;en-us&apos; =&gt; ENV[&apos;PRIVACY_URL_US&apos;]</span><br><span class="line">)</span><br><span class="line"># 上传完成后提交新版本进行审查</span><br><span class="line">submit_for_review false</span><br><span class="line"># 跳过HTML报告文件验证</span><br><span class="line">force true</span><br><span class="line"># 启用iTC的分阶段发布功能 灰度发布</span><br><span class="line">phased_release true</span><br><span class="line"># 应用审核小组的联系信息 app 审核信息</span><br><span class="line">app_review_information(</span><br><span class="line">  first_name: &quot;xx&quot;,</span><br><span class="line">  last_name: &quot;xx&quot;,</span><br><span class="line">  phone_number: &quot;+86 18888888888&quot;,</span><br><span class="line">  email_address: &quot;xxxx&quot;,</span><br><span class="line">  demo_user: &quot;test1@test.com&quot;,</span><br><span class="line">  demo_password: &quot;test123&quot;</span><br><span class="line">)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>最后，附上一个Fastfile脚本和一些自定义Actions：<br><a href="https://github.com/thierryxing/Fastfiles" target="_blank" rel="noopener">https://github.com/thierryxing/Fastfiles</a></p><p>另外，Fastlane也提供了一些国外团队的Example：<br><a href="https://github.com/fastlane/examples" target="_blank" rel="noopener">https://github.com/fastlane/examples</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;打包到-AppStore&quot;&gt;&lt;a href=&quot;#打包到-AppStore&quot; class=&quot;headerlink&quot; title=&quot;打包到 AppStore&quot;&gt;&lt;/a&gt;打包到 AppStore&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;&quot;&gt;上篇文章&lt;/a&gt; 我们已经成功的打包app到蒲公英了。那么我们也可以尝试将app上传到AppStore.&lt;br&gt;废话不多说，先简单的打包一个 ipa 到 AppStore 。  &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Fastlane 安装 和 发布到蒲公英</title>
    <link href="http://yoursite.com/2018/09/18/Fastlane-%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2018/09/18/Fastlane-安装/</id>
    <published>2018-09-18T06:53:54.000Z</published>
    <updated>2018-09-19T09:02:49.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h1><blockquote><p>在使用Fastlane打包之前，你的项目必须是正确的。我的意思是说，你得用原生的方式成功Archive，并可以upload你的测试项目！否则会导致Fastlane打包失败<br><a id="more"></a><br>当你看到这篇文章的时候，说明你已经厌烦不停的打包等一系列<code>没有技术含量的、乏味</code>的工作,然后会去寻找偷懒的方法，于是找到了 <code>Fastlane</code> ，因为 <a href="https://github.com/fastlane/fastlane" target="_blank" rel="noopener">Fastlane</a> 在网上有很多资料，也介绍了蛮多，这里只是简单的点出一些重点。        </p></blockquote><p>Fastlane命令是一个流程控制的命令行工具(CLI)，通过内部集成action和第三方的action完成一系列控制流程。运行Fastlane命令行工具，会读取当前目录或者 <code>./fastlane</code> 目录下的 <code>Fastfile</code> 配置文件。</p><blockquote><p>在Fastfile中：</p></blockquote><blockquote><blockquote><p><code>action</code> :  Fastlane中的每一条命令都是一个扩展(action)，下面提到的deliver，sigh之类的工具本身是CLI，但是在Fastlane中内嵌了对他们支持的action<br><code>lane</code> : Fastlane中流程的合集，每一个动作即可以是action，也可以是其他的lane。语法和ruby中的rake非常像</p></blockquote></blockquote><h1 id="Fastlane组件"><a href="#Fastlane组件" class="headerlink" title="Fastlane组件"></a>Fastlane组件</h1><p><code>不是一个人的王者，而是团队的荣誉</code>, Fastlane 是一套基于 Ruby 的工具集合，它包括了诸多工具:</p><ul><li>测试<ul><li><code>scan</code> =&gt; 自动运行测试工具，并且可以生成漂亮的HTML报告 </li></ul></li><li>证书，配置文件<ul><li><code>cert</code> =&gt; 自动创建管理iOS代码签名证书</li><li><code>sigh</code> =&gt; 是用来创建、更新、下载、修复Provisioning Profile的工具</li><li><code>pem</code> =&gt; 自动生成、更新推送配置文件</li><li><code>match</code> =&gt; 一个新的证书和配置文件管理工具,它会把所有需要用到的证书传到git私有库上，任何需要配置的机器直接用match同步回来就不用管证书问题了，小团队福音啊！</li></ul></li><li>截图<ul><li><code>snapshot</code> =&gt; 用Xcode7推出的UI test功能实现自动化截图</li><li><code>frameit</code> =&gt; 可以把截的图片自动套上一层手机的物理边框</li></ul></li><li>编译<ul><li><code>gym</code> =&gt; Fastlane家族的自动化编译工具，和其他工具配合的非常默契</li></ul></li><li>发布<ul><li>produce =&gt; 如果你的产品还没在iTunes Connect(iTC)或者Apple Developer Center(ADC)建立，produce可以自动帮你完成这些工作</li><li>deliver =&gt; 自动上传截图，APP的元数据，二进制(ipa)文件到iTunes Connect</li></ul></li><li>TestFlight管理<ul><li><code>pilot</code> =&gt; 管理TestFlight的测试用户，上传二进制文件</li><li><code>boarding</code> =&gt; 建立一个添加测试用户界面，发给测试者，可自行添加邮件地址，并同步到iTC</li></ul></li></ul><blockquote><p>更多工具可以去查看<a href="https://docs.fastlane.tools" target="_blank" rel="noopener">官方文档</a></p></blockquote><h1 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h1><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><h4 id="检查-Xcode-CLT-是否安装"><a href="#检查-Xcode-CLT-是否安装" class="headerlink" title="检查 Xcode CLT 是否安装"></a>检查 Xcode CLT 是否安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure><p>如果终端提示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select: error: command line tools are already installed, use &quot;Software Update&quot; to install updates</span><br></pre></td></tr></table></figure></p><p>说明已经安装成功</p><h4 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h4><p>确保已经安装好 <code>ruby</code>、<code>rubygems</code>、<code>bundler</code>，Fastlane要求Ruby版本，当前最新版本要求ruby版本&gt;=2.1。使用以下命令查看ruby版本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -v</span><br></pre></td></tr></table></figure></p><p>相关链接:      </p><p><a href="http://www.cnblogs.com/foxting/p/4520829.html" target="_blank" rel="noopener">《MAC机中安装RUBY环境》</a><br><a href="https://blog.csdn.net/maojudong/article/details/7918291/" target="_blank" rel="noopener">《Ruby系列文章之6 —OS X 10.8.1 系统 HomeBrew 的安装和简单使用》</a></p><h3 id="安装fastlane"><a href="#安装fastlane" class="headerlink" title="安装fastlane"></a>安装fastlane</h3><p>最新的安装命令如下：<a href="https://blog.csdn.net/top_roboo/article/details/52087192" target="_blank" rel="noopener">解决方法</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install -n /usr/local/bin fastlane</span><br></pre></td></tr></table></figure><p>彻底解决方法 <a href="https://www.macx.cn/thread-2167166-1-5.html?mod=viewthread&amp;tid=2167166&amp;extra=page%253D5&amp;page=1" target="_blank" rel="noopener">解除 OSX 10.11 Rootless 的方法</a> </p><blockquote><p>该命令可以用来更新fastlane</p></blockquote><p>如果不是最新版本 还可以在项目文件里面执行指定版本来更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install -n /usr/local/bin/ fastlane --version2.104.0</span><br></pre></td></tr></table></figure><p>检查版本 fastlane    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fastlane -v</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">安装参考于该[文章](https://www.jianshu.com/p/abc2063f0981)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 初始化 ###</span><br><span class="line">打开[Terminal(终端)](sudo launchctl load -w /System/Library/LaunchDaemons/ssh.plist)，进入项目根目录下，初始化fastlane</span><br></pre></td></tr></table></figure><p>fastlane init<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">出现如下选项，`一般选择第4项`：      </span><br><span class="line">![](https://ws1.sinaimg.cn/large/006tNbRwgy1fvelhb6udrj30ve0k8zor.jpg) </span><br><span class="line"> 选项含义:</span><br><span class="line">    </span><br><span class="line"> * ① 自动化截图</span><br><span class="line"> * ② 将测试版分发自动化到TestFlight</span><br><span class="line"> * ③ 自动上传、发布到App Store</span><br><span class="line"> * ④ 手动设置 - 手动设置您的项目以使您的任务自动化</span><br><span class="line"> </span><br><span class="line">然后，输入开发者账号密码      </span><br><span class="line"></span><br><span class="line">![](https://upload-images.jianshu.io/upload_images/1533163-1fd4760349f624e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/587)</span><br><span class="line"></span><br><span class="line">以上就表示成功安装了Fastlane</span><br><span class="line"></span><br><span class="line">如果遇到下面的问题，一直卡在不动</span><br><span class="line">![](https://ws1.sinaimg.cn/large/006tNbRwgy1fveljinsb7j30vo0aiq50.jpg)</span><br><span class="line"></span><br><span class="line">那么可以不用管他，`关闭终端`或者`终止命令`即可。</span><br><span class="line"></span><br><span class="line">![](https://ws4.sinaimg.cn/large/006tNbRwgy1fvello1s6ej305i03j74m.jpg)</span><br><span class="line">## 发布到蒲公英（可选）##</span><br><span class="line">详情请移步[蒲公英](https://www.pgyer.com/doc/view/fastlane)</span><br><span class="line"></span><br><span class="line">### 安装蒲公英的 fastlane 插件 ###</span><br><span class="line">在`项目根`目录下，安装蒲公英插件:</span><br></pre></td></tr></table></figure></p><p>fastlane add_plugin pgyer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">稍等几秒钟</span><br><span class="line">如果出现类似下面的信息，就说明安装成功了：</span><br><span class="line">![](https://ws1.sinaimg.cn/large/006tNbRwgy1fvet3cqvatj30vc08i40m.jpg)</span><br><span class="line">期间会询问是否可以修改文件信息，选择`y`即可</span><br><span class="line"></span><br><span class="line">### 编辑 ###</span><br><span class="line">Fastlane 会自动在 App 目录中生成 fastlane 目录，其中就会有 Fastlane 的配置文件 fastlane/Fastfile，这里，我们用 vim 打开：</span><br></pre></td></tr></table></figure></p><p>vim ./fastlane/Fastfile<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后，我们找到我们在用的工作流（action），在 build_app 指令后，加入蒲公英插件的配置信息。例如：</span><br></pre></td></tr></table></figure></p><p>lane :beta do<br>  build_app(export_method: “development”)<br>  pgyer(api_key: “7f15xxxxxxxxxxxxxxxxxx141”, user_key: “4a5bcxxxxxxxxxxxxxxx3a9e”)<br>end<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 注意：</span><br><span class="line"></span><br><span class="line">&gt;以上的 `api_key` 和 `user_key`，请开发者在自己账号下的 `应用管理` - `App概述` - `API` 中可以找到，并替换到以上相应的位置。</span><br><span class="line">&gt;在 Xcode 8.3 和 Xcode 8.3 以后的版本中，对于 `build_app` 的 `export_method` 的值，需要根据开发者的打包类型进行设置，可选的值有：`app-store`、`ad-hoc`、`development`、`enterprise`。对于 Xcode 8.3 以下的版本，则不需要设置 `export_method`。</span><br><span class="line"></span><br><span class="line">### 打包并自动上传 App 到蒲公英 ###</span><br><span class="line">经过以上配置后，就可以使用 Fastlane 来打包 App，并自动上传到蒲公英了。在终端下，定位到项目所在目录，输入以下命令即可：</span><br></pre></td></tr></table></figure></p><p>fastlane beta<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后就充满激情的等待      </span><br><span class="line"></span><br><span class="line">![](https://ws2.sinaimg.cn/large/006tNbRwgy1fvdrmzvucwg305a05aq3g.gif)      </span><br><span class="line"></span><br><span class="line">最后打包成功提示</span><br><span class="line"></span><br><span class="line">![蒲公英](https://ws1.sinaimg.cn/large/006tNbRwgy1fvelgi3hnaj30vi0cmjsz.jpg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 其他 #</span><br><span class="line"></span><br><span class="line">### 卸载 ####</span><br></pre></td></tr></table></figure></p><p>gem/brew uninstall fastlane<br><code>`</code></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>在项目中手动删除 fastlane文件夹即可。</p><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><p>完成了发布到蒲公英之后肯定不再仅仅满足于此，毕竟 Fastlane 是集成一系列的自动化工具的，后面会进行一些详细的操作，比如上传到 <code>APP Store Connect</code>.详情请移步 <a href="">Fastlane (二)</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前沿&quot;&gt;&lt;a href=&quot;#前沿&quot; class=&quot;headerlink&quot; title=&quot;前沿&quot;&gt;&lt;/a&gt;前沿&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在使用Fastlane打包之前，你的项目必须是正确的。我的意思是说，你得用原生的方式成功Archive，并可以upload你的测试项目！否则会导致Fastlane打包失败&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="自动化" scheme="http://yoursite.com/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="Fastlane" scheme="http://yoursite.com/tags/Fastlane/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL EL (二)</title>
    <link href="http://yoursite.com/2018/09/18/OpenGL-EL-%E4%BA%8C/"/>
    <id>http://yoursite.com/2018/09/18/OpenGL-EL-二/</id>
    <published>2018-09-18T01:19:50.000Z</published>
    <updated>2018-09-18T01:19:50.612Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>OpenGL ES (一)</title>
    <link href="http://yoursite.com/2018/09/06/OpenGL-ES-%E4%B8%80/"/>
    <id>http://yoursite.com/2018/09/06/OpenGL-ES-一/</id>
    <published>2018-09-06T07:34:08.000Z</published>
    <updated>2018-09-14T09:52:30.273Z</updated>
    
    <content type="html"><![CDATA[<!--<div align=center>![1](http://d-pic-image.yesky.com/1080x-/uploadImages/2017/014/00/FP43CP909564.jpg)<div>--><p>最近，斗破苍穹电视剧上映的，里面的梗就不用多提， <code>三十年河东，三十年河西，莫欺少年穷</code> 指不定口碑低开高走呢。<br>人生也是一样, 无法预料,学历代表你的过去，能力代表你的现在，学习代表你的将来.<br>所以学无止境，需精益求精，不断的学习，才能蹒跚前行。    </p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>OpenGL ES （Open Graphics Library for Embedded Systems）是访问类似 iPhone 和 iPad 的现代嵌入式系统的 2D 和 3D 图形加速硬件的标准。<br>把程序提供的几何数据转换为屏幕上的图像的过程叫做渲染。<br>GPU 控制的缓存是高效渲染的关键。容纳几何数据的缓存定义了要渲染的点、线段和三角形。<br>OpenGL ES 3D 的默认坐标系、顶点和矢量为几何数据的描述提供了数学基础。<br>渲染的结果通常保存在帧缓存中。有两个特别的帧缓存，前帧缓存和后帧缓存，它们控制着屏幕像素的最终颜色。<br>OpenGL ES 的上下文保存了 OpenGL ES 的状态信息，包括用于提供渲染数据的缓存地址和用于接收渲染结果的缓存地址。</p></blockquote><p>OpenGL ES 是 OpenGL 的子集，它移除了 OpenGL 中冗余的函数，使其更易学也更容易在移动图形硬件中实现。</p><p>OpenGL ES 是基于 C 语言的 API ，所以可以无缝移植到 Objective—C 中，然后通过创建上下文来接收命令和操纵帧缓存。</p><p>在 iOS 中，使用 OpenGL ES 时，还可以使用 GLKit 框架中的 GLKView 将 OpenGL ES 绘制的内容渲染到屏幕上，并且可以使用 GLKViewController 来管理 GLKView 视图。另外，还可以使用 CAEAGLLayer 图层将动画与视图相结合。</p><blockquote><p>但是，需要注意的是，当应用处于后台状态时，不能调用 <em>OpenGL ES</em> 中的函数，否则应用便会被终止，而且 OpenGL ES 中的上下文也不支持在同一时刻被不同的线程访问。</p></blockquote><p>作为新手入门，我打算先了解一下 OpenGL 的一些基本概念</p><h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p>弄清楚坐标系很重要，它可以把几何图像和代数方程关联起来，是图像绘制的 布局的开始。</p><h3 id="iOS-手机坐标系"><a href="#iOS-手机坐标系" class="headerlink" title="iOS 手机坐标系"></a>iOS 手机坐标系</h3><p>二维坐标系，原点在左上角，x 轴向右，y 轴向下，x y 取值范围为屏幕分辨率：</p><p><img src="http://farm6.staticflickr.com/5192/7420067916_889152557b.jpg" alt="手机坐标"></p><h3 id="OpenGL-坐标系"><a href="#OpenGL-坐标系" class="headerlink" title="OpenGL 坐标系"></a>OpenGL 坐标系</h3><p>三维坐标系，原点在中间，x 轴向右，y 轴向上，z 轴朝向我们，x y z 取值范围都是 [-1, 1]：</p><p><img src="https://images2017.cnblogs.com/blog/1207934/201707/1207934-20170727100049437-925043765.png" alt="OpenGL坐标"></p><h3 id="纹理（texture）-坐标"><a href="#纹理（texture）-坐标" class="headerlink" title="纹理（texture） 坐标"></a>纹理（texture） 坐标</h3><p>为了能够把纹理映射到三角形，我们需要指定三角形的每一个顶点各自对应纹理的哪个部分。这样每一个顶点就会关联着一个纹理坐标，用来标明该从纹理图像的那一个人部分采样（采集片段颜色）。之后再图形的其他片段上进行片段插值。    </p><p>纹理坐标是二维坐标系，使用纹理坐标获取纹理颜色叫做采样，其原点在左下角，s（x）轴向右，t（y）轴向上，x y 取值范围都是 [0, 1]。<br>下面的图片展示了我们是如何把纹理坐标映射到三角形上：</p><p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/20170116148453793035367.jpg?imageView2/0/format/jpg" alt="纹理坐标"></p><h2 id="OpenGL-组成"><a href="#OpenGL-组成" class="headerlink" title="OpenGL 组成"></a>OpenGL 组成</h2><p> OpengGL 主要包括三个要素： 原件（Primitives） 缓冲区（Buffers） 光栅化（Rasterisation）</p><h3 id="原件"><a href="#原件" class="headerlink" title="原件"></a>原件</h3><p>原件 包括 点, 线 三角形。有的OpenGL版本还包括四边形，但在OpengGL ES中只有这三种原件</p><p>OpenGL 绘制的都是图形，包括形状和填充，基本形状是三角形。<br>每个形状都有顶点，Vertix，顶点的序列就是一个图形。<br>图形有所谓的正反面，如果我们看向一个图形，它的顶点序列是逆时针方向，那我们看到的就是正面。</p><h3 id="缓存区"><a href="#缓存区" class="headerlink" title="缓存区"></a>缓存区</h3><p>缓冲区包括三个概念: <code>帧缓冲区</code>(Frame Buffers)   <code>渲染缓冲区</code>(Render Buffers)  <code>缓冲区对象</code>(Buffer Objects)</p><ul><li><p>帧缓冲区 <code>是GL储存渲染结果的地方,为GPU指定存储渲染结果的区域</code>，它可以包含多个图像，也就是包含多个渲染缓冲区。更通俗点，可以理解成存储屏幕上最终显示的一帧画面的区域.      </p></li><li><p>渲染缓冲区 也就是一个图像，也被称作颜色缓冲区.因为它本质上是存储要显示的颜色.例如颜色图像，深度图像，模版图像（决定每一个位置是可以的掩膜）等。</p></li><li><p>缓冲区对象 就是程序员提供给OpenGL的数据，分为结构类和索引类。前者被称为 “数组缓冲区对象” 或者 “顶点缓冲对象”（“Array Buffer Object or Vertex Buffer Object”），即用来描述模型的数组，如顶点数组，纹理数组等；后者被称为 “索引缓冲区对象”（“Index Buffer Object”），是对上述数组的索引。</p></li></ul><h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/20170112706113F85123B-6006-4633-9D8C-C4C4DB4BA3AC.png" alt="光栅化"></p><p>光栅化的过程就是根据缓冲区对象里提供的数据 经过渲染 从3D模型得到2D模型的过程。得到的2D图像会根据帧缓冲区的配置来决定是直接送到屏幕显示 或是 做别的用处。      </p><p><code>在光栅化阶段，基本图元被转换为供片段着色器使用的片段（Fragment</code>），Fragment 表示可以被渲染到屏幕上的像素，它包含位置，颜色，纹理坐标等信息，这些值是由图元的顶点信息进行插值计算得到的。这些片元接着被送到片元着色器中处理。这是从顶点数据到可渲染在显示设备上的像素的质变过程。</p><p>在片段着色器运行之前会执行裁切（Clipping）。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p><h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><p>从2.0版本开始，OpenGL支持可变的流水线，也就是说，程序员 可以通过 Shader（一种程序，一段包含着色信息的源代码字符串）来控制GPU渲染的过程。</p><p>Shader 也叫着色器，用来描述如何绘制（渲染）， GLSL 是 OpenGL 的 编程语言，全称全称就叫 OpenGL Shader Language。</p><p> Shader 分为 <code>Vertex Shader</code> 和 <code>Fragment Shader</code>。这两种Shader是成对出现的，GPU先执行前者，后执行后者。</p><h3 id="Vertex-Shader（顶点着色器）"><a href="#Vertex-Shader（顶点着色器）" class="headerlink" title="Vertex Shader（顶点着色器）"></a>Vertex Shader（顶点着色器）</h3><p>Vertex Shader 对于3D模型网格的每一个顶点执行一次，主要是确定改顶点的最终位置。Vertex Shader 还会准备并输出一些变量，传给 Fragment Shader 使用。 简单点就是 控制顶点的绘制，指定坐标、变换等。</p><h3 id="Fragment-Shader（片元着色器）"><a href="#Fragment-Shader（片元着色器）" class="headerlink" title="Fragment Shader（片元着色器）"></a>Fragment Shader（片元着色器）</h3><p><img src="http://7xkc7a.com1.z0.glb.clouddn.com/20170112997054573CDB0-956C-4A00-837F-6BDA9BA4F550.png" alt=""></p><p>Fragment Shader(也叫片段着色器) 对于最终得到的2D图像的每一个像素处理一次。3D物体的表面最终显示成什么样将有它决定。例如为模型的可见表面添加纹理，处理光照 阴影的影响等等，都在这里做。 Fragment Shader 的输出是一个 RGBA 格式的像素颜色值。 简单点就是 控制形状内区域渲染，纹理填充内容。</p><h3 id="着色器的使用流程"><a href="#着色器的使用流程" class="headerlink" title="着色器的使用流程"></a>着色器的使用流程</h3><p>着色器源代码和OpenGL源代码不是一起编译的，所以要特别强调我刚才说的“着色器是一段包含着色信息的源代码字符串”。所以，OpenGL源代码肯定是和工程一起编译的，但是着色器源代码是在运行期编译的。你可能会问，着色器的源代码是一个字符串怎么编译呢？所以OpenGL ES提供了一套运行期动态编译的流程：</p><p>（1）创建着色器：glCreateShader</p><p>（2）指定着色器源代码字符串：glShaderSource</p><p>（3）编译着色器：glCompileShader</p><p>（4）创建着色器可执行程序：glCompileShader</p><p>（5）向可执行程序中添加着色器：glAttachShader</p><p>（6）链接可执行程序：glLinkProgram</p><h2 id="OpenGL-有关概念"><a href="#OpenGL-有关概念" class="headerlink" title="OpenGL 有关概念"></a>OpenGL 有关概念</h2><p>OpenGL 提供一组API，各显卡制造商和系统制造商来实现这组API。       </p><p>EGL 是另一组API，主要是系统制造商实现，它负责OpenGL和原生窗口系统之间的接口，用于把OpenGL 渲染的结果显示在屏幕上。      </p><p>EGAL 是Apple公司对EGL做了修改，自己实现的一套屏幕显示接口，一般只用于iOS和 OS X 系统中。</p><p>关系如下图所示</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fv0xlv41zej30sg0lcwjc.jpg" alt="关系图"></p><p>参考文章：<br><a href="https://www.2cto.com/kf/201706/647894.html" target="_blank" rel="noopener">https://www.2cto.com/kf/201706/647894.html</a><br><a href="https://blog.csdn.net/wangyuchun_799/article/details/7736928" target="_blank" rel="noopener">https://blog.csdn.net/wangyuchun_799/article/details/7736928</a><br><a href="https://www.jianshu.com/p/ce287a5460cd" target="_blank" rel="noopener">https://www.jianshu.com/p/ce287a5460cd</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!--
&lt;div align=center&gt;![1](http://d-pic-image.yesky.com/1080x-/uploadImages/2017/014/00/FP43CP909564.jpg)&lt;div&gt;
--&gt;
&lt;p&gt;最近，斗破苍穹电视剧上映的，里面的梗就不用多提， &lt;code&gt;三十年河东，三十年河西，莫欺少年穷&lt;/code&gt; 指不定口碑低开高走呢。&lt;br&gt;人生也是一样, 无法预料,学历代表你的过去，能力代表你的现在，学习代表你的将来.&lt;br&gt;所以学无止境，需精益求精，不断的学习，才能蹒跚前行。    &lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="OpenGL" scheme="http://yoursite.com/tags/OpenGL/"/>
    
      <category term="iOS进阶" scheme="http://yoursite.com/tags/iOS%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>《AV Foundation 开发秘籍》之 数据的采集和编码</title>
    <link href="http://yoursite.com/2018/09/04/%E3%80%8AAV-Foundation-%E5%BC%80%E5%8F%91%E7%A7%98%E7%B1%8D%E3%80%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2018/09/04/《AV-Foundation-开发秘籍》（一）/</id>
    <published>2018-09-04T08:23:20.000Z</published>
    <updated>2018-09-26T08:11:59.015Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AVFoundation简介"><a href="#AVFoundation简介" class="headerlink" title="AVFoundation简介"></a>AVFoundation简介</h2><p>AVFoundation是苹果在iOS和OS X系统中用于处理基于时间的媒体数据的Objective-C框架. 供使用者来开发媒体类型的应用程序。</p><p><img src="/2018/09/04/《AV-Foundation-开发秘籍》（一）/avfoundation.png" alt=""></p><p>如果只是进行简单的视频录制，使用UIKit中的<code>UIImagePickerController</code>就可以了。如果需要播放视频，使用AVKit框架也足够了。但是如果需要进行视频文件的处理等更灵活等操作，就需要使用到AVFoundation等底层的框架了。</p><ul><li><p><code>Core Audio</code> : 处理所有音频事件.是由多个框架整合在一起的总称,为音频和MIDI内容的录制,播放和处理提供相应接口.尤其是 <code>Audio Units</code> 接口，提供针对音频信号进行完全控制的功能,也可以通过它来构建一些复杂的音频处理.</p></li><li><p><code>Core Video</code> : 针对数字视频所提供的管道模式。Core Video为其相对的Core Media提供图片缓存和缓存池支持，提供了一个能够对数字视频逐帧访问的接口。</p></li><li><p><code>Core Media</code> : 是AVFoundation所用到低层级媒体管道的一部分.提供音频样本和视频帧处理所需的低层级数据类型和接口.</p></li><li><p><code>Core Animation</code> : 合成及动画相关框架, 封装了支持OpenGL和OpenGL ES功能的Obj-C的各种类. AVFoundation可以利用CoreAnimation让开发者能够在视频的编辑和播放过程中添加动画和图片效果.</p></li></ul><h2 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h2><h3 id="采集过程"><a href="#采集过程" class="headerlink" title="采集过程"></a>采集过程</h3><p>为了管理从相机或者麦克风等这样的设备捕获到的信息，我们需要输入对象(input)和输出对象(output)，并且使用一个会话(AVCaptureSession)来管理 input 和 output 之前的数据流：</p><p><img src="/2018/09/04/《AV-Foundation-开发秘籍》（一）/capture.png" alt=""></p><p>通过单个 session，也可以管理多个 input 和 output 对象之间的数据流，从而得到视频、静态图像和预览视图。input 可以有一个或多个输入端口，output 也可以有一个或多个数据来源(比如视频+音频)。</p><p>当添加 input 和 output 到 session 中时，session 会自动建立起一个连接(AVCaptureConnection)。我们可以使用这个 connection 来设置从 input 或者 从 output 得到的数据的有效性，也可以用来监控在音频信道中功率的平均值和峰值。</p><p><img src="/2018/09/04/《AV-Foundation-开发秘籍》（一）/connection.png" alt=""></p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>仅录制音频      </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> audioSettings = [<span class="type">AVFormatIDKey</span>: kAudioFormatLinearPCM, <span class="comment">// 格式      </span></span><br><span class="line">                     <span class="type">AVSampleRateKey</span>: <span class="number">44100</span>, <span class="comment">// 采样率      </span></span><br><span class="line">                     <span class="type">AVNumberOfChannelsKey</span>: <span class="number">1</span>, <span class="comment">// 声道数      </span></span><br><span class="line">                     <span class="type">AVLinearPCMBitDepthKey</span>: <span class="number">16</span>] <span class="comment">// 位深度      </span></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(fileURLWithPath: <span class="string">"\(NSHomeDirectory())/tmp/audio.pcm"</span>)       </span><br><span class="line"><span class="keyword">do</span> &#123;      </span><br><span class="line">    <span class="keyword">let</span> recorder = <span class="keyword">try</span> <span class="type">AVAudioRecorder</span>(url: url, settings: audioSettings)       </span><br><span class="line">    recorder.record()       </span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;       </span><br><span class="line">    <span class="built_in">print</span>(error)       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>录制视频</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> session = <span class="type">AVCaptureSession</span>()</span><br><span class="line"><span class="keyword">if</span> session.canSetSessionPreset(.hd1280x720) &#123;</span><br><span class="line">    session.sessionPreset = .hd1280x720</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">self</span>.session = session</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加视频源</span></span><br><span class="line"><span class="keyword">let</span> videoDevice = <span class="type">AVCaptureDevice</span>.<span class="keyword">default</span>(<span class="keyword">for</span>: .video)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> device = videoDevice &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> input = <span class="keyword">try</span> <span class="type">AVCaptureDeviceInput</span>(device: device)</span><br><span class="line">        <span class="keyword">if</span> session.canAddInput(input) &#123;</span><br><span class="line">            session.addInput(input)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;</span><br><span class="line">        <span class="built_in">print</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加音频源</span></span><br><span class="line"><span class="keyword">let</span> audioDevice = <span class="type">AVCaptureDevice</span>.<span class="keyword">default</span>(<span class="keyword">for</span>: .audio)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> device = audioDevice &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> input = <span class="keyword">try</span> <span class="type">AVCaptureDeviceInput</span>(device: device)</span><br><span class="line">        <span class="keyword">if</span> session.canAddInput(input) &#123;</span><br><span class="line">            session.addInput(input)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;</span><br><span class="line">        <span class="built_in">print</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 输出每一帧</span></span><br><span class="line"><span class="keyword">let</span> dataOutput = <span class="type">AVCaptureVideoDataOutput</span>()</span><br><span class="line">dataOutput.videoSettings = [kCVPixelBufferPixelFormatTypeKey: kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange] <span class="keyword">as</span> [<span class="type">String</span> : <span class="type">Any</span>]</span><br><span class="line">dataOutput.setSampleBufferDelegate(<span class="keyword">self</span>, queue: <span class="type">DispatchQueue</span>.main)</span><br><span class="line"><span class="keyword">if</span> session.canAddOutput(dataOutput) &#123;</span><br><span class="line">    session.addOutput(dataOutput)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 输出为文件</span></span><br><span class="line"><span class="keyword">let</span> fileOutput = <span class="type">AVCaptureMovieFileOutput</span>()</span><br><span class="line"><span class="keyword">if</span> session.canAddOutput(fileOutput) &#123;</span><br><span class="line">    session.addOutput(fileOutput)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> connection = fileOutput.connection(with: .video)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> conn = connection, conn.isVideoStabilizationSupported &#123;</span><br><span class="line">    conn.preferredVideoStabilizationMode = .auto</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(fileURLWithPath: <span class="string">"\(NSHomeDirectory())/tmp/movie.mov"</span>)</span><br><span class="line"><span class="comment">// 开始录制</span></span><br><span class="line">fileOutput.startRecording(to: url, recordingDelegate: <span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> previewLayer = <span class="type">AVCaptureVideoPreviewLayer</span>(session: session)</span><br><span class="line">previewLayer.frame = view.bounds</span><br><span class="line">view.layer.addSublayer(previewLayer)</span><br><span class="line"></span><br><span class="line">session.startRunning()</span><br></pre></td></tr></table></figure><p><code>AVCaptureMovieFileOutput</code>和<code>AVCaptureVideoDataOutput</code>的区别在于，前者是把采集到到数据直接写入到文件，而后者通过下面到代理方法将每一帧到图像数据发送过来，以便于进行一些处理。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">captureOutput</span><span class="params">(<span class="number">_</span> output: AVCaptureOutput, didOutput sampleBuffer: CMSampleBuffer, from connection: AVCaptureConnection)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(sampleBuffer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="音频采集相关概念"><a href="#音频采集相关概念" class="headerlink" title="音频采集相关概念"></a>音频采集相关概念</h3><p>音频的采集过程主要是通过设备将环境中的模拟信号转换成<code>PCM</code>编码的原始数据，然后编码压缩成<code>MP3</code>、<code>AAC</code>、<code>WMA</code>、<code>m4a</code>、<code>APE</code>、<code>FLAC</code>等格式。</p><h4 id="PCM"><a href="#PCM" class="headerlink" title="PCM"></a>PCM</h4><blockquote><p>PCM全称Pulse Code Modulation，中文名为脉冲编码调制。脉冲编码调制就是对模拟信号先抽样，再对样值幅度量化，编码的过程。</p></blockquote><p>衡量一个音频文件的质量的一个重要指标是比特率(码率)，单位为bps(bit per second)，也就是单位时间内传输的比特数。</p><p>而影响比特率的因素有：</p><ol><li>采样率(Sample Rate)：采样的频率，采样的频率越高，数据量就越大，音质就越高。</li></ol><p><img src="/2018/09/04/《AV-Foundation-开发秘籍》（一）/pcm.jpg" alt=""></p><ol start="2"><li><p><a href="https://zhidao.baidu.com/question/1575028964185733420.html" target="_blank" rel="noopener">位深度(Bit Depth)</a>：表示每一个采样点所需要的数值的大小。可以是4bit、8bit、16bit等，位数越多，采样点表示的精度就越高，音质就越高，数据量也会成倍的增加。</p></li><li><p>声道数(Number of Channels)：由于音频的采集和播放是可以叠加的，因此，可以同时从多个音频源采集声音，并分别输出到不同的扬声器，故声道数一般表示声音录制时的音源数量或回放时相应的扬声器数量。声道数为 1 和 2 分别称为单声道和双声道。</p></li></ol><p>根据采样率 量化 声道 我们就可以计算出一个采样率为44100Hz，位深度为16bit，时长为3分钟的单声道CD歌曲的数据量为：<br><code>44100Hz x 16bit x 5 x 60s x 2 = 423360000bit = 52.9MB</code><br>比特率为：<code>423360000bit / (5 x 60s) = 1441kbps</code><br>这样的数据大小显然是不能接受的，所以才有了上面提到的<code>MP3</code>、<code>AAC</code>、<code>WMA</code>、<code>m4a</code>、<code>APE</code>、<code>FLAC</code>这些压缩格式的出现。</p><p>音频的压缩分为无损压缩和有损压缩，简单的来说，有损压缩就是通过删除一些已有数据中不太重要的数据来达到压缩目的；无损压缩就是通过优化排列方式来达到压缩目的。</p><p><code>MP3</code>、<code>AAC</code>、<code>WMA</code>、<code>m4a</code>都属于有损压缩，假设把上面的歌曲压缩为码率128kpbs的普通音质的MP3，压缩比为<code>1441kpbs / 128kbps = 11</code>，因此压缩后的文件大小为<code>52.9MB / 11 = 5MB</code>。</p><p><code>APE</code>、<code>FLAC</code>属于无损压缩，文件相对较大。</p><h3 id="图像采集相关概念"><a href="#图像采集相关概念" class="headerlink" title="图像采集相关概念"></a>图像采集相关概念</h3><p>图像采集的图片结果组合成一组连续播放的动画，即构成视频中可肉眼观看的内容。图像的采集过程主要由摄像头等设备拍摄成 YUV 编码的原始数据，然后经过编码压缩成 H.264 等格式的数据分发出去。常见的视频封装格式有：MP4、3GP、AVI、MKV、WMV、MPG、VOB、FLV、SWF、MOV、RMVB 和 WebM 等。</p><p>图像数据质量的同样可以通过码率来进行衡量，而影响码率的因素主要有：</p><ol><li>图像的分辨率(Resolution)：视频采集过程中的原始分辨率决定了视频整体的清晰度，分辨率越高，视频越清晰。常见的分辨率有<code>480p</code>、<code>720</code>、<code>1080p</code>、<code>4k</code>。</li><li>图像的格式：视频图像一般采用YUV格式存储原始的数据信息，而不是采用常见的RGB格式。</li><li>帧率(Frame Rate)：单位时间内捕获到到图像到数量，帧率越高，画面的流畅度就越高。一般的视频的帧率为30fps。延时摄影就是以远低于普通帧率的频率进行图像的采集然后以正常的帧率进行播放，就会有一种加速的效果。而高速摄影（慢动作）就是以远高于普通帧率的频率进行图像的采集，然后以正常的帧率进行播放，就会有一种变慢的效果。</li><li>传输通道数：一般情况下都只有一个摄像头进行数据的采样，而随着VR和AR技术的发展，要拍摄一个360度的视频，就需要多个摄像头来同时进行采集了。</li></ol><h4 id="图像的位深度"><a href="#图像的位深度" class="headerlink" title="图像的位深度"></a>图像的位深度</h4><p>我们知道对于一个普通的不包含Alpha通道的位图图像而言，每一个像素点的数据都可以通过R、G、B三个分量数据来进行表示。每个数据用用多大的数值来表示就决定了这个图像的位深度，也即图像的色彩范围。色彩越丰富，‘位’越多。假设我们用1个字节来表示一个分量的数值，即24位真彩色，那么总共就有<code>2^8 x 2^8 x 2^8 = 1600万</code>种颜色，而如果对RGB分别用3bit、3bit、2bit也即8位色来表示的话 只有<code>2^3 x 2^3 x 2^2 = 256</code>种颜色。</p><p><img src="/2018/09/04/《AV-Foundation-开发秘籍》（一）/24bit.png" alt=""></p><p>24位色的图片</p><p><img src="/2018/09/04/《AV-Foundation-开发秘籍》（一）/8bit.png" alt=""></p><p>8位色的图片</p><h4 id="YUV格式"><a href="#YUV格式" class="headerlink" title="YUV格式"></a>YUV格式</h4><p>与我们所熟知的RGB类似，YUV也是一种颜色的编码方法，主要用于视频领域。它将亮度信息(Y)与色彩信息(UV也称CbCr)分离，没有UV信息一样可以显示完整的图像，只不过是黑白的。这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。并且，YUV不像RGB那样要求三个独立的视频信号同时传输，所以用YUV方式传送占用极少的频宽。我们人眼对于亮度的感知比对色彩的感知更为强烈，所以可以通过减少色彩信息(UV)的采样来减少数据量。这就是二次采样</p><p><img src="/2018/09/04/《AV-Foundation-开发秘籍》（一）/chroma.png" alt=""></p><p>色彩信息(UV)</p><p><img src="/2018/09/04/《AV-Foundation-开发秘籍》（一）/luma.png" alt=""></p><p>亮度和色度的对比</p><p>YUV码流的存储格式其实与其采样的方式密切相关，主流的采样方式有三种，YUV4:4:4、YUV4:2:2、YUV4:2:0，如下图所示：</p><p><img src="/2018/09/04/《AV-Foundation-开发秘籍》（一）/yuv.png" alt=""></p><p>对于YUV 4:4:4采样，每一个Y分量对应一组UV分量<br>对于YUV 4:2:2采样，每两个Y分量公用一组UV分量<br>对于YUV 4:2:0采样，每四个Y分量公用一组UV分量       </p><p>YUV格式有两大类：planar和packed。<br>对于planar的YUV格式，先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。<br>对于packed的YUV格式，每个像素点的Y,U,V是连续交叉存储的。</p><p>一般移动平台视频录制使用的是YUV 4:2:0，而根据各个分量的排列顺序不同又分为<code>YV12</code>、<code>I420(YU12)</code>、<code>NV12</code>、<code>NV21</code>。</p><p><code>YV12</code>和<code>I420</code>也称为YUV420P，即planar平面格式。YV12和I420的区别仅在与UV顺序的不同。顾名思义，YV12中Y平面后面紧跟的是V平面，然后是U平面，12表示它的位深度为12，也就是一个像素占12bit。而I420(YU12)顺序刚好与之相反。</p><p><code>NV12</code>和<code>NV21</code>都属于YUV420SP，即Y分量平面格式，UV分量打包格式。也即先存储Y平面，后面是UV分量交错存储。iOS平台使用的是<code>NV21</code>格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I420: YYYYYYYY UU VV  =&gt; YUV420P</span><br><span class="line">YV12: YYYYYYYY VV UU  =&gt; YUV420P</span><br><span class="line">NV12: YYYYYYYY UVUV   =&gt; YUV420SP</span><br><span class="line">NV21: YYYYYYYY VUVU   =&gt; YUV420SP</span><br></pre></td></tr></table></figure><p>I420(Planar)的单帧结构示意图如下：(I420 ： 亮度（行×列） +U（行×列/4) + V（行×列/4）)</p><p><img src="/2018/09/04/《AV-Foundation-开发秘籍》（一）/i420p.png" alt=""></p><p>NV12(Planar)的单帧结构示意图如下:</p><p><img src="/2018/09/04/《AV-Foundation-开发秘籍》（一）/nv12.png" alt=""></p><p>根据上图所示：</p><p>一张分辨率为6 x 4的图片采用YUV420的方式存储所占的空间为<code>6 x 4 + 6 + 6 = 36</code>个字节，而如果采用RGB的方式存储就需要占用<code>6 x 4 x 3 = 72</code>个字节，数据量减少了一半。(本文中像素的采样位数一律为8bit。由于1Byte=8bit，所以一个像素的一个分量的采样值占用1Byte)</p><p>如果以YUV420的方式编码一部720p、帧率为30fps、时长两小时的高清电影所需要的空间为</p><p><code>12bit x 1280 x 720 x 30 x 120 x 60 = 2.38 x 10^12bit = 298.6GB</code></p><p>这个大小显然是不能接受的，经过编码我们可以把它压缩到2G左右，而画面到清晰度不会有多少损失。</p><h3 id="视频编码"><a href="#视频编码" class="headerlink" title="视频编码"></a>视频编码</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>为什么视频文件的压缩比可以达到100:1甚至更高？核心的思想就是去除冗余信息。</p><p>视频文件中的冗余信息分为以下几类：</p><ol><li>空间冗余：每一帧图像相邻像素之间有较强的关联性</li><li>时间冗余：视频相邻帧之间的内容相似</li><li>编码冗余：不同像素值出现的概率不同</li><li>视觉冗余：人眼对于某些细节不敏感</li><li>知识冗余：规规律性的结构可由先验知识和背景知识得到</li></ol><p>对于视频文件最简单的压缩方式就是对每一帧图像进行压缩，叫做帧内压缩。有一种比较古老的 MJPEG 编码就是这种编码方式。可以理解为把视频的每一帧当作一张图片，然后按照JPEG的方式来进行压缩。这样的压缩方式只处理了空间冗余信息，离理想的压缩比还差得远。</p><p>视频的图像的相邻帧之间具有很大的相似性，因此去除时间冗余信息对于提高压缩比有很大的提升空间。比如说一些高级的编码器可以采用帧间编码，简单点说就是通过搜索算法选定了帧上的某些区域，然后通过计算当前帧和前后参考帧的向量差进行编码的一种形式，通过下面两个图 2 连续帧我们可以看到，滑雪的同学是向前位移的，但实际上是雪景在向后位移。后面的帧就可以参考前面的帧进行编码，这样后面的帧编码的结果就非常小，压缩比很高。</p><p><img src="/2018/09/04/《AV-Foundation-开发秘籍》（一）/time-redundancy.jpg" alt=""></p><p>去除其他的冗余信息这里就不多说了。</p><h4 id="常用编码器"><a href="#常用编码器" class="headerlink" title="常用编码器"></a>常用编码器</h4><h5 id="H-264"><a href="#H-264" class="headerlink" title="H.264"></a>H.264</h5><blockquote><p>H.264/AVC 是现在使用最广泛的编码标准。与旧标准相比，它能够在更低带宽下提供优质视频（换言之，只有 MPEG-2，H.263 或 MPEG-4 第 2 部分的一半带宽或更少），也不增加太多设计复杂度使得无法实现或实现成本过高。另一目的是提供足够的灵活性以在各种应用、网络及系统中使用，包括高、低带宽，高、低视频分辨率，广播，DVD 存储，RTP/IP 网络，以及 ITU-T 多媒体电话系统。</p></blockquote><h5 id="H-265"><a href="#H-265" class="headerlink" title="H.265"></a>H.265</h5><p>2017年6月6日凌晨召开WWDC 2017大会上苹果在iOS11上推出了HEVC，用来取代H.264</p><blockquote><p>高效率视频编码（High Efficiency Video Coding，简称HEVC）是一种视频压缩标准，被视为是 ITU-T H.264/MPEG-4 AVC 标准的继任者。2004 年开始由 ISO/IEC Moving Picture Experts Group（MPEG）和 ITU-T Video Coding Experts Group（VCEG）作为 ISO/IEC 23008-2 MPEG-H Part 2 或称作 ITU-T H.265 开始制定。第一版的 HEVC/H.265 视频压缩标准在 2013 年 4 月 13 日被接受为国际电信联盟（ITU-T）的正式标准。HEVC 被认为不仅提升视频质量，同时也能达到 H.264/MPEG-4 AVC 两倍之压缩率（等同于同样画面质量下比特率减少了 50%），可支持 4K 分辨率甚至到超高清电视（UHDTV），最高分辨率可达到 8192×4320（8K分辨率）。</p></blockquote><h4 id="硬件编解码和软件编解码"><a href="#硬件编解码和软件编解码" class="headerlink" title="硬件编解码和软件编解码"></a>硬件编解码和软件编解码</h4><p>iOS8开始，苹果通过<code>Video ToolBox</code>开放了系统的硬件编解码能力。在这之前，开发者基本上都是使用的是一个叫做<a href="https://www.ffmpeg.org/" target="_blank" rel="noopener">FFmpeg</a>的多媒体库，利用CPU做视频的编解码，俗称软解码。</p><blockquote><p>FFmpeg 是一个自由软件，可以运行音频和视频多种格式的录影、转换、流功能，包含了 libavcodec ——这是一个用于多个项目中音频和视频的解码器库，以及 libavformat —— 一个音频与视频格式转换库。</p></blockquote><h4 id="视频容器-格式"><a href="#视频容器-格式" class="headerlink" title="视频容器(格式)"></a>视频容器(格式)</h4><p>所谓容器，就是把编码器生成的多媒体内容（视频，音频，字幕，章节信息等）混合封装在一起的标准。容器使得不同多媒体内容同步播放变得很简单，而容器的另一个作用就是为多媒体内容提供索引，也就是说如果没有容器存在的话一部影片你只能从一开始看到最后，不能拖动进度条（当然这种情况下有的播放器会花比较长的时间临时创建索引），而且如果你不自己去手动另外载入音频就没有声音。</p><p><img src="/2018/09/04/《AV-Foundation-开发秘籍》（一）/mov-atom.gif" alt=""></p><p>MOV文件的结构</p><p>常见的视频容器格式有：</p><ul><li><p>AVI 格式（后缀为 .AVI）: 它的英文全称为 Audio Video Interleaved ，即音频视频交错格式。它于 1992 年被 Microsoft 公司推出。<br>这种视频格式的优点是图像质量好。由于无损AVI可以保存 alpha 通道，经常被我们使用。缺点太多，体积过于庞大，而且更加糟糕的是压缩标准不统一，最普遍的现象就是高版本 Windows 媒体播放器播放不了采用早期编码编辑的AVI格式视频，而低版本 Windows 媒体播放器又播放不了采用最新编码编辑的AVI格式视频，所以我们在进行一些AVI格式的视频播放时常会出现由于视频编码问题而造成的视频不能播放或即使能够播放，但存在不能调节播放进度和播放时只有声音没有图像等一些莫名其妙的问题。</p></li><li><p>QuickTime File Format 格式（后缀为 .MOV）: 美国Apple公司开发的一种视频格式，默认的播放器是苹果的QuickTime。<br>具有较高的压缩比率和较完美的视频清晰度等特点，并可以保存alpha通道。</p></li><li><p>MPEG 格式（文件后缀可以是 .MPG .MPEG .MPE .DAT .VOB .ASF .3GP .MP4等) : 它的英文全称为 Moving Picture Experts Group，即运动图像专家组格式，该专家组建于1988年，专门负责为 CD 建立视频和音频标准，而成员都是为视频、音频及系统领域的技术专家。<br>MPEG 文件格式是运动图像压缩算法的国际标准。MPEG 格式目前有三个压缩标准，分别是 MPEG－1、MPEG－2、和MPEG－4 。MPEG－1、MPEG－2 目前已经使用较少，着重介绍 MPEG－4，其制定于1998年，MPEG－4 是为了播放流式媒体的高质量视频而专门设计的，以求使用最少的数据获得最佳的图像质量。目前 MPEG-4 最有吸引力的地方在于它能够保存接近于DVD画质的小体积视频文件。</p></li><li><p>Real Video 格式（后缀为 .RM .RMVB）: Real Networks 公司所制定的音频视频压缩规范称为Real Media。<br>用户可以使用 RealPlayer 根据不同的网络传输速率制定出不同的压缩比率，从而实现在低速率的网络上进行影像数据实时传送和播放。RMVB 格式：这是一种由RM视频格式升级延伸出的新视频格式，当然性能上有很大的提升。RMVB 视频也是有着较明显的优势，一部大小为700MB左右的 DVD 影片，如果将其转录成同样品质的 RMVB 格式，其个头最多也就 400MB 左右。大家可能注意到了，以前在网络上下载电影和视频的时候，经常接触到 RMVB 格式，但是随着时代的发展这种格式被越来越多的更优秀的格式替代，著名的人人影视字幕组在2013年已经宣布不再压制 RMVB 格式视频。</p></li><li><p>Matroska 格式（后缀位 .MKV）:是一种新的多媒体封装格式，这个封装格式可把多种不同编码的视频及16条或以上不同格式的音频和语言不同的字幕封装到一个Matroska Media档内。它也是其中一种开放源代码的多媒体封装格式。Matroska同时还可以提供非常好的交互功能，而且比MPEG更方便、强大。</p></li></ul><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   在完整的数字音频生产流程流程中，最终的成品品质是由信号采样量化,信号编码，信号传输，信号同步，信号处理，信号存储等多个环节共同决定的，      </span><br><span class="line">   很大程度依赖与软硬件的性能指标，而工作者对与采样量化相关概念的明确，是音频质量的一道重要的保障，总的来说 工作中选择采样率与量化位深的原则有几点</span><br><span class="line"><span class="number">1</span>.在高精度和系统性能之间选取平衡点</span><br><span class="line"><span class="number">2</span>.一般不低于 24bit/<span class="number">44</span>.1kHz规格</span><br><span class="line"><span class="number">3</span>.尽可能减少流程中采样率转换的次数</span><br><span class="line"><span class="number">4</span>.在降低量化位深时，进行有效的技术补偿</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;AVFoundation简介&quot;&gt;&lt;a href=&quot;#AVFoundation简介&quot; class=&quot;headerlink&quot; title=&quot;AVFoundation简介&quot;&gt;&lt;/a&gt;AVFoundation简介&lt;/h2&gt;&lt;p&gt;AVFoundation是苹果在iOS和OS
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 组件化+热切换+热更新+MVVM 架构思想漫谈</title>
    <link href="http://yoursite.com/2018/09/03/iOS-%E6%9E%B6%E6%9E%84%E6%80%9D%E6%83%B3%E6%BC%AB%E8%B0%88/"/>
    <id>http://yoursite.com/2018/09/03/iOS-架构思想漫谈/</id>
    <published>2018-09-03T08:45:46.000Z</published>
    <updated>2018-09-18T06:59:29.406Z</updated>
    
    <content type="html"><![CDATA[<p>移动互联网发展10余年来，移动应用也谁之发生了翻天覆地的变化。从最初的几M小应用到现在动则几十上百M；从最初的一个人几个小功能，到现在的几十上百号人，比PC网页还要齐全还要强大的功能。在此过程中，原有的单Project，MVC架构，一个月一发版，已经远远不能满足当前移动应用的开发。于是乎，一个新的名词便诞生了–移动架构师。<br><a id="more"></a><br>   总有开发者朋友问我，得具备什么样的水平，多长的工作经验，做过多大的项目才能成为一个架构师啊。的确，这个问题很难回答。架构，在很大程度上并不具有具体的角色定位，架构师亦然。能够独立做出一个APP，可以称为这个APP的架构师。能够把控一个超级APP的所有技术解决方案，可以称为这个超级APP的架构师。</p><p>   总有开发者朋友问我，什么样的架构才是好架构。在很长一段时间，C/S架构独领风骚，随后B/S架构横空出世，一时风头无两，但是随着移动互联网的出现和发展，C/S架构又成为移动应用的主流，再次焕发初生命地光彩，重拾其荣耀，但与此同时B/S却也依然坚挺。这就是架构，只有适合，没有好坏。</p><p>   同样，我们今天所谈论的这套宏伟的iOS架构，是绝对不适合只有几个页面的小APP的。至于如何抉择，3人以上的开发团队可以组建化，百万级别日活可以热切换，百万级别用户量可以热更新，需求频繁、功能分布零散，高耦合可以用MVVM。</p><p>   数据持久化方案，网络方案，MODEL方案，这些也是架构，怎么今天不谈呢？因为这是技术，而我们今天所谈论的是思想。</p><p>   APP组件化，我总结了两种方案。总线+分线、分线+分线。第一种，总线+分线方案，对应IOS APP，即多个子模块加一个主模块，主模块负责所有子模块间的组合和通信，必不可少；第二钟，分线+分线，即任意两个子模块都可以组合构成一个独立的APP。对于这两种方案，第一种便于理解和实现，第二种灵活性更高，优势虐势都很明显，至于取舍，选则自己擅长的便是。</p><p>   APP组件化的具体实现，我推荐使用 <code>CocoaPods私有Pod</code> 来实现各个组件，理由有下，技术成熟、资料众多，使用者众。具体实现方式亦有两种。<br>   第一种，将各个组件做为LocalPod，方便调适，维护。<br>   第二种，像第三方Pod一样作为外部组件引入，优势是便于把控。同时，这两种方式也可以结合使用，与业务毫无关联的基础组件，可以作为第三方Pod引入，由团队专人维护，而将业务模块作为LocalPod引入，可以方便调适、维护。<br>   至于具体实现，请参看文章末尾的Git项目。</p><p>   APP热切换，即在用户使用APP的过程中，出现某一个或者多个功能无法使用时，直接将该功能切换为React-Native的实现，或者H5的实现。前提是你有React-Native或者H5的备份可供下发，并且APP提供了所有正常功能的访问权限和方法。实现难度不高，但是成本巨大，除非著名大厂高日活APP，否则没有太大的实现必要。唯一一点实现难度，主要体现在各端数据格式的统一。打个比方，如果你的一个页面出现了Bug，并且该页面为了用户体验是使用原生编写，而该页面的必要初始化参数通过上一页面带入，此时你临时将页面切换成RN或者H5的实现，则你所传递的参数必定要被其数据结构所认可。所以，如果要实现APP的热切换，最好是各个功能、页面都只使用一个identity字段作为初始化的请求参数。至于具体实现，请参看文章末尾的Git项目。</p><p>   APP热更新，即无需发版，可做紧急Bug修复，和功能更新，在去年早些时候还有JSPatch等直接替换OC方法的方案来修复Bug，但是很不幸，现在已经被苹果所禁用。目前主流的方案是使用RN构筑View和实现业务逻辑，然后做有限的功能更新、和Bug修复，即通过RN对你APP所有原生功能做重新的排列组合，而修复一些不是由你的原生基础库所导致的Bug。目前主要有两种实现方案，一种是原生提供所有的基础功能和库，由RN实现页面和业务逻辑，需要从零开始开发；另一种是把RN作为一个组件，植入到现有原生APP中，并为RN提供主要原生页面和功能的访问支持，部分业务场景使用RN编写，这样实现有点类似于原生+H5，优点是性能高于H5，缺点是成本比H5更大。</p><p>   MVVM架构，即Model-View-ViewModel的分层架构方案，但凡对架构稍有了解的都不会觉得陌生。但在iOS项目的具体实现中ViewController绝对是必不可少的，所以我们在iOS项目中也不妨将它理解为Model-View-ViewModel-ViewController。Model、View这两层一个是实体模型，一个是显示和操作实体模型，在实际情况中Model中的数据和View中的数据往往存在差异，比如Model中有一个100，在View中却要显示为100元，在View中有一个选项菜单，选择的是具体菜单名，在Model中却要保存为菜单名+菜单ID，在Model中有一个详细信息的数组，在View中却要根据该信息的长度来控制列表上不同Cell的高度。在MVC架构中这些操作往往通过Controller来完成，但随着业务的增加Controller却又会变得无比的庞大，并且功能模块难以复用。如果将这些操作交给View让其自己去实现的话又会影响到View的可复用性。所以，为了解决这样的问题，ViewModel便应运而生了，ViewModel主要负责将业务和View关联起来，其本质是对数据流的操作，其关注点亦是数据流。即数据发生改变，ViewModel刷新视图，数据不同VIewModel提供不同的显示方案，用户操作视图，VIewModel更新数据；同一个视图，不同的ViewModel绑定不同的数据便做到了视图的复用；不同的ViewController使用同一个ViewModel便做到了功能的复用和解耦；你也可以将ViewModel理解为对业务的封装；所以ViewModel应当具有如下功能，数据的取得、数据的处理、视图的更新、数据的更新。即，ViewModel应当同时持有View和Model，或者ViewModel应当同时绑定View和Model。第三方开源模块Rective Cocoa，提供非常简便的绑定能力，个人推荐使用。至于具体实现，请参看文章末尾的Git项目。</p><p>  所谓架构，本质上是为了实现业务而对技术和人员的最有效排列组合。架构思想，则是从哲学的角度对经验的总结和归纳。如果你把代码看成有血有肉有思想的生命，那么，架构思想，即创造代码的哲学。你的代码，即你的思想。</p><p> <a href="https://blog.csdn.net/bsn1928/article/details/79436556" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;移动互联网发展10余年来，移动应用也谁之发生了翻天覆地的变化。从最初的几M小应用到现在动则几十上百M；从最初的一个人几个小功能，到现在的几十上百号人，比PC网页还要齐全还要强大的功能。在此过程中，原有的单Project，MVC架构，一个月一发版，已经远远不能满足当前移动应用的开发。于是乎，一个新的名词便诞生了–移动架构师。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>object-c编码规范</title>
    <link href="http://yoursite.com/2018/09/03/object-c%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2018/09/03/object-c编码规范/</id>
    <published>2018-09-03T03:02:54.000Z</published>
    <updated>2018-09-04T09:16:32.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>参考资料<a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-objc-styleguide/" target="_blank" rel="noopener">Google Objective-C Style Guide</a>   </p><p>   老大是一位重度代码洁癖的处女座，对代码规范非常苛刻，以前经常改动我的代码就为了他能看的顺眼。我记得曾在我提交的茫茫代码行中愣是指出某处的空格少了一个(囧)。<br>    其实我们花时间在某一方面，必然在某一方面有所收获，在代码上花时间，那么必然对技术有所提升，对泡妞上花时间，必然在泡妞上有更多的心得。。。  写博客也是因为老大的建议，即便写的不深，很是粗糙，但是经常写博客，花时间总结，可以记录自己的整个学习过程，也有助于自我思考，自我表达。&lt; 屁话太多了吧(路过人员的心声) &gt;      </p><pre><code>前沿：其实 每一门开发语言都有自己的代码规范，我们应该遵循它的代码规范去使用它，这就是这篇文章的来源。    </code></pre><a id="more"></a> <h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p> Objective-C是一个C语言的扩展语言，非常动态，非常的“面向对象”，它被设计成既拥有复杂的面向对象设计理念又可以轻松使用与阅读的语言，也是Mac OS X和iPhone开发的首选语言。</p><p>   Cocoa是Mac OS X的主要应用框架，提供迅速开发各种功能的Mac OS X应用的Objective-C类集合。</p><p>  Apple已经有一个很好也被广泛接受的Objective-C的编码规范，Google也有类似的C++编码规范，这份Objective-C编码规范很自然是Apple和Google的共同推荐的组合。所以，在阅读本规范前，确保你已经阅读了:</p><ul><li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/FrameworkImpl.html" target="_blank" rel="noopener">Apple’s Cocoa Coding Guidelines</a>     </li><li><p><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/" target="_blank" rel="noopener">Google’s Open Source C++ Style Guide</a> </p><blockquote><p>注意所有已在Google的C++编码规范里的禁用条款在Objective-C里也适用，除非本文档明确指出反对意见。 </p></blockquote></li></ul><p>本文档旨在描述可供可适用于所有Mac OS X代码的Objective-C(包括Objective-C++)编码规范和实践。规范中的许多条款已经改进也不断的被其他的项目和团队所证明其指导性。Google的相关开源项目都遵守此规范。</p><p>  Google已经发布了一份作为<a href="https://code.google.com/p/google-toolbox-for-mac/" target="_blank" rel="noopener">Google Toolbox for Mac project</a> (文档中简称为<code>GTM</code>)的组成部分的遵守本规范的开源代码。这份开放代码也是本文很好的例证(原文看不太懂－－Code meant to be shared across different projects is a good candidate to be included in this repository. )</p><p>  注意本文不是Objective-C的教学指南，我们假设读者已经了解语言。如果你是一个Objective-C的初学者或需要重温，请阅读<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html" target="_blank" rel="noopener">The Objective-C Programming Language</a> .</p><p>示例 </p><p> 人们说一个例子胜过千言万语，所以就让我们用例子来让你感受以下编码规范的风格，留间距，命名等等。</p><p> 下例是一份头文件，展示对@interface 声明正确的注释和留间距    </p><p>iOS代码 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  GTMFoo.h  </span></span><br><span class="line"><span class="comment">//  FooProject  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">//  Created by Greg Miller on 6/13/08.  </span></span><br><span class="line"><span class="comment">//  Copyright 2008 Google, Inc. All rights reserved.  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">``` objc</span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// A sample class demonstrating good Objective-C style. All interfaces,  </span></span><br><span class="line"><span class="comment">// categories, and protocols (read: all top-level declarations in a header)  </span></span><br><span class="line"><span class="comment">// MUST be commented. Comments must also be adjacent to the object they're  </span></span><br><span class="line"><span class="comment">// documenting.  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// (no blank line between this comment and the interface)  </span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GTMFoo</span> : <span class="title">NSObject</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">@private</span>  </span><br><span class="line">  <span class="built_in">NSString</span> *foo_;  </span><br><span class="line">  <span class="built_in">NSString</span> *bar_;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Returns an autoreleased instance of GMFoo. See -initWithString: for details  </span></span><br><span class="line"><span class="comment">// about the argument.  </span></span><br><span class="line">+ (<span class="keyword">id</span>)fooWithString:(<span class="built_in">NSString</span> *)string;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Designated initializer. |string| will be copied and assigned to |foo_|.  </span></span><br><span class="line">- (<span class="keyword">id</span>)initWithString:(<span class="built_in">NSString</span> *)string;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Gets and sets the string for |foo_|.  </span></span><br><span class="line">- (<span class="built_in">NSString</span> *)foo;  </span><br><span class="line">- (<span class="keyword">void</span>)setFoo:(<span class="built_in">NSString</span> *)newFoo;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Does some work on |blah| and returns YES if the work was completed  </span></span><br><span class="line"><span class="comment">// successfuly, and NO otherwise.  </span></span><br><span class="line">- (<span class="built_in">BOOL</span>)doWorkWithString:(<span class="built_in">NSString</span> *)blah;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p> <strong>注意：有朋友喜欢在全局变量命名时以_开头，其实我不建议，比如 NSString *_foo; 因为在阅读时很容易让人误会是property属性，我们应该尽量让阅读者可以方便的理解代码，而不是出现诱导因素。</strong></p><p>  下例是一份源文件，展示对接口的@implementation 的实现的正确注释和留间隔。它也包括了主要方法如getters,setters,init ,和dealloc 的相关实现。  </p><p>iOS代码    </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">//  GTMFoo.m  </span></span><br><span class="line"><span class="comment">//  FooProject  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">//  Created by Greg Miller on 6/13/08.  </span></span><br><span class="line"><span class="comment">//  Copyright 2008 Google, Inc. All rights reserved.  </span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"GTMFoo.h"</span>  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">GTMFoo</span>  </span></span><br><span class="line">  </span><br><span class="line">+ (<span class="keyword">id</span>)fooWithString:(<span class="built_in">NSString</span> *)string &#123;  </span><br><span class="line">  <span class="keyword">return</span> [[[<span class="keyword">self</span> alloc] initWithString:string] autorelease];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Must always override super's designated initializer.  </span></span><br><span class="line">- (<span class="keyword">id</span>)init &#123;  </span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">self</span> initWithString:<span class="literal">nil</span>];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">- (<span class="keyword">id</span>)initWithString:(<span class="built_in">NSString</span> *)string &#123;  </span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;  </span><br><span class="line">    foo_ = [string <span class="keyword">copy</span>];  </span><br><span class="line">    bar_ = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"hi %d"</span>, <span class="number">3</span>];  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;    </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;  </span><br><span class="line">  [foo_ release];  </span><br><span class="line">  [bar_ release];  </span><br><span class="line">  [<span class="keyword">super</span> dealloc];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">- (<span class="built_in">NSString</span> *)foo &#123;  </span><br><span class="line">  <span class="keyword">return</span> foo_;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">- (<span class="keyword">void</span>)setFoo:(<span class="built_in">NSString</span> *)newFoo &#123;  </span><br><span class="line">  [foo_ autorelease];  </span><br><span class="line">  foo_ = [newFoo <span class="keyword">copy</span>];    </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">- (<span class="built_in">BOOL</span>)doWorkWithString:(<span class="built_in">NSString</span> *)blah &#123;  </span><br><span class="line">  <span class="comment">// ...  </span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NO</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="间隔与格式化"><a href="#间隔与格式化" class="headerlink" title="间隔与格式化"></a>间隔与格式化</h2><h3 id="空格对tab键"><a href="#空格对tab键" class="headerlink" title="空格对tab键"></a>空格对tab键</h3><p>  仅使用空格，缩进两个。</p><p>  我们使用空格用于缩进，不要在编码时使用tab键，你应该设置你的编辑器将tab键转换成对应的空格。</p><h3 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h3><p>  代码中的每行文本不要超过80个字符的长度。</p><p>  尽管Objective-C正变得比C++更加繁冗，为了保持规范的互通性，我们还是决定保持80字符长度的限制。这比你想象中的更容易做到。</p><p>  我们知道本条款是有争议的，但已有此多的代码已经遵从了本条款，即使只是保持一致性也是一个充足的理由。</p><p>  你可以在Xcode里清楚地发现代码中的违规，设置  Xcode &gt; Preferences &gt; Text Editing &gt; Show page guide. (之后就可以在代码编辑区域里看到一条指定字符长度的指示线了)</p><h2 id="方法声明与定义"><a href="#方法声明与定义" class="headerlink" title="方法声明与定义"></a>方法声明与定义</h2><p>  留一个空格在 - 或 + 和 返回类型 之间，但参数列表里的参数之间不要留间隔。<br> 方法应该写成这样:    </p><p>iOS代码 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doSomethingWithString:(<span class="built_in">NSString</span> *)theString &#123;  </span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>星号前的空格是可选的，你可以根据原来的代码风格自行决定。</p><p>如果参数过多，推荐每个参数各占一行。使用多行的情况下，以参数前的冒号用于对齐:<br>        (很遗憾这里仅有Google Chrome浏览器能看出是冒号对齐的……)     </p><p>iOS代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doSomethingWith:(GTMFoo *)theFoo  </span><br><span class="line">                   rect:(<span class="built_in">NSRect</span>)theRect  </span><br><span class="line">               interval:(<span class="keyword">float</span>)theInterval &#123;  </span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当第一个关键字比其他的短时，后续行至少缩进四个空格。这样你可以让后续的关键字垂直对齐，而不是用冒号对齐:<br>iOS代码 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)short:(GTMFoo *)theFoo  </span><br><span class="line">    longKeyword:(NSRect)theRect  </span><br><span class="line">    evenLongerKeyword:(float)theInterval &#123;  </span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p> 方法调用的格式和方法声明时的格式时一致的，如果格式风格可选，遵从原有代码的风格。</p><p> 调用应该将所有参数写在一行:   </p><p>iOS代码 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[myObject doFooWith:arg1 name:arg2 error:arg3];</span><br></pre></td></tr></table></figure><p> 或者每个参数一行，用冒号对齐:(对齐效果如前说明)    </p><p>iOS代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[myObject doFooWith:arg1  </span><br><span class="line">               name:arg2  </span><br><span class="line">              error:arg3];</span><br></pre></td></tr></table></figure><p>注意:不要使用如下风格的写法</p><p>iOS代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[myObject doFooWith:arg1 name:arg2  <span class="comment">// some lines with &gt;1 arg  </span></span><br><span class="line">              error:arg3];  </span><br><span class="line">  </span><br><span class="line">[myObject doFooWith:arg1  </span><br><span class="line">               name:arg2 error:arg3];  </span><br><span class="line">  </span><br><span class="line">[myObject doFooWith:arg1  </span><br><span class="line">          name:arg2  <span class="comment">// aligning keywords instead of colons  </span></span><br><span class="line">          error:arg3];</span><br></pre></td></tr></table></figure><p>在声明和定义时，如果因为关键字长度使就算有四个空格在前仍然无法用冒号对齐，那么就让后续行缩进四个空格而不是冒号对齐:    </p><p>iOS代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[myObj short:arg1  </span><br><span class="line">    longKeyword:arg2  </span><br><span class="line">    evenLongerKeyword:arg3];</span><br></pre></td></tr></table></figure><h3 id="public-和-private"><a href="#public-和-private" class="headerlink" title="@public 和 @private"></a>@public 和 @private</h3><p>权限控制符@public 和@private 缩进一个空格.</p><p>类似C++的public,protected,private:</p><p>iOS代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">@public</span>  </span><br><span class="line">  ...  </span><br><span class="line"> <span class="keyword">@private</span>  </span><br><span class="line">  ...  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>每个异常标签的@ 和开括号({ )写在统一行，标签和开括号间隔一个空格，同样适用于@catch 语句。</p><p>如果你决定使用Objective-C的异常，那么就按如下格式，不过你最好先看看Avoid Throwing Exceptions(见后)条款，了解为何你不应使用异常。    </p><p>iOS代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@try &#123;  </span><br><span class="line">  foo();  </span><br><span class="line">&#125;  </span><br><span class="line">@catch (NSException *ex) &#123;  </span><br><span class="line">  bar(ex);  </span><br><span class="line">&#125;  </span><br><span class="line">@finally &#123;  </span><br><span class="line">  baz();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>命名规则对于维护代码来说是非常重要的。Objective-C方法名往往很长，不过这也有好处，读代码就像读散文(放屁),让很多注释变得毫无意义。</p><p>写纯Objective-C代码时，我们基本上遵守标准Objective-C naming rules ，这些规则和C++的规则有很大的不同。比如Google的C++代码规范推荐变量名构词之间使用下划线隔开，而本文档推荐驼峰法，也是Objective-C社区的标准。</p><p>所有类，类别, 方法，以及变量如包括缩写，则缩写部分使用全大写的缩写(Initialisms )形式。这遵守Apple的标准，比如URL,TIFF以及EXIF。</p><p>  当写Objective-C++代码时，情况就不是那么单一了。许多项目需要实现带一些Objective-C代码的跨平台的C++APIs或者连接后台的C++代码与前台的原生Cocoa代码.这会造成两种规范直接冲突。</p><p>  我们的解决方法是根据方法/函数风格来决定。如果在@implementation 块，就使用Objective-C的命名规则；如果在C++的方法实现块，就使用C++的命名规则。避免了实体变量和本地变量在一个函数内命名规则冲突的情况，而这种情况是对可读性的极大损害。</p><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><p>  文件名反映了它所包含的实现类的名字，遵从你所在项目的习惯。</p><p>  文件扩展名使用如下规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.h     C/C++/Objective-C header file</span><br><span class="line"> </span><br><span class="line">.m     Objective-C implementation file</span><br><span class="line"> </span><br><span class="line">.mm    Objective-C++ implementation file</span><br><span class="line"> </span><br><span class="line">.cc    Pure C++ implementation file</span><br><span class="line"> </span><br><span class="line">.c     C implementation file</span><br></pre></td></tr></table></figure><p>类别的文件名应该包含扩展类的名字，比如 <code>GTMNSString+Utils.h</code> or <code>GTMNSTextView+Autocomplete.h</code> </p><h3 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective-C++"></a>Objective-C++</h3><p>在一份源文件里，Objective-C++代码遵守当前方法/函数的风格</p><p>为了尽量减少不同命名风格间的冲突，使用当前方法的风格。如果在@implementation块，使用Objective-C命名规则，如果在C++类的函数实现块，使用C++命名规则。    </p><p>iOS代码 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: cross_platform_header.h  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> CrossPlatformAPI &#123;  </span><br><span class="line"> public:  </span><br><span class="line">  ...  </span><br><span class="line">  <span class="keyword">int</span> DoSomethingPlatformSpecific();  <span class="comment">// impl on each platform  </span></span><br><span class="line"> private:  </span><br><span class="line">  <span class="keyword">int</span> an_instance_var_;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: mac_implementation.mm  </span></span><br><span class="line"><span class="meta">#include <span class="meta-string">"cross_platform_header.h"</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// A typical Objective-C class, using Objective-C naming.  </span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyDelegate</span> : <span class="title">NSObject</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">@private</span>  </span><br><span class="line">  <span class="keyword">int</span> instanceVar_;  </span><br><span class="line">  CrossPlatformAPI* backEndObject_;  </span><br><span class="line">&#125;  </span><br><span class="line">- (<span class="keyword">void</span>)respondToSomething:(<span class="keyword">id</span>)something;  </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyDelegate</span>  </span></span><br><span class="line">- (<span class="keyword">void</span>)respondToSomething:(<span class="keyword">id</span>)something &#123;  </span><br><span class="line">  <span class="comment">// bridge from Cocoa through our C++ backend  </span></span><br><span class="line">  instanceVar_ = backEndObject-&gt;DoSomethingPlatformSpecific();  </span><br><span class="line">  <span class="built_in">NSString</span>* tempString = [<span class="built_in">NSString</span> stringWithInt:instanceVar_];  </span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, tempString);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// The platform-specific implementation of the C++ class, using  </span></span><br><span class="line"><span class="comment">// C++ naming.  </span></span><br><span class="line"><span class="keyword">int</span> CrossPlatformAPI::DoSomethingPlatformSpecific() &#123;  </span><br><span class="line">  <span class="built_in">NSString</span>* temp_string = [<span class="built_in">NSString</span> stringWithInt:an_instance_var_];  </span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, temp_string);  </span><br><span class="line">  <span class="keyword">return</span> [temp_string intValue];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类命名"><a href="#类命名" class="headerlink" title="类命名"></a>类命名</h3><p>   类名(不包括类别和协议名)应该用大写开头的驼峰命名法。</p><p>   在应用级别的代码里，尽量不要使用带前缀的类名。每个类都有相同的前缀不能提高可读性。不过如果是编写多个应用间的共享代码，前缀就是可接受并推荐的做法了(型如 GTMSendMessage )。（注：笔者建议加入前缀，因为这并不是单单为了提高可读性，也为了与引入进来的类做区分，所以合适的前缀是有必要的）</p><h3 id="类别命名"><a href="#类别命名" class="headerlink" title="类别命名"></a>类别命名</h3><p>   类别命名应该以两三个字符的分类前缀作为一个项目或通用的公用部分。类别名应该包含类的扩展。</p><p>   举个例子，如果我们想要创建一个基于NSString 的类别用于解析，我们应该把类别放到名字是GTMNSString+Parsing.h 的文件里，而类别本身的名字则是GTMStringParsingAdditions (是的，我们明白这个类别和其文件名字不匹配，但这个文件可能还包括其他用于解析相关的类别)。类别的方法应该都使用一个前缀(型如gtm_myCategoryMethodOnAString ),以防止Objective-C代码在单名空间里冲突。如果代码本来就不考虑共享或在不同的地址空间(address-space)，方法命名规则就没必要恪守了。</p><h3 id="Objective-C-方法命名"><a href="#Objective-C-方法命名" class="headerlink" title="Objective-C 方法命名"></a>Objective-C 方法命名</h3><p>   方法使用小写开头的驼峰法命名，每个参数都应该小写开头。</p><p>   方法名应该尽可能读起来像一句话，参数名就相对方法名的补充说明(比如convertPoing:fromRect: 或者 replaceCharactersInRange:withString: )，详见Apple’s Guide to Naming Methods </p><p>   存取(Accessor)方法应该一致的在”取(getting)”的时候直接用变量名而不是在签名加”get”,如下:    </p><p>iOS代码 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (id)getDelegate;  // AVOID  </span><br><span class="line">  </span><br><span class="line">- (id)delegate;    // GOOD</span><br></pre></td></tr></table></figure><p>   不过这仅针对Objective-C代码，C++代码仍然遵循自己的代码规范。</p><h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><p>   变量名使用小写开头的驼峰法，类成员变量名最后加一个下划线，比如:myLovalVariable, myInstanceVariable_ . 下面看不懂，原文Members used for KVO/KVC bindings may begin with a leading underscore iff use of Objective-C 2.0’s @property isn’t allowed. </p><h4 id="一般变量命名"><a href="#一般变量命名" class="headerlink" title="一般变量命名"></a>一般变量命名</h4><p>   不要使用匈牙利命名法去标记语法，比如静态类型或变量类型(int或pointer之类的)。使变量名尽量可以推测其用途属性具有描述性。别一心想着少打几个字母，让你的代码可以迅速被理解更加重要。比如:</p><p>iOS代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// AVOID  </span><br><span class="line">int w;  </span><br><span class="line">int nerr;  </span><br><span class="line">int nCompConns;  </span><br><span class="line">tix = [[NSMutableArray alloc] init];  </span><br><span class="line">obj = [someObject object];  </span><br><span class="line">p = [network port];  </span><br><span class="line">  </span><br><span class="line">// GOOD  </span><br><span class="line">int numErrors;  </span><br><span class="line">int numCompletedConnections;  </span><br><span class="line">tickets = [[NSMutableArray alloc] init];  </span><br><span class="line">userInfo = [someObject object];  </span><br><span class="line">port = [network port];</span><br></pre></td></tr></table></figure><h4 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h4><p>   实例变量用驼峰法命名并后缀下划线，就像 <code>usernameTextField_</code> . 然而我们允许一种例外就是用KVO/KVC去绑定一个实体变量而Objective-C 2.0 不能用(因为操作系统的限制)的情况，此时也可用前缀下划线的方法给每个变量命名。如果可以使用Objective-C 2.0，<code>@property</code> 和 <code>@synthesize</code> 提供了遵守命名规范的解决方法。</p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>   常量(预定义，枚举，局部常量等)使用小写k开头的驼峰法，比如 <code>kInvalidHandle</code> , <code>kWritePerm</code> . </p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>尽管写起来很痛苦，但注释仍然是使代码保持可读性的极端重要的方式。下面的条款描述了你应该注释什么以及在哪里做注释。但是记住:即使注释是如此重要，最好的代码还是自说明式的。起一个有意义的名字比起一个晦涩的名字然后在用注释去解释它好的多。</p><p>   当你写注释的时候，记住注释是写给读者，即下一个要理解你的代码并继续开发的人。”下一个”完全可能就是你自己。</p><p>   同样，所有C++编码规范的条款仍然适用，只是增加了一些条款，如下.</p><h3 id="文件注释"><a href="#文件注释" class="headerlink" title="文件注释"></a>文件注释</h3><p>   每个文件的开头都是版权声明，接着是文件内容的描述。</p><p>   法律声明和作者栏 </p><p>   每个文件都应该包含如下信息:</p><p>   一份版权声明(比如 Copyright 2008 Google Inc .)<br>   许可版本 为项目选择合适的许可版本(比如Apache 2.0, BSD, LGPL, GPL)</p><p>   如果你把别人写的文件做了相当大的改动，就把自己添加到作者栏去。这样别的开发者就方便联系这个文件的实际开发人员了。</p><h3 id="声明部分注释"><a href="#声明部分注释" class="headerlink" title="声明部分注释"></a>声明部分注释</h3><p>   每个接口，类别，协议都必须伴随描述它的用途以及如何整合的注释。</p><p>iOS代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A delegate for NSApplication to handle notifications about app  </span></span><br><span class="line"><span class="comment">// launch and shutdown. Owned by the main app controller.  </span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyAppDelegate</span> : <span class="title">NSObject</span> </span>&#123;  </span><br><span class="line">  ...  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>   如果已经在文件的顶部写了接口的详细描述，你也可以简单的写如”见文件顶部的完整描述”，当然要有这些注释的顺序安排。</p><p>   此外public接口的每个方法都应该添加关于函数，参数，返回值以及副作用的注释。       </p><p>   文档默认类都是同步的，如果类实例可以多线程访问，必须要加上额外的说明。     </p><h3 id="实现部分注释"><a href="#实现部分注释" class="headerlink" title="实现部分注释"></a>实现部分注释</h3><p>  使用竖线引用变量或符号，而不是用引号。    </p><p>   这可以减少歧义，特别是当符号本身就是个常见的词时，可能使句子显得支离破碎，比如符号是”count”:    </p><p>iOS代码     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// Sometimes we need |count| to be less than zero.</span><br></pre></td></tr></table></figure><p>   或者是对于那些已经存在引号的情况     </p><p>iOS代码    </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remember to call |StringWithoutSpaces("foo bar baz")|</span></span><br></pre></td></tr></table></figure><h3 id="对象所有权"><a href="#对象所有权" class="headerlink" title="对象所有权"></a>对象所有权</h3><p>   使指针所有权的模型尽可能清晰，当它属于Objective-C的使用惯例时(不懂，原文是Make the pointer ownership model as explicit as possible when it falls outside the most common Objective-C usage idioms. )</p><p>   实例变量指向NSObject派生类的对象时都假定是retain的，如果它们不是retain的则需要加上”weak”的文档说明。对应的，实体变量如果标记上IBOutlets则是假定为非retain的，若实际上用了retain，就必须加上”strong”的说明。</p><p>   当实例变量指向核心库，C++或其他非Objective-C对象时，必须永远用注释说明是strong还是weak的。必须注意为了支持Objective-C对象里的自动化C++对象的封装是默认被关闭的的(这句话有歧义，原文是Be mindful that support for automatic C++ objects encapsulated in Objective-C objects is disabled by default)，这里 有说明。</p><p>  strong和weak说明的文档示例:</p><p>  iOS代码 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyDelegate</span> : <span class="title">NSObject</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">@private</span>  </span><br><span class="line">  <span class="keyword">IBOutlet</span> <span class="built_in">NSButton</span>* okButton_;  <span class="comment">// normal NSControl  </span></span><br><span class="line">  <span class="keyword">IBOutlet</span> <span class="built_in">NSMenu</span>* myContextMenu_;  <span class="comment">// manually-loaded menu (strong)  </span></span><br><span class="line">  </span><br><span class="line">  AnObjcObject* doohickey_;  <span class="comment">// my doohickey  </span></span><br><span class="line">  MyController* controller_;  <span class="comment">// so we can send msgs back (weak, owns me)  </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// non-NSObject pointers...  </span></span><br><span class="line">  CWackyCPPClass* wacky_;  <span class="comment">// some cross-platform object (strong)  </span></span><br><span class="line">  <span class="built_in">CFDictionaryRef</span>* dict_;  <span class="comment">// (strong)  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strong</span><br><span class="line">对象会在类中retain </span><br><span class="line">weak</span><br><span class="line">对象不会在类中retain   (比如一个委托)</span><br></pre></td></tr></table></figure><h2 id="Cocoa和Objective-C特性"><a href="#Cocoa和Objective-C特性" class="headerlink" title="Cocoa和Objective-C特性"></a>Cocoa和Objective-C特性</h2><h3 id="成员变量应该定义为-private"><a href="#成员变量应该定义为-private" class="headerlink" title="成员变量应该定义为@private"></a>成员变量应该定义为@private</h3><p>iOS代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface MyClass : NSObject &#123;  </span><br><span class="line"> @private  </span><br><span class="line">  id myInstanceVariable_;  </span><br><span class="line">&#125;  </span><br><span class="line">// public accessors, setter takes ownership  </span><br><span class="line">- (id)myInstanceVariable;  </span><br><span class="line">- (void)setMyInstanceVariable:(id)theVar;  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="明确指定初始化函数"><a href="#明确指定初始化函数" class="headerlink" title="明确指定初始化函数"></a>明确指定初始化函数</h3><ul><li><p>注释并说明指定的初始化。</p><p>明确指定初始化对想要子类化你的类的时候时很重要的。那样，子类化时只需要做一个或多个初始化去保证初值即可。这也有助于在以后调试你的类时明了初始化流程。</p></li></ul><h3 id="重写指定初始化函数"><a href="#重写指定初始化函数" class="headerlink" title="重写指定初始化函数"></a>重写指定初始化函数</h3><p>   当重写一个子类并需要init… 方法，注意要重写父类的指定初始化方法。</p><p>   如果你没有正确重写父类的指定初始化方法，你的初始化方法可能不会被调用，这会导致很多微妙而难以排除的错误。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>   没必要在初始化方法里把变量初始化为0 或者nil ,这是多余的。</p><p>   所有新分配内存的对象内容都初始化为0(除了 isa )，所以不要在init 方法里做无谓的重初始化为0的操作。</p><h3 id="保持公有API简明"><a href="#保持公有API简明" class="headerlink" title="保持公有API简明"></a>保持公有API简明</h3><p>   保持你的类简单，避免”厨房水槽”似的APIs，如果一个方法没必要公开就不要公开。使用私有类别保证公开头文件的简洁。</p><p>   和C++不同，Objective-C无法区分公有私有方法，因为它全是公有的。因此，除非就是为了让用户调用所设计，不要把其他的方法放到公有API里。这样可以减少不期调用的可能性。这还包括重写父类的方法。对于那些内部实现的方法，在实现文件里使用类别而不是将方法定义在公有头文件里。</p><p>iOS代码    </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GTMFoo.m  </span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"GTMFoo.h"</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GTMFoo</span> (<span class="title">PrivateDelegateHandling</span>)  </span></span><br><span class="line">- (<span class="built_in">NSString</span> *)doSomethingWithDelegate;  <span class="comment">// Declare private method  </span></span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">GTMFoo</span>(<span class="title">PrivateDelegateHandling</span>)  </span></span><br><span class="line">...  </span><br><span class="line">- (<span class="built_in">NSString</span> *)doSomethingWithDelegate &#123;  </span><br><span class="line">  <span class="comment">// Implement this method  </span></span><br><span class="line">&#125;  </span><br><span class="line">...  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>   在Objective-C 2.0之前，如果你在私有@interface 里声明了一个方法，但忘记在主@implementation 文件里实现了，编译器不会有什么反应(这是因为你没有在不同的类别里实现这些私有方法)。解决方案在是把函数写到@implementation 里并指明类别。</p><p>   如果你用的是 Objective-C 2.0，你应该使用类扩展 而不是声明私有类别，如下:</p><p>iOS代码    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface GMFoo () &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>   如此就可以保证函数做了声明但没有在@implememtation 里实现的时候编译器会警报。</p><p>   再者，”private”方法并不是真正的private，你可能会无意间重写了父类的一个”private”方法，这回导致bug的涌现。总的来说，私有方法应该使用更特别的名字以阻止子类化时并不期望的重写。</p><p>   最后，对于绝大多数类而言，Objective-C的类别是将@implelemtation做可理解的分块，添加新的应用级别的功能的最佳途径。比如，与其在你的项目里随便找个类来实现字符串的”中间截断”功能，不如创建一个新的NSString 类别。</p><h2 id="import-和-include"><a href="#import-和-include" class="headerlink" title="#import 和 #include"></a>#import 和 #include</h2><p>   用 #import 导入Objective-C 或 Objective-C++头 文件，用 #include 导入C或C++头 文件</p><h3 id="根据头文件的语言去选择合适的导入方式。"><a href="#根据头文件的语言去选择合适的导入方式。" class="headerlink" title="根据头文件的语言去选择合适的导入方式。"></a>根据头文件的语言去选择合适的导入方式。</h3><p>   当导入的头文件使用Objective-C或Objective-C++语言时，使用#import .<br>   当导入标准C或 C++头文件时，使用#include . 头文件应该使用自己的#define 重加载保护</p><p>   有些Objective-C头文件没有#define 重加载保护，所以只应该用#import 导入。因此Objective-C头文件只应该被Objective-C源文件或其他的Objective-C头文件所导入。这种情况下全部使用#import 是合适的。</p><p>   标准C和C++头文件不包含任何Objective-C元素都可以被一般的C或C++文件导入。因为标准C和C++里根本没有#import ，所以也只能用#include 导入。在Objective-C代码中使用#include 一致的导入这些头文件。</p><p>   本条款有助于跨平台项目的无意错误。一位Mac开发者引入一份新C或C++头文件时可能会忘记添加#define重加载保护，因为在Mac上用#import 导入文件不会引发问题，但在别的使用#include 的平台就可能出问题。在所有平台一致的使用#include 意味着要么全部成功要么全部失败，避免了那种另人沮丧的一些平台上可以运作而另一些不行的情况。</p><p> iOS代码 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#include <span class="meta-string">&lt;CoreFoundation/CoreFoundation.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"GTMFoo.h"</span>  </span></span><br><span class="line"><span class="meta">#include <span class="meta-string">"base/basictypes.h"</span></span></span><br></pre></td></tr></table></figure><h3 id="使用框架根"><a href="#使用框架根" class="headerlink" title="使用框架根"></a>使用框架根</h3><p>   导入框架根的头文件而不是分别导入框架头文件</p><p>   看起来从Cocoa或Foundation这些框架里导入个别的文件很不错，但实际上你直接导入框架根头文件效率更高。框架根已经被预编译故可更快的被加载。还有，记住用#import 指令而不是#include 导入Objective-C的框架。</p><p>iOS代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span>     // good  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/NSArray.h&gt;</span>        // avoid  </span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/NSString.h&gt;</span>  </span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">### 构建时即设定autorelease ###</span></span><br><span class="line"></span><br><span class="line">   当创建新的临时对象时，在同一行代码里就设定autorelease而不是写到这个方法的后面几行去</span><br><span class="line"></span><br><span class="line">   即使这样可能会造成一些轻微的延迟，但这样避免了谁不小心把release 去掉，或在release 之前就<span class="keyword">return</span> 而造成的内存泄露，如下</span><br><span class="line">   </span><br><span class="line">iOS代码    </span><br><span class="line"></span><br><span class="line">``` objc </span><br><span class="line"><span class="comment">// AVOID (unless you have a compelling performance reason)  </span></span><br><span class="line">MyController* controller = [[MyController alloc] init];  </span><br><span class="line"><span class="comment">// ... code here that might return ...  </span></span><br><span class="line">[controller release];  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// BETTER  </span></span><br><span class="line">MyController* controller = [[[MyController alloc] init] autorelease];</span><br></pre></td></tr></table></figure><p>   优先autorelease而非retain </p><h3 id="对象赋值时尽量采用autorelease-而不是retian-模式。"><a href="#对象赋值时尽量采用autorelease-而不是retian-模式。" class="headerlink" title="对象赋值时尽量采用autorelease 而不是retian 模式。"></a>对象赋值时尽量采用autorelease 而不是retian 模式。</h3><p>   当把一个新创建的对象赋予一个变量的时候，第一件要做的事情就是先释放原来变量指向的对象以防止内存泄露。这里也有很多”正确的”方法去做这件事。我们选择autorelease时因为它更不倾向于出错。小心在密集的循环里可能会很快填满autorelease池，而且它也确实会降低效率，但权衡下来还是可以接受的。</p><p>iOS代码  </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setFoo:(GMFoo *)aFoo &#123;  </span><br><span class="line">  [foo_ autorelease];  <span class="comment">// Won't dealloc if |foo_| == |aFoo|  </span></span><br><span class="line">  foo_ = [aFoo <span class="keyword">retain</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   以声明时的顺序dealloc处理实例变量 </p><p>   dealloc 应该用在@interface 声明时同样的顺序处理实例变量，这也有助于评审者鉴别。</p><p>   代码评审者检查或修正dealloc 的实现要确保所有retain 的实例变量都获得了释放。</p><p>   为了简化评审dealloc ，将释放retain 的实例变量代码保持和@interface 里声明的顺序一致。如果dealloc 调用了其他方法去释放实例变量，添加注释说明那些实例变量被这些方法所处理了。</p><h3 id="Setters-copy-NSStrings"><a href="#Setters-copy-NSStrings" class="headerlink" title="Setters copy NSStrings"></a>Setters copy NSStrings</h3><p>   在NSString 上调用Setters 方法时，永远使用copy 方式。(不太懂，原文是Setters taking an NSString, should always copy  the string it accepts. )</p><p>   永远不要retain 一个字符串，这可以防止调用者在你不知到的情况下修改了字符串。不要以为你可以改变NSString 的值，只有NSMutableString 才能做到。</p><p>iOS代码 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setFoo:(<span class="built_in">NSString</span> *)aFoo &#123;  </span><br><span class="line">  [foo_ autorelease];  </span><br><span class="line">  foo_ = [aFoo <span class="keyword">copy</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 避免抛出异常 </p><p>   不要 @throw Objective-C的异常，不过你还是要做好准备捕获第三方以及系统调用抛出的异常。</p><p>   我们的确在编译时加入了-fobjc-exceptions 指令(主要是为了获得@synchronized )，但我们并不@throw 。当然在使用第三方库的时候是允许使用@try，@catch, 以及@finally 的。如果你确实使用了，请务必明确到文档中哪个方向你想抛出什么异常。</p><p>   除非你写的代码想要泡在MacOS 10.2或更之前，否则不要使用NS_DURING, NS_HANDLER, NS_ENDHANDLER, NS_VALUERETURN and NS_VOIDRETURN 这些宏。</p><p>   另外你要小心当写Objective-C++代码的时候，如果抛出Objective-C异常，那些栈上的对象不会被清理。示例:</p><p>iOS代码 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> exceptiontest &#123;  </span><br><span class="line"> public:  </span><br><span class="line">  exceptiontest() &#123; <span class="built_in">NSLog</span>(<span class="string">@"Created"</span>); &#125;  </span><br><span class="line">  ~exceptiontest() &#123; <span class="built_in">NSLog</span>(<span class="string">@"Destroyed"</span>); &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">void</span> foo() &#123;  </span><br><span class="line">  exceptiontest a;  </span><br><span class="line">  <span class="built_in">NSException</span> *exception = [<span class="built_in">NSException</span> exceptionWithName:<span class="string">@"foo"</span>  </span><br><span class="line">                                                   reason:<span class="string">@"bar"</span>  </span><br><span class="line">                                                 userInfo:<span class="literal">nil</span>];  </span><br><span class="line">  <span class="keyword">@throw</span> exception;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) &#123;  </span><br><span class="line">  GMAutoreleasePool pool;  </span><br><span class="line">  <span class="keyword">@try</span> &#123;  </span><br><span class="line">    foo();  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">@catch</span>(<span class="built_in">NSException</span> *ex) &#123;  </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"exception raised"</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   将会有如下输出:    </p><p>   iOS代码    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2006-09-28 12:34:29.244 exceptiontest[23661] Created         </span><br><span class="line">2006-09-28 12:34:29.244 exceptiontest[23661] exception raised</span><br></pre></td></tr></table></figure><p>   注意这里的析构函数永远没有机会被调用。这是在你想用栈上的智能指针比如shared_ptr,linked_ptr ,还有STL对象的时候不得不关注的一个核心问题。我们不得不痛心地说，如果你一定要在Objective-C++代码里抛出异常，那就请一定使用C++的异常。永远不要重新抛出一个Objective-C的异常，也不允许在异常块即@try,@catch,@finally 里生成栈上的 C++对象(比如std::string, std::vector 等).</p><h3 id="nil检查"><a href="#nil检查" class="headerlink" title="nil检查"></a>nil检查</h3><p>   仅在校验逻辑流程时做nil检查。</p><p>   使用nil检查不是为了防止程序崩溃，而是校验逻辑流程。向一个空对象发送一条消息是由Objective-C运行时处理的。方法没有返回结果，你也可以安心走下去.然而这里也有一种，依执行架构不同而返回尺寸和OS X的版本(这段不懂)(见)Apple’s documentation for specifics 。</p><p>   注意这里和C/C++的空指针检查是完全不同的，在那些环境里，并不处理空指针情况并可能导致你的应用程序崩溃。不过你仍要自己确保提领的指针不为空。</p><h3 id="BOOL类型陷阱"><a href="#BOOL类型陷阱" class="headerlink" title="BOOL类型陷阱"></a>BOOL类型陷阱</h3><p>  整形的转换为 BOOL 型的时候要小心。不要直接和YES做比较。</p><p>   BOOL 在Objective-C里被定义为unsigned char，这意味着它不仅仅只有YES (1)和NO (0)两个值。不要直接把整形强制转换为BOOL 型。常见的错误发生在把数组大小，指针的值或者逻辑位运算的结果赋值到BOOL型中，而这样就导致BOOL 值的仅取决于之前整形值的最后一个字节，有可能出现整形值不为0但被转为NO的情况。应此把整形转为BOOL型的时候请使用ternery操作符，保证返回YES 或NO 值。</p><p>   在BOOL，_BOOL 以及bool (见C++ Std 4.7.4, 4.12以及C99 Std 6.3.1.2)之间可以安全的交换值或转型。但BOOL 和Boolean 之间不可，所以对待Boolean 就像上面讲的整形一样就可以了。在Objective-C函数签名里仅使用BOOL 。</p><p>   对BOOL值使用逻辑运算(&amp;&amp;, ||, ! )都是有效的，返回值也可以安全的转为BOOL型而不需要ternery操作符。</p><p>iOS代码 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// AVOID  </span><br><span class="line">- (BOOL)isBold &#123;  </span><br><span class="line">  return [self fontTraits] &amp; NSFontBoldTrait;  </span><br><span class="line">&#125;  </span><br><span class="line">- (BOOL)isValid &#123;  </span><br><span class="line">  return [self stringValue];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// GOOD  </span><br><span class="line">- (BOOL)isBold &#123;  </span><br><span class="line">  return ([self fontTraits] &amp; NSFontBoldTrait) ? YES : NO;  </span><br><span class="line">&#125;  </span><br><span class="line">- (BOOL)isValid &#123;  </span><br><span class="line">  return [self stringValue] != nil;  </span><br><span class="line">&#125;  </span><br><span class="line">- (BOOL)isEnabled &#123;  </span><br><span class="line">  return [self isValid] &amp;&amp; [self isBold];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   还有，不要把 BOOL 型变量直接与 YES 比较。这样不仅对于精通C的人很有难度，而且此条款的第一点也说明了这样做未必能得到你想要的结果。</p><p>iOS代码 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// AVOID  </span><br><span class="line">BOOL great = [foo isGreat];  </span><br><span class="line">if (great == YES)  </span><br><span class="line">  // ...be great!  </span><br><span class="line">  </span><br><span class="line">// GOOD  </span><br><span class="line">BOOL great = [foo isGreat];  </span><br><span class="line">if (great)  </span><br><span class="line">  // ...be great!</span><br></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>   属性总的来说是遵循如下告诫的: 属性是Objective-C 2.0的特性，所以只能跑在iPhone以及MacOS X 10.5(leopard)或更高的版本。点表示法访问属性是不被允许的。</p><h3 id="命名-1"><a href="#命名-1" class="headerlink" title="命名"></a>命名</h3><p>   一个有属性关联实例变量都要在后面加下划线，而该属性的名称就是实例变量不加尾部的下划线的名字。</p><p>   使用@synthesize 标识以正确的重命名属性。</p><p>iOS代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">@private</span>  </span><br><span class="line">  <span class="built_in">NSString</span> *name_;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;  </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span>  </span></span><br><span class="line"><span class="keyword">@synthesize</span> name = name_;  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p>   在类接口声明里，属性的声明必须紧挨着实例变量块声明之后。类定义里，属性的定义必须紧挨着@implementation块。缩进和@interface或@implementation是一样的。    </p><p>iOS代码 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">@private</span>  </span><br><span class="line">  <span class="built_in">NSString</span> *name_;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;  </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span>  </span></span><br><span class="line"><span class="keyword">@synthesize</span> name = name_;  </span><br><span class="line">- (<span class="keyword">id</span>)init &#123;  </span><br><span class="line">...  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="对字符串使用拷贝特性"><a href="#对字符串使用拷贝特性" class="headerlink" title="对字符串使用拷贝特性"></a>对字符串使用拷贝特性</h3><p>   NSString 类型的属性应该永远声明为带有copy attribute </p><p>   这点是因为NSString 的setters 永远使用copy 而不是retain 。</p><p>   永远不要对CFType属性使用synthesize </p><p>   CFType类型应该永远遵守@dynamic的实现规则。</p><p>   因为CFType类型不能有reatin 属性特性，开发者必须自己维护。(下面不懂，原文In the rare case that you do actually want assignment it is better to make that completely clear by actually implementing the setter and getter and commenting why that is the case. )</p><p>  列出所有的实现指令 </p><p>  为所有属性使用实现指令，即使默认是@dynamic</p><p>  尽管@dynamic是默认的，显式的列出所有属性实现指令还是让类中的每个属性更加清楚。</p><p>iOS代码 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AVOID  </span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span>  </span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name;  </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span>  </span></span><br><span class="line">.  </span><br><span class="line">.  </span><br><span class="line">.  </span><br><span class="line">- (<span class="built_in">NSString</span>*)name &#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="string">@"foo"</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// GOOD  </span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span>  </span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name;  </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span>  </span></span><br><span class="line"><span class="keyword">@dynamic</span> name;  </span><br><span class="line">.  </span><br><span class="line">.  </span><br><span class="line">.  </span><br><span class="line">- (<span class="built_in">NSString</span>*)name &#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="string">@"foo"</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>   属性使用过犹不及。默认情况，所有的synthesized setters 以及 getters  默认都是原子性的，显然所有的get，set方法都过度使用了同步方法。所以除非你确实需要原子性，否则都将你的属性声明为nonatomic </p><h3 id="点表示法"><a href="#点表示法" class="headerlink" title="点表示法"></a>点表示法</h3><p>   我们禁止使用点表示法是基于如下理由的:      </p><ul><li>点表示法不过是标准函数调用的语法糖，它的可读性很有争议。也不过就是换个形式调用函数而已。      </li><li>它使得提领操作含糊不请.首先看: [foo setBar:1] 很清楚你就明白这是Objective-C对象上的操作。那么看 foo.bar = 1 就不太清楚到底是对Objective-C的对象还是结构体/公用体/C++类进行操作了。      </li><li>它使得函数调用看起来就像getters         </li></ul><p>iOS代码 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *upperCase = <span class="string">@"foo"</span>.uppercaseString;</span><br></pre></td></tr></table></figure><p>   不仅使人困惑，也很难在代码审核的时候检查出来。     </p><ul><li><p>它隐藏了函数调用</p><p>iOS代码 </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar.value += 10;</span><br></pre></td></tr></table></figure><p> 这实际上做了两次函数调用(一次get一次set)，而如果你的类很复杂的话，你发现一大堆事都在幕后做完了。</p><h2 id="Cocoa模式"><a href="#Cocoa模式" class="headerlink" title="Cocoa模式"></a>Cocoa模式</h2><h3 id="委托模式"><a href="#委托模式" class="headerlink" title="委托模式"></a>委托模式</h3><p> 委托对象不应该是retain </p><p> 一个实现委托模式的类应该:    </p><ol><li>实例变量命名为delegate_ 以显示这是个委托       </li><li>因此，访存方法名就为delegate 和setDelegate      </li><li>delegate_ 变量不能设为retain       </li></ol><h3 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h3><ul><li><p>将模型与视图分离，将控制器从视图和模型中分离，回调APIs使用@protocol </p></li><li><p>模型与视图分离: 不要对模型或数据源的表现形式做任何假设。保持数据与表现层的接口的抽象性。模型不对视图有任何了解(一个好的实践就是询问你自己是否能对数据有多个不同形式的表现方法)</p></li><li><p>控制器从视图和模型中分离: 不要把”业务逻辑”放到视图相关的类；这会导致代码可复用性下降。让控制器的类承管代码，但不要对表现形式做太多假设。</p></li><li><p>用@protocol 定义回调APIs: 如果不是所有的方法都必须实现就使用@optional (例外:在Objecitve-C 1.0的时候，@optional 还不可用，所以用类别去定义一个”非标准协议(informal protocol)”)</p></li></ul><p>最后的最后，这篇文章会尽量的完善，不停的矫正，以便让自己形成一个良好的代码习惯</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;总览&quot;&gt;&lt;a href=&quot;#总览&quot; class=&quot;headerlink&quot; title=&quot;总览&quot;&gt;&lt;/a&gt;总览&lt;/h1&gt;&lt;p&gt;参考资料&lt;a href=&quot;https://zh-google-styleguide.readthedocs.io/en/latest/google-objc-styleguide/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google Objective-C Style Guide&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;   老大是一位重度代码洁癖的处女座，对代码规范非常苛刻，以前经常改动我的代码就为了他能看的顺眼。我记得曾在我提交的茫茫代码行中愣是指出某处的空格少了一个(囧)。&lt;br&gt;    其实我们花时间在某一方面，必然在某一方面有所收获，在代码上花时间，那么必然对技术有所提升，对泡妞上花时间，必然在泡妞上有更多的心得。。。  写博客也是因为老大的建议，即便写的不深，很是粗糙，但是经常写博客，花时间总结，可以记录自己的整个学习过程，也有助于自我思考，自我表达。&amp;lt; 屁话太多了吧(路过人员的心声) &amp;gt;      &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;前沿：其实 每一门开发语言都有自己的代码规范，我们应该遵循它的代码规范去使用它，这就是这篇文章的来源。    
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>c函数实用函数</title>
    <link href="http://yoursite.com/2018/09/03/c%E5%87%BD%E6%95%B0%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/09/03/c函数实用函数/</id>
    <published>2018-09-03T02:56:00.000Z</published>
    <updated>2018-09-18T06:59:52.961Z</updated>
    
    <content type="html"><![CDATA[<p>我有一个疑问，Class类对象是在main函数之前的dyld阶段加载进内存的，那它是在内存的静态区还是堆区存储着？ </p><p>好了，疑问先放着，我们进入正题，在iOS开发中我们经常遇到 浮点数的 四舍五入、进位、摸位 方法。</p><p>我们可以通过速查表查看所有的C函数，<code>https://baike.baidu.com/item/Objective-C函数速查实例手册?fr=aladdin</code><br><a id="more"></a><br>这里列出常用的几个函数：<br>1，四舍五入法<br>    <code>float numberToRound</code>;</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">int result;</span><br><span class="line"></span><br><span class="line">numberToRound = 5.61;</span><br><span class="line"></span><br><span class="line">result = (int)roundf(numberToRound);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;roundf(%.2f) = %d&quot;, numberToRound, result);</span><br><span class="line"></span><br><span class="line">// 输出 roundf(5.61) = 6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">numberToRound = 5.41;</span><br><span class="line"></span><br><span class="line">result = (int)roundf(numberToRound);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;roundf(%.2f) = %d&quot;, numberToRound, result);</span><br><span class="line"></span><br><span class="line">// 输出 roundf(5.41) = 5</span><br></pre></td></tr></table></figure><p>2、进位方法<br>    float numberToRound;<br>    <code>int result</code>;    </p><pre><code>numberToRound = 5.61;result = (int)ceilf(numberToRound);NSLog(@&quot;ceilf(%.2f) = %d&quot;, numberToRound, result);// 输出 ceilf(5.61) = 6numberToRound = 5.41;result = (int)ceilf(numberToRound);NSLog(@&quot;ceilf(%.2f) = %d&quot;, numberToRound, result);// 输出 ceilf(5.41) = 6</code></pre><p>3、摸位方法<br>    <code>float numberToRound</code>;</p><pre><code>int result;numberToRound = 5.61;result = (int)floorf(numberToRound);NSLog(@&quot;floorf(%.2f) = %d&quot;, numberToRound, result);// 输出 floorf(5.61) = 5numberToRound = 5.41;result = (int)floorf(numberToRound);NSLog(@&quot;floorf(%.2f) = %d&quot;, numberToRound, result);// 输出 floorf(5.41) = 5</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我有一个疑问，Class类对象是在main函数之前的dyld阶段加载进内存的，那它是在内存的静态区还是堆区存储着？ &lt;/p&gt;
&lt;p&gt;好了，疑问先放着，我们进入正题，在iOS开发中我们经常遇到 浮点数的 四舍五入、进位、摸位 方法。&lt;/p&gt;
&lt;p&gt;我们可以通过速查表查看所有的C函数，&lt;code&gt;https://baike.baidu.com/item/Objective-C函数速查实例手册?fr=aladdin&lt;/code&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Hexo-搭建博客(二)</title>
    <link href="http://yoursite.com/2018/08/30/Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2-%E4%BA%8C/"/>
    <id>http://yoursite.com/2018/08/30/Hexo-搭建博客-二/</id>
    <published>2018-08-30T06:23:52.000Z</published>
    <updated>2018-09-04T03:28:34.709Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>创建 github.io</title>
    <link href="http://yoursite.com/2018/08/30/%E5%88%9B%E5%BB%BA-github-io/"/>
    <id>http://yoursite.com/2018/08/30/创建-github-io/</id>
    <published>2018-08-30T06:09:26.000Z</published>
    <updated>2018-09-04T03:28:34.713Z</updated>
    
    <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ol><li><p>注册<a href="https://github.com/" target="_blank" rel="noopener">GitHUb</a>账号    </p></li><li><p>创建新的项目<br><img src="/2018/08/30/创建-github-io/1.jpeg" alt="">    </p></li><li>按格式输入项目名称<br><img src="/2018/08/30/创建-github-io/2.jpeg" alt="">     </li><li>点击设置 创建一个page   </li></ol><p><img src="/2018/08/30/创建-github-io/3.jpeg" alt=""><br><img src="/2018/08/30/创建-github-io/4.jpeg" alt=""><br><img src="/2018/08/30/创建-github-io/5.jpeg" alt="">     </p><ol start="5"><li>随意选择一个主题     </li></ol><p><img src="/2018/08/30/创建-github-io/6.jpeg" alt="">      </p><ol start="6"><li>查看效果，输入<code>用户名.github.io</code></li></ol><p><img src="/2018/08/30/创建-github-io/7.jpeg" alt="">     </p>]]></content>
    
    <summary type="html">
    
      利用免费的同性交流平台，免费的搭建一个博客
    
    </summary>
    
      <category term="技能" scheme="http://yoursite.com/categories/%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 搭建博客（一）</title>
    <link href="http://yoursite.com/2018/08/30/Hexo-%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/08/30/Hexo-搭建博客/</id>
    <published>2018-08-30T05:51:03.000Z</published>
    <updated>2018-09-14T09:53:07.815Z</updated>
    
    <content type="html"><![CDATA[<h2 id="搭建环境"><a href="#搭建环境" class="headerlink" title="搭建环境"></a>搭建环境</h2><ol><li><p>安装安装环境:<code>homebrew</code>—&gt;<code>nodejs</code>—&gt;<code>hexo</code>,确保我们电脑安装了 ruby ,因为 homebrew 安装时依赖ruby的,使用<code>ruby --version</code>查看ruby版本    </p><ul><li>安装 <code>homebrew</code><br><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code> </li><li>安装 nodejs<br><code>brew install node</code></li><li>安装git(Xcode自带Git 可以忽略)</li><li>安装 hexo<br><code>sudo npm install -g hexo</code> 如果安装失败 就使用 <code>sudo  npm install -g hexo-cli</code></li></ul></li><li><p>创建文件夹，下面创建一个blog文件夹并在目录下初始化 hexo    </p></li></ol><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir blog</span><br><span class="line">cd blog</span><br><span class="line">hexo i <span class="comment">// init 的缩写</span></span><br></pre></td></tr></table></figure><p>此时blog文件下出现了很多文件和文件夹，如下图所示:   </p><a id="more"></a> <p><img src="/2018/08/30/Hexo-搭建博客/1.png" alt="目录"><br>然后我们可以试试创建一套静态网页</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo g <span class="comment">/** generate 的缩写 生成一套静态网页 **/</span></span><br><span class="line">hexo s <span class="comment">/** server 的缩写 在服务器上运行 **/</span></span><br></pre></td></tr></table></figure><p>在浏览器上运行 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 就能看到我们的 Hello World 了</p><h2 id="撰写博客"><a href="#撰写博客" class="headerlink" title="撰写博客"></a>撰写博客</h2><p>在这个目录下，输入命令:<br><code>hexo n post &quot;我的第一篇博客&quot; /* new 的缩写 创建新的 .md 文件 */</code>   </p><p>随后终端会出现如下消息:<br><code>INFO  Created: ~/blog/source/_posts/我的第一篇博客.md</code>    </p><p>这证明创建文章成功，“我的第一篇博客”这个md文件会创建在 <code>source/_posts/</code> 的文件下。该md文件在自动生成时会带有一些属性：    </p><p>title:     定义了博文的标题</p><p>date:   定义了创作博文的时间</p><p>tags:   定义了博文的标签</p><p>除了这个三个属性以外我们还可以扩展一些属性：</p><p>update:  定义了最后修改的时间</p><p>comments：定义能否评论此博文(默认为true)</p><p>categories: 定义了博文的种类</p><h2 id="配置博客-–-config-yml说明"><a href="#配置博客-–-config-yml说明" class="headerlink" title="配置博客 –  _config.yml说明"></a>配置博客 –  _config.yml说明</h2><ul><li>Hexo 的每一个功能都由 <code>_config.yml</code>文件配置，文件就在blog根目录下 具体说明看下面的注解：</li></ul><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta"># Hexo Configuration</span></span><br><span class="line"><span class="meta">## Docs: https://hexo.io/docs/configuration.html</span></span><br><span class="line"><span class="meta">## Source: https://github.com/hexojs/hexo/</span></span><br><span class="line"> </span><br><span class="line"><span class="meta"># Site                 ##修改以适应搜索引擎的收录</span></span><br><span class="line">title: Hexo            <span class="meta">##定义网站的标题</span></span><br><span class="line">subtitle:              <span class="meta">##定义网站的副标题</span></span><br><span class="line">description:           <span class="meta">##定义网站的描述</span></span><br><span class="line">author: jason jwl      <span class="meta">##定义网站的负责人</span></span><br><span class="line">language:              <span class="meta">##定义网站的语言,默认zh-Hans</span></span><br><span class="line">timezone:              <span class="meta">##定义网站的时区</span></span><br><span class="line"> </span><br><span class="line"><span class="meta"># URL</span></span><br><span class="line"><span class="meta">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line">url: http:<span class="comment">//yoursite.com   ##定义网站访问的域名</span></span><br><span class="line">root: /      <span class="meta">##定义所在Web文件夹在哪个目录</span></span><br><span class="line">permalink: :year/:month/:day/:title/  <span class="meta">##定义时间格式</span></span><br><span class="line">permalink_defaults:</span><br><span class="line"> </span><br><span class="line"><span class="meta"># Directory</span></span><br><span class="line">source_dir: source   <span class="meta">##定义从哪个文件夹获取博客资料</span></span><br><span class="line">public_dir: public   <span class="meta">##定义生成静态网站到哪个文件夹</span></span><br><span class="line"> </span><br><span class="line">archive_dir: archives</span><br><span class="line">category_dir: categories</span><br><span class="line">code_dir: downloads/code</span><br><span class="line">i18n_dir: :lang</span><br><span class="line">skip_render:</span><br><span class="line"> </span><br><span class="line"><span class="meta"># Writing</span></span><br><span class="line">new_post_name: :title.md <span class="meta"># File name of new posts</span></span><br><span class="line">default_layout: post</span><br><span class="line">titlecase: <span class="literal">false</span> <span class="meta"># Transform title into titlecase</span></span><br><span class="line">external_link: <span class="literal">true</span> <span class="meta"># Open external links in new tab</span></span><br><span class="line">filename_case: <span class="number">0</span></span><br><span class="line">render_drafts: <span class="literal">false</span></span><br><span class="line">post_asset_folder: <span class="literal">false</span></span><br><span class="line">relative_link: <span class="literal">false</span></span><br><span class="line">future: <span class="literal">true</span></span><br><span class="line">highlight:</span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  line_number: <span class="literal">true</span></span><br><span class="line">  auto_detect: <span class="literal">false</span></span><br><span class="line">  tab_replace:</span><br><span class="line"> </span><br><span class="line"><span class="meta"># Category &amp; Tag</span></span><br><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">tag_map:</span><br><span class="line"> </span><br><span class="line"><span class="meta"># Date / Time format</span></span><br><span class="line"><span class="meta">## Hexo uses Moment.js to parse and display date</span></span><br><span class="line"><span class="meta">## You can customize the date format as defined in</span></span><br><span class="line"><span class="meta">## http://momentjs.com/docs/#/displaying/format/</span></span><br><span class="line">date_format: YYYY-MM-DD</span><br><span class="line">time_format: HH:mm:ss</span><br><span class="line"> </span><br><span class="line"><span class="meta"># Pagination</span></span><br><span class="line"><span class="meta">## Set per_page to 0 to disable pagination</span></span><br><span class="line">per_page: <span class="number">10</span>  <span class="meta">##定义每一页多少条博客</span></span><br><span class="line">pagination_dir: page</span><br><span class="line"> </span><br><span class="line"><span class="meta"># Extensions</span></span><br><span class="line"><span class="meta">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="meta">## Themes: https://hexo.io/themes/</span></span><br><span class="line">theme: landscape  <span class="meta">##定义使用的主题</span></span><br><span class="line"> </span><br><span class="line"><span class="meta"># Deployment</span></span><br><span class="line"><span class="meta">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  type:</span><br></pre></td></tr></table></figure><p>注意：</p><p> 修改这些属性时，请注意格式，属性和值要空一个格，比如theme: landscape。</p><ul><li><p>选择主题 比如 next    </p><ol><li><p>在当前目录输入：<br><code>git clone https://github.com/iissnan/hexo-theme-next themes/next</code>       </p></li><li><p>打开 配置文件 在根目录下 <code>_config.yml</code> 找到 <code>theme</code> 字段 并将其值更改为 <code>next</code><br><img src="/2018/08/30/Hexo-搭建博客/2.png" alt="修改主题"><br>把 <code>landscape</code> 改为 <code>next</code>     </p></li><li><p>在终端输入     </p><pre><code><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  <span class="comment">//清除缓存</span></span><br><span class="line">hexo g  <span class="comment">//重新生成代码</span></span><br><span class="line">hexo s  <span class="comment">//部署到本地</span></span><br><span class="line"><span class="comment">// 然后打开浏览器访问 localhost:4000 查看效果</span></span><br></pre></td></tr></table></figure></code></pre></li></ol></li></ul><ol start="4"><li><p>配置<code>next</code>，next 主题有三种选择，这个只是最简洁的一种，我们选择最好看的那个。这个需要在<code>站点根目录/themes/next/_congig.yml</code>文件中修改  </p><ul><li>Muse - 默认 Scheme，这是 NexT 最初的版本，黑白主调，大量留白</li><li>Mist - Muse 的紧凑版本，整洁有序的单栏外观</li><li>Pisces - 双栏 Scheme，小家碧玉似的清新<br>如下图,将不使用的主题注释掉即可<br><img src="/2018/08/30/Hexo-搭建博客/3.png" alt="主题"></li></ul><p>然后我们重新 clean, generator 刷新网页即可<br><a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">更多next设置</a></p></li></ol><h3 id="本地同步github"><a href="#本地同步github" class="headerlink" title="本地同步github"></a>本地同步github</h3><ol><li><a href="./创建-github-io">创建github.io博客</a>    </li><li>    </li><li><p>安装插件<br><code>npm install hexo-deployer-git --save</code></p></li><li><p>可以通过修改 <code>_config.yml</code> 让 hexo 帮助我们同步到github ,配置如下</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: https://github.com/xxx/xxx.github.io.git</span><br><span class="line">  branch: master</span><br><span class="line">  ## xxx为个人github的name</span><br></pre></td></tr></table></figure><p>配置完后，发布，运行下面的终端命令<br><code>hexo d /* deploy 的缩写 发布命令*/</code></p><ol start="4"><li>以后当你新增文章或者插件时，可以通过下面三个命令进行同步操作</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo c</span><br><span class="line">hexo g</span><br><span class="line">heox d</span><br></pre></td></tr></table></figure><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">https://hexo.io/themes/ 更多hexo主题</span><br><span class="line">https://www.zhihu.com/question/24422335 知乎上的hexo主题</span><br><span class="line">https://blog.csdn.net/Hoshea_chx/article/details/78826689</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      快速搭建 Hexo+Github 博客
    
    </summary>
    
      <category term="技能" scheme="http://yoursite.com/categories/%E6%8A%80%E8%83%BD/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="http://yoursite.com/2018/08/30/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2018/08/30/我的第一篇博客/</id>
    <published>2018-08-30T01:04:01.000Z</published>
    <updated>2018-09-14T09:53:25.219Z</updated>
    
    <content type="html"><![CDATA[<p>请看我这篇文章<a href="/2018/08/30/Hexo-搭建博客/">《搭建博客》</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;请看我这篇文章&lt;a href=&quot;/2018/08/30/Hexo-搭建博客/&quot;&gt;《搭建博客》&lt;/a&gt;&lt;/p&gt;

      
    
    </summary>
    
      <category term="iOS" scheme="http://yoursite.com/categories/iOS/"/>
    
    
      <category term="测试" scheme="http://yoursite.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2018/08/28/hello-world/"/>
    <id>http://yoursite.com/2018/08/28/hello-world/</id>
    <published>2018-08-28T03:02:54.000Z</published>
    <updated>2018-09-07T06:32:56.463Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>

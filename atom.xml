<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>段雨田的Blog</title>
  
  <subtitle>一个不知所云的人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://476139183.github.io/"/>
  <updated>2018-12-27T02:30:27.249Z</updated>
  <id>https://476139183.github.io/</id>
  
  <author>
    <name>Duan yutian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS 制作和使用 Framework</title>
    <link href="https://476139183.github.io/2018/12/10/iOS-%E5%88%B6%E4%BD%9C%E5%92%8C%E4%BD%BF%E7%94%A8-Framework/"/>
    <id>https://476139183.github.io/2018/12/10/iOS-制作和使用-Framework/</id>
    <published>2018-12-10T02:27:02.000Z</published>
    <updated>2018-12-27T02:30:27.249Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>假如你想将你开发的一些控件或者工具与别人分享，一种方法是直接提供源代码文件。然而，这种方法并不是很优雅。因为它会暴露所有的实现细节，而这些实现你可能并不想开源出来。此外，使用者也可能并不想看到你的所有代码，因为他们可能仅仅只是希望将你的这份代码的一部分植入自己的应用中去使用。</p><p>网上关于 <code>Framework</code> 制作的教程不说数不胜数吧，但绝对让人眼花缭乱。但很多都步骤过旧也过简单，更没有更新了，所以这里就把我前些时候总结的 <code>制作Framework</code>的过程记录,重新捋一下。</p><h5 id="我用的是Xcode-9-4"><a href="#我用的是Xcode-9-4" class="headerlink" title="我用的是Xcode 9.4"></a>我用的是Xcode 9.4</h5><a id="more"></a><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><p>首先我们需要打开 Xcode，新建一个项目。 并且选择 <code>Cocoa touch Framework</code>。 如下图</p><p><img src="https://ws4.sinaimg.cn/large/006tNc79gy1fvp1ukuuuhj314k0t8wi8.jpg" alt=""></p><p>然后随便给这个 <code>Framework</code> 取一个名字,比如 <code>TestSDK</code></p><p>为了区分，分别建立了 <code>PublicFile</code> <code>PrivateFile</code>  <code>ProjectFile</code> ,     </p><p>如下图，并分别拖入到对应的 <code>Header</code>组</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fvq663uja6j31kw0xf1kx.jpg" alt=""></p><blockquote><p>在你弄清楚之前，这三个组的名称可能会让你迷惑，<em><font color="orange">Public</font></em> 是你期望的，开源出来的，<em><font color="orange">Private</font></em> 下的头文件依然是可以暴露出来的，因此名字可能有些误导。奇怪的是，在 <em><font color="orange">Project</font></em> 下的头文件对你的工程来说才是 <strong><code>“私有”</code></strong> 的，因此，你将会更多地希望你的头文件或者在 <code>Public</code> 下，或者在 <code>Project</code> 下</p></blockquote><h4 id="必须更改的两个注意点"><a href="#必须更改的两个注意点" class="headerlink" title="必须更改的两个注意点:"></a>必须更改的两个注意点:</h4><h6 id="搜索-mach-将工程改为-静态-。"><a href="#搜索-mach-将工程改为-静态-。" class="headerlink" title="搜索 mach 将工程改为 静态 。"></a>搜索 <code>mach</code> 将工程改为 <code>静态</code> 。</h6><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fvq6lghlpcj31c60bq10i.jpg" alt=""></p><h6 id="搜索-Defines-Module-修改为NO"><a href="#搜索-Defines-Module-修改为NO" class="headerlink" title="搜索 Defines Module 修改为NO"></a>搜索 <code>Defines Module</code> 修改为NO</h6><p><img src="https://ws2.sinaimg.cn/large/006tNc79gy1fvq6komvuuj31c40aeq4z.jpg" alt=""></p><p>最后你还要更改 <code>SDK最低支持</code> 的版本,这个和项目更改 <code>系统支持</code> 的版本一样,不再赘述        </p><p>到此基本配置基本完成,也实现了项目的闭源</p><h2 id="打包（Bundle）资源"><a href="#打包（Bundle）资源" class="headerlink" title="打包（Bundle）资源"></a>打包（Bundle）资源</h2><h4 id="导入Bundle"><a href="#导入Bundle" class="headerlink" title="导入Bundle"></a>导入Bundle</h4><h4 id="在ImageViewer中使用Bundle"><a href="#在ImageViewer中使用Bundle" class="headerlink" title="在ImageViewer中使用Bundle"></a>在ImageViewer中使用Bundle</h4><h2 id="添加自动打包脚本环境-实现自动打包"><a href="#添加自动打包脚本环境-实现自动打包" class="headerlink" title="添加自动打包脚本环境,实现自动打包"></a>添加自动打包脚本环境,实现自动打包</h2><p><img src="https://upload-images.jianshu.io/upload_images/2845360-4ecee02abf98bfca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/950" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/2845360-6cbd6c664b58b84b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/2845360-d7e9e393a4272e91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/2845360-02b693458c795191.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/2845360-7b8705b72984b275.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/2845360-f4a99a21af4042c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt=""></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h4 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h4><h5 id="1-库"><a href="#1-库" class="headerlink" title="1. 库"></a>1. 库</h5><p>库是源代码经过编译，形成的二进制代码，别人项目中使用我们的库的时候，库在参与编译的时候，直接link就OK了，按照link的方式，可以把库分为静态库和动态库</p><h5 id="2-静态库"><a href="#2-静态库" class="headerlink" title="2. 静态库"></a>2. 静态库</h5><p>静态库在编译的时候会被直接拷贝一份，复制到目标程序里，这段代码在目标程序里就不会再改变了。<br>一般以.a 和 .framework为文件后缀名<br>这种做法是牺牲应用“体量”来节省编译时间。</p><h5 id="3-动态库"><a href="#3-动态库" class="headerlink" title="3. 动态库"></a>3. 动态库</h5><p>与静态库相反，动态库在编译时并不会被拷贝到目标程序中，目标程序中只会存储指向动态库的引用。等到程序运行时，动态库才会被真正加载进来。<br>动态库的优点是，不需要拷贝到目标程序中，不会影响目标程序的体积，而且同一份库可以被多个程序使用（因为这个原因，动态库也被称作共享库）。<br>同时，编译时才载入的特性，也可以让我们随时对库进行替换，而不需要重新编译代码。动态库带来的问题主要是，动态载入会带来一部分性能损失，使用动态库也会使得程序依赖于外部环境。如果环境缺少动态库或者库的版本不正确，就会导致程序无法运行<br>以.tbd(之前叫.dylib) 和 .framework 为文件后缀名<br>苹果系统为我们提供了很多动态链接库，我们可以在我们项目工程中查看一下<br><img src="https://upload-images.jianshu.io/upload_images/2845360-8866144669207f3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt=""></p><h5 id="4-Framework"><a href="#4-Framework" class="headerlink" title="4. Framework"></a>4. Framework</h5><p>Framework 是一种打包方式，将库的二进制文件，头文件和有关的资源文件打包到一起，方便管理和分发。<br>Framework只是一种打包方式，其本身和静态、动态无关！<br>但Cocoa Touch Framework 的实际内容为 Header + 动态链接库 + 资源文件</p><h5 id="对Framework认识的误区"><a href="#对Framework认识的误区" class="headerlink" title="对Framework认识的误区"></a>对Framework认识的误区</h5><p>误区①：.framework是动态库，.a是静态库，前面已经讲过，不再赘述<br>误区②：有人说“自定义的动态库苹果审核不通过”，那我打的framework是不是通不过审核？<br>任何没有时间前提的结论都是耍流氓！！！<br>在 iOS 8 / iOS6之前，iOS 平台不支持使用动态 Framework，开发者可以使用的 Framework 只有系统的framework，这种限制可能是出于安全的考虑<br>换一个角度讲，因为 iOS 应用都是运行在沙盒当中，不同的程序之间不能共享代码，同时动态下载代码又是被苹果明令禁止的，没办法发挥出动态库的优势，实际上动态库也就没有存在的必要了<br>但是，码农总是喜欢折腾的，一方面骨子里面有一种“你不让我做我偏要做的倔强”，另一方面用framework确实比用.a加头文件的方式简单，所以这一时期的开发者用了很多“奇淫技巧”来制作framework，这就有了Fake Framework 和 Real Framework的区分<br>在 iOS 8 / iOS6后，iOS平台添加了动态库的支持，同时， Xcode 6 也原生自带了 Framework 支持，注意，前后两个维度的不同是两件事，不要混淆。。。</p><p>那么，为什么 iOS 8 要添加动态库的支持？<br>主要的理由大概就是 Extension 的出现。Extension 和 App 是两个分开的可执行文件，同时需要共享代码，这种情况下动态库的支持就是必不可少的了。但是这种动态 Framework 和系统的 UIKit.Framework 还是有很大区别；还有就是为了支持swift<br>虽然同样是动态框架，但是和系统 framework 不同，app 中的使用的 Cocoa Touch Framework 在打包和提交 app 时会被放到 app bundle 中（App 和 Extension 的 Bundle 是共享的），运行在沙盒里，而不是系统中。也就是说，不同的 app 就算使用了同样的 framework，但还是会有多份的框架被分别签名，打包和加载，因此苹果又把这种 Framework 称为 Embedded Framework，也正是代码签名机制，通过AppStore发布的APP是无法通过替换服务端下发framework的方式来进行热更新！</p><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><p>同一个静态库在不同程序中使用时，每一个程序中都得导入一次，打包时也被打包进去，形成一个程序。而动态库在不同程序中，打包时并没有被打包进去，只在程序运行使用时，才链接载入（如系统的框架如UIKit、Foundation等），所以程序体积会小很多，但是苹果不让使用自己的动态库，否则审核就无法通过。这也是为什么前文将工程选择为 <code>静态</code>的原因</p><h4 id="常见的错误"><a href="#常见的错误" class="headerlink" title="常见的错误:"></a>常见的错误:</h4><p>1, 没有改成静态,不支持动态</p><p><img src="https://upload-images.jianshu.io/upload_images/2845360-7d6b4dede764dfe2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt=""></p><p>2, Defines Module 必须改成NO</p><p>3, 支持bitcode的frame操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">如果自己想要制作支持 Bitcode 的 Framework，</span><br><span class="line">1, 工程中开启 Enable Bitcode </span><br><span class="line">2, Build Setting 中 Other Linker Flags 中加入 -fembed-bitcode。</span><br><span class="line">3, Build Setting 中 Other C Flags 中加入 -fembed-bitcode。</span><br><span class="line"></span><br><span class="line">作者：山神_云网工作室</span><br><span class="line">链接：https://www.jianshu.com/p/ef5a888e57f2</span><br><span class="line">來源：简书</span><br><span class="line">简书著作权归作者所有，任何形式的转载都请联系作者获得授权并注明出处。</span><br></pre></td></tr></table></figure><p>同时支持模拟器真机的配置</p><p><img src="https://upload-images.jianshu.io/upload_images/2845360-93f8dc19331592eb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/980" alt=""></p><p>静态库和自己项目同时开发的方案</p><p><img src="https://upload-images.jianshu.io/upload_images/2845360-643a36730b33d55c.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1000" alt=""></p><p>上文中会用到自动打包的 shell 脚本,我使用的是公司其他大神写的根据项目需求配置的脚本,这里就不开源了, 大家可以使用以下脚本,也可以实现自动打包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">#要build的target名</span><br><span class="line">TARGET_NAME=$&#123;PROJECT_NAME&#125;</span><br><span class="line">if [[ $1 ]]</span><br><span class="line">then</span><br><span class="line">TARGET_NAME=$1</span><br><span class="line">fi</span><br><span class="line">UNIVERSAL_OUTPUT_FOLDER=&quot;$&#123;SRCROOT&#125;/$&#123;PROJECT_NAME&#125;/&quot;</span><br><span class="line"></span><br><span class="line">#创建输出目录，并删除之前的framework文件</span><br><span class="line">mkdir -p &quot;$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;&quot;</span><br><span class="line">rm -rf &quot;$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;/$&#123;TARGET_NAME&#125;.framework&quot;</span><br><span class="line"></span><br><span class="line">#分别编译模拟器和真机的Framework</span><br><span class="line">xcodebuild -target &quot;$&#123;TARGET_NAME&#125;&quot; ONLY_ACTIVE_ARCH=NO -configuration $&#123;CONFIGURATION&#125; -sdk iphoneos BUILD_DIR=&quot;$&#123;BUILD_DIR&#125;&quot; BUILD_ROOT=&quot;$&#123;BUILD_ROOT&#125;&quot; clean build</span><br><span class="line">xcodebuild -target &quot;$&#123;TARGET_NAME&#125;&quot; ONLY_ACTIVE_ARCH=NO -configuration $&#123;CONFIGURATION&#125; -sdk iphonesimulator BUILD_DIR=&quot;$&#123;BUILD_DIR&#125;&quot; BUILD_ROOT=&quot;$&#123;BUILD_ROOT&#125;&quot; clean build</span><br><span class="line"></span><br><span class="line">#拷贝framework到univer目录</span><br><span class="line">cp -R &quot;$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/$&#123;TARGET_NAME&#125;.framework&quot; &quot;$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;&quot;</span><br><span class="line"></span><br><span class="line">#合并framework，输出最终的framework到build目录</span><br><span class="line">lipo -create -output &quot;$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;/$&#123;TARGET_NAME&#125;.framework/$&#123;TARGET_NAME&#125;&quot; &quot;$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator/$&#123;TARGET_NAME&#125;.framework/$&#123;TARGET_NAME&#125;&quot; &quot;$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphoneos/$&#123;TARGET_NAME&#125;.framework/$&#123;TARGET_NAME&#125;&quot;</span><br><span class="line"></span><br><span class="line">#删除编译之后生成的无关的配置文件</span><br><span class="line">dir_path=&quot;$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;/$&#123;TARGET_NAME&#125;.framework/&quot;</span><br><span class="line">for file in ls $dir_path</span><br><span class="line">do</span><br><span class="line">if [[ $&#123;file&#125; =~ &quot;.xcconfig&quot; ]]</span><br><span class="line">then</span><br><span class="line">rm -f &quot;$&#123;dir_path&#125;/$&#123;file&#125;&quot;</span><br><span class="line">fi</span><br><span class="line">done</span><br><span class="line">#判断build文件夹是否存在，存在则删除</span><br><span class="line">if [ -d &quot;$&#123;SRCROOT&#125;/build&quot; ]</span><br><span class="line">then</span><br><span class="line">rm -rf &quot;$&#123;SRCROOT&#125;/build&quot;</span><br><span class="line">fi</span><br><span class="line">rm -rf &quot;$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphonesimulator&quot; &quot;$&#123;BUILD_DIR&#125;/$&#123;CONFIGURATION&#125;-iphoneos&quot;</span><br><span class="line">#打开合并后的文件夹</span><br><span class="line">open &quot;$&#123;UNIVERSAL_OUTPUT_FOLDER&#125;&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;假如你想将你开发的一些控件或者工具与别人分享，一种方法是直接提供源代码文件。然而，这种方法并不是很优雅。因为它会暴露所有的实现细节，而这些实现你可能并不想开源出来。此外，使用者也可能并不想看到你的所有代码，因为他们可能仅仅只是希望将你的这份代码的一部分植入自己的应用中去使用。&lt;/p&gt;
&lt;p&gt;网上关于 &lt;code&gt;Framework&lt;/code&gt; 制作的教程不说数不胜数吧，但绝对让人眼花缭乱。但很多都步骤过旧也过简单，更没有更新了，所以这里就把我前些时候总结的 &lt;code&gt;制作Framework&lt;/code&gt;的过程记录,重新捋一下。&lt;/p&gt;
&lt;h5 id=&quot;我用的是Xcode-9-4&quot;&gt;&lt;a href=&quot;#我用的是Xcode-9-4&quot; class=&quot;headerlink&quot; title=&quot;我用的是Xcode 9.4&quot;&gt;&lt;/a&gt;我用的是Xcode 9.4&lt;/h5&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>王争：羁绊前行的，不是肆虐的狂风，而是内心的迷茫</title>
    <link href="https://476139183.github.io/2018/12/01/%E7%8E%8B%E4%BA%89%EF%BC%9A%E7%BE%81%E7%BB%8A%E5%89%8D%E8%A1%8C%E7%9A%84%EF%BC%8C%E4%B8%8D%E6%98%AF%E8%82%86%E8%99%90%E7%9A%84%E7%8B%82%E9%A3%8E%EF%BC%8C%E8%80%8C%E6%98%AF%E5%86%85%E5%BF%83%E7%9A%84%E8%BF%B7%E8%8C%AB/"/>
    <id>https://476139183.github.io/2018/12/01/王争：羁绊前行的，不是肆虐的狂风，而是内心的迷茫/</id>
    <published>2018-12-01T13:10:19.000Z</published>
    <updated>2018-12-19T07:03:23.848Z</updated>
    
    <content type="html"><![CDATA[<p>看到 王争 老师 单独抽空开一栏 不讲算法，不谈人生，只是为了揭开我们心中的迷茫时。我还是很惭愧的，之前停留在前几节文章，落后了很多课程，但我一直为自己辩解，说服自己因为我想更深层的理解和慢慢反复咀嚼，但这何尝不是一种渴望速成而没有做好迎接漫长的学习之旅。</p><p>我好好的思考了一下，当时的我的做法就是每一篇都反复阅读掌握，才看下一篇，这样可以一点一点的把基础打牢，把算法的思想吃透。而当进度和现状相左时，难免心浮气躁， 背负着抵触情绪强行学习，反而失去了学习的初衷。</p><a id="more"></a><p>直到朋友点醒我，高一的课本还记得么。你最感兴趣的又是哪一门课，你是怎么学习的。我想了想，那门课就是先预习了，然后上课时有一个初步思想，然后更理解了，所以更感兴趣，于是更超前学习了，当时预习的时候考虑的就是不求掌握，但求一个印象。如果我要是纠结这些公式的来源，估计连 1+1=2 都无法理解了。</p><p>心中有了体系的知识结构，再各个击破，局部咀嚼消化。于是我首先放下焦虑，以看小说的心思去阅读文章，看到问题思考一下，没想出来没关系，我继续，不会停留，直到最新的文章为止，然后再从感到不解的地方重新看，发现有了一点点的想法和理解，这让我更感兴趣了，又越啃这些细节了。后来看到一个人问了一个算法题，我不再想以前一样毫无思路，而是给出方案并思考可行性了，这让我略有心喜，这何尝不是解除大题之后的喜悦呢？</p><blockquote><p>PS:写的乱七八糟，只是记录一下，让自己去学习一个不懂的东西时，如何去调整自己</p></blockquote><blockquote><blockquote><p> 有一个大概的知识体系<br> 在不学习的时候，应该坚持学习，在学习的时候，应该忘掉学习，享受其中。</p></blockquote></blockquote><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>你好，我是王争。</p><p>专栏更新过半，我发现有些小伙伴已经掉队，虽然有人掉队也挺正常，但是我还是想尽量拉一把。于是，周末的时间，我就在想，究竟是什么原因让有些小伙伴掉队了？是内容本身太难了吗？是我讲的不够清楚吗？还是小伙伴本身基础太差、不够努力、没有掌握学习方法？</p><p>我觉得都不是，让你掉队的原因，从根儿上讲，是你内心的迷茫。<strong>如果我们不那么确信能不能看懂、能不能学会的时候，当面对困难的时候，很容易就会否定自己，也就很容易半途而废</strong>。</p><p>这就好比你迷失在沙漠中，对你来说，肆虐的狂风并不可怕，可怕的是，你不知道该努力多久才能走出沙漠，不知道到底能不能走出沙漠。这种对结果的未知、不确定，导致了你内心的恐惧，最后就差那么一点点就可以走出沙漠的时候，你放弃了。</p><p>学习也是同样的道理。所以，<strong>我今天不打算讲学习方法，也不打算给你灌输心灵鸡汤，我就讲讲，对这个专栏的学习，或者对于任何学习来说，我觉得你应该建立的一些正确认知</strong>。有了这些认知，希望你能在后面的专栏学习中，少一点迷茫，多一份坚持。</p><h2 id="没有捷径，没有杀手锏，更没有一招致胜的“葵花宝典”"><a href="#没有捷径，没有杀手锏，更没有一招致胜的“葵花宝典”" class="headerlink" title="没有捷径，没有杀手锏，更没有一招致胜的“葵花宝典”"></a>没有捷径，没有杀手锏，更没有一招致胜的“葵花宝典”</h2><p><img src="https://static001.geekbang.org/resource/image/21/68/2138b83c6c35881807d00eac47c02f68.jpg" alt=""></p><p>有小伙伴给我留言说：“看书五分钟，笔记两小时，急求学霸的学习方法”，还有人问，“数据结构和算法好难，到底该怎么学？是我的学习方法不对？还是我太笨？”</p><p>我想说，并没有什么杀手锏的学习方法，更没有一招致胜的“葵花宝典”。不知道这么说有没有让你失望。<strong>如果你真要“求”一个学习方法，那就再看看我在专栏开始写的 “</strong><a href="">如何抓住重点，系统高效地学习数据结构与算法</a> <strong>” 那篇文章吧</strong>。</p><p>说实话，我也挺想知道学霸的学习方法的，所以，在求学路上，每当有学霸来分享学习方法，我都要去听一听。但是，听多了之后，我发现其实并没有太多用。因为那些所谓学霸的学习方法，其实都很简单，比如“认认真真听讲”“认认真真做每一道题”等等。</p><p>也不是他们说的不对，但是这种大实话，我总有一种领会不了的感觉，更别说真正指导我的学习了。而且，我觉得，很多时候，<strong>这些方法论的难点并不在于能不能听懂，而是在于能不能执行到位</strong>。比如很多人都听过“一万小时定律”，坚持一万个小时，你就能成为大牛，但有多少人能坚持一万个小时呢？</p><p>所以，这里我要纠正一个认知，那就是，学习没有“杀手锏”似的方法论。不要怀疑是不是自己的学习方法不对，不要在开始就否定自己。因为否定得越多，你就越迷茫，越不能坚持。</p><h2 id="不要浮躁，不要丧失思考能力，不要丧失学习能力"><a href="#不要浮躁，不要丧失思考能力，不要丧失学习能力" class="headerlink" title="不要浮躁，不要丧失思考能力，不要丧失学习能力"></a>不要浮躁，不要丧失思考能力，不要丧失学习能力</h2><p><img src="https://static001.geekbang.org/resource/image/8c/ca/8c1963cc2a871f4c2de8631d4f8684ca.jpg" alt=""></p><p>有小伙伴给我留言说：“老师，这个地方看不懂，你能不能再解释一下”，还有小伙伴留言说：“《红黑树（上）》里的图为什么跟你的定义不相符？”</p><p>对于留言的问题，我都挺重视的，但是当仔细看这些问题的时候，我发现，实际上文章里已经有答案了，他根本没有认真看、认真思考，更别说去自己搜搜资料，再研究下，就来提问了。</p><p>一般情况下，我都会回复“你自己再认真看一遍”或者“你自己先去网上搜一下，研究研究，如果还不懂再给我留言”。告诉你答案，并不会花费我太长时间，但是，这样会让你丢失最宝贵的东西，那就是，你自己的思考能力、学习能力，能自己沉下心来研究的能力。这个是很可怕的。</p><p>现在，互联网如此发达，我们每天都会面对各种各样的信息轰炸，人也变得越来越浮躁。很多人习惯看些不动脑子就能看懂的东西，看到稍微复杂的东西，就感觉脑子转不动了。</p><p>上学的时候还好，要考试，有老师督促，还能坚持学习。但是工作之后，没有人监督，很多人陷入各种手机 App 中不能自拔，学一会儿就想玩会儿手机，想静下心来学上半个小时都无比困难。无法自律，沉不下心来，那你就基本可以跟学习说拜拜了。</p><h2 id="只有做好打硬仗的心理准备，遇到困难才能心态平和"><a href="#只有做好打硬仗的心理准备，遇到困难才能心态平和" class="headerlink" title="只有做好打硬仗的心理准备，遇到困难才能心态平和"></a>只有做好打硬仗的心理准备，遇到困难才能心态平和</h2><p>还有小伙伴给我留言说：“看不懂，一个 4000 多字的文章、10 分钟的音频，反复看了、听了 2 个小时都没怎么看懂”。我给他的回复是：<strong>“如果之前没有基础或者基础不好的话，看 2 个小时还不懂，很正常，看一个礼拜试试。”</strong></p><p>“一个礼拜”的说法，我一点都不是夸张。虽然专栏的每篇文章都只有三四千字，10 分钟左右的音频，但是知识点的密度还是很高的。如果你潜意识里觉得应该一下子就能看懂，就会出现这样的情况：看了一遍不懂，又看了一遍还是不怎么懂，然后就放弃了。</p><p>数据结和算法就是一个非常难啃的硬骨头，可以说是计算机学科中最难学的学科之一了。<strong>我当时学习也费了老大的劲，能做到讲给你听，我靠的也是十年如一的积累和坚持</strong>。如果没有基础、或者基础不好，你怎能期望看 2 个小时就能完全掌握呢？</p><p>面对这种硬骨头，我觉得我们要有打硬仗、打持久战的心理准备。只有这样，在学习的过程中遇到困难的时候，心态才能更加平和，才能沉下心来有条不紊地去解决一个个的疑难问题。这样，碰到问题，你可能还会“窃喜”，我又遇到了一个之前不怎么懂的知识点了，看懂它我又进步了一点。甚至你还会“坏坏地”想，又多了一个拉开我跟其他人距离的地方了。跨过这些点，我就能比别人更厉害。</p><p>一口吃不成胖子，如果你基础不好，那就从长计议吧，给自己定一个长一点的“死磕”计划，比如一年。面对不懂的知识点，沉下心来逐个突破，这样你的信心慢慢也就建立了。</p><h2 id="“放弃”的念头像是一个心魔，它会一直围绕着你"><a href="#“放弃”的念头像是一个心魔，它会一直围绕着你" class="headerlink" title="“放弃”的念头像是一个心魔，它会一直围绕着你"></a>“放弃”的念头像是一个心魔，它会一直围绕着你</h2><p><img src="https://static001.geekbang.org/resource/image/61/f4/6118ba4f07e5c1f8f1a7a0a18ba6f7f4.jpg" alt=""></p><p>还有小伙伴给我留言说：“开始没怎么看懂，看了一下午，终于看懂了”。看到这样的留言，我其实挺为他感到庆幸的，庆幸他没有中途放弃。因为，放弃的念头就像一个心魔，在我们的学习过程中，它会一直围绕着我们，一旦被它打败一次，你就会被它打败很多次，掉队就不可避免了。</p><p>我分享一个我最近思考比较多的事情。前一段时间，我在研究多线程方面的东西，它涉及一块比较复杂的内容，“Java 内存模型”。虽然看懂并不难，但是要透彻、无盲点地理解并不容易。本来以为半天就能看懂的东西，结果我从周一一直看到周五下午，断断续续花了 5 天的时间才把它彻底搞懂。回忆起这 5 天，我有不下 10 次都想放弃，每次心里都在想：“算了，先放一放，以后再说吧”“太难了，啃不下来，算了。”“就这样吧，反正也用不到，没必要浪费时间”等等。这种放弃的念头就像一个邪恶的魔鬼一样，一直围绕着我这 5 天的研究中。</p><p>现在回想起来，我很庆幸我当时没有放弃，多坚持了几天。如果当时我放弃了，那之后再遇到技术难题时，“放弃”的心魔还会再来拜访我，潜意识里我还是会认输。</p><p>之所以没有放弃，我自己总结了两点原因。</p><p>第一，我对学习这件事情认识得比较清楚，我一直觉得，没有学不会的东西，没有攻克不了的技术难题，如果有，那就说明时间花得还不够多。</p><p>第二，我之前遇到卡壳的时候，几乎从来没有放弃过，即便短暂地停歇，我也会继续拎起来再死磕，而且每次都能搞定，正是这种正向的激励，给了我信心，让我再遇到困难的时候，都能坚信自己能搞定它。</p><h2 id="入门是一个非常漫长和煎熬的过程，谁都逃不过"><a href="#入门是一个非常漫长和煎熬的过程，谁都逃不过" class="headerlink" title="入门是一个非常漫长和煎熬的过程，谁都逃不过"></a>入门是一个非常漫长和煎熬的过程，谁都逃不过</h2><p><img src="https://static001.geekbang.org/resource/image/c3/67/c3db74036668f2d279e9a4a7b8468167.jpg" alt=""></p><p>还有小伙伴留言说：“看到有小伙伴有很多疑问，我来帮作者说句话，文章写的很好，通俗易懂，如果有一定基础，看懂还是不成问题的。”</p><p>我觉得，有些小伙伴的觉悟还是挺高的：）。我文章写得再通俗易懂，对于之前没有任何基础的人来说，看起来还是挺费劲的。</p><p>第一，数据结构和算法这门课程本身的难度摆在那里，想要轻松看懂，本身就不太现实。第二，对于任何新知识的学习，入门都是一个非常漫长和煎熬的的过程。但是这个过程都是要经历的，谁都逃不过。只要你挺过去，入了门，再学习更深的知识就简单多了。</p><p>我大学里的第一堂课是 C 语言，现在回想起来，当时对我来说，简直就是听天书。因为之前没有接触过计算机，更别说编程语言，对我来说，C 语言就像另一个世界的东西。从完全看不懂，到慢慢有点看懂，再到完全看懂，不夸张地讲，我花了好几年的时间，但是当掌握了之后，我发现这个东西其实也不难。但是如果没有度过漫长和煎熬的入门的过程，如果没有一点韧性，没有一点点信念，那可能也没有现在的我了。</p><p>其实我一直觉得<strong>情商比智商更重要</strong>。对于很多学科的学习，智商并不是瓶颈，最终能够决定你能达到的高度的，还是情商，而情商中最重要的，我觉得就是<strong>逆商</strong>（逆境商数，Adversity Quotient），也就是，<strong>当你遇到困难时，你会如何去面对，这将会决定你的人生最终能够走多远</strong>。</p><p><img src="https://static001.geekbang.org/resource/image/56/c2/56db1ff64199a020ef376187f75304c2.jpg" alt=""></p><p>好了，今天我想分享的关于学习的几个认知就讲完了。现在，你有没有对学习这件事有更加清晰的认识呢？能不能让你少一点迷茫，多一份坚持呢？</p><p>最后，我有一句送给你：吃得苦中苦，方为人上人。耐得住寂寞，才能守得住繁华。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到 王争 老师 单独抽空开一栏 不讲算法，不谈人生，只是为了揭开我们心中的迷茫时。我还是很惭愧的，之前停留在前几节文章，落后了很多课程，但我一直为自己辩解，说服自己因为我想更深层的理解和慢慢反复咀嚼，但这何尝不是一种渴望速成而没有做好迎接漫长的学习之旅。&lt;/p&gt;
&lt;p&gt;我好好的思考了一下，当时的我的做法就是每一篇都反复阅读掌握，才看下一篇，这样可以一点一点的把基础打牢，把算法的思想吃透。而当进度和现状相左时，难免心浮气躁， 背负着抵触情绪强行学习，反而失去了学习的初衷。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法" scheme="https://476139183.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="进阶" scheme="https://476139183.github.io/tags/%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>1024 节日快乐</title>
    <link href="https://476139183.github.io/2018/10/24/1024-%E8%8A%82%E6%97%A5%E5%BF%AB%E4%B9%90/"/>
    <id>https://476139183.github.io/2018/10/24/1024-节日快乐/</id>
    <published>2018-10-24T15:46:12.000Z</published>
    <updated>2018-12-07T13:14:09.625Z</updated>
    
    <content type="html"><![CDATA[<p>没错，程序员节 节日快乐！！！  </p><p>后续的 <a href="https://time.geekbang.org/column/intro/133" target="_blank" rel="noopener">《数据结构与算法之美》</a> 我就不发布了，毕竟这是大神的付费文章，有兴趣还是去订阅他的讲课，支持一下知识产权。不过我还是会贴出一些课后习题，记录自己的一些学习感受和成果吧。</p><h4 id="为什么要学算法？"><a href="#为什么要学算法？" class="headerlink" title="为什么要学算法？"></a>为什么要学算法？</h4><p>因为算法无处不在，在生活中我们也会遇到，比如</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwrdgxc59oj30qo0cgab9.jpg" alt=""></p><p>你看，不会算法，我们连Wi-Fi密码都破译不了，</p><p>……</p><a id="more"></a><p>开一个玩笑， 我想很多人都想到了， 因为要面试啊。是的，面试是会问到算法，其实生活上也用的到，比如找女朋友，<br>由数学家 Merrill M. Flood 在 1949 提出的，他命名为“未婚妻选择问题”，可以看作是基于苏格拉底的 <code>麦穗原理</code> 得出的数学版本，这里有一篇文章可以去看看<a href="https://blog.csdn.net/FnqTyr45/article/details/78629810?locationNum=2&amp;fps=1" target="_blank" rel="noopener">传送门</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">炮灰男友数量EX=1/e*N=36.8%*N，其中N为预计所有男朋友的数量。</span><br></pre></td></tr></table></figure><p>这只是一个尴尬而不失礼貌的例子，只为了说明,生活中的很多看起来很复杂的决策,原来都可以用算法来解决。</p><h4 id="那为什么面试会问到算法呢？"><a href="#那为什么面试会问到算法呢？" class="headerlink" title="那为什么面试会问到算法呢？"></a>那为什么面试会问到算法呢？</h4><p>因为如果把编程比喻武学，那么算法就是驱动，是内功，内功雄厚，就可以像鸠摩智一样用小无相功催动的少林七十二绝技。编程亦然，掌握算法，了解核心思想那么就可以快速入门一门语言。所以大家都比较看重内力，这个是最能体现武学造诣。</p><p>我们知道了算法的重要性，那么就要开始入门，掌握一下算法的基本概念。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwrdjdwd50j30go0ke0u7.jpg" alt="算法入门"></p><p>看到这个图，心里肯定是一万匹羊驼跑过</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fwremn5h22j303c01o741.jpg" alt=""></p><p>要是这么好入门，我会在这里写心得？不存在的。还是得靠自己去学习，比如一些有趣的书籍，大神推荐了一本趣味性的入门级书，<a href="">《算法图解》</a>，可以去试试。</p><h4 id="最优方案"><a href="#最优方案" class="headerlink" title="最优方案"></a>最优方案</h4><p>算法入门之后，我们就需要对一些需求进行算法分析了。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwrdkd0w5hj30hs0a6t92.jpg" alt="正确的算法思路"></p><p>此时我的心情是</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fwrdlx7uxnj30dw0dw3zz.jpg" alt=""></p><p>这个小朋友的脑回路清奇，分分钟拿出了一个别具一格的方案，关键是真的解决了需求呀。当然实际上，这个就属于修炼内功出错的情况，方案肯定是不行的，说到这，就要提一下武学奇才 欧阳锋，修炼了错误的九阴真经居然真的成功了。但不是所有人都是欧阳锋，但正确的解决方案和算法分析都需要深厚的算法理论才行，欧阳锋九阴逆行，估计也是内功深厚啊。这里大神是推荐了一本书<a href="">《数据结构和算法分析》</a>.</p><p> 内力深厚是离不开平时的苦修和练习的，所以这里附上<a href="https://time.geekbang.org/column/intro/133" target="_blank" rel="noopener">《数据结构与算法之美》</a>的第七章的课后习题，以及我对题目自己的想法，作为修炼，因为oc是兼容c的，所以我就直接使用了混编编写     </p><p> 接招     </p><ul><li>单链表反转</li></ul><ul><li><p>链表中环的检测</p></li><li><p>两个有序的链表合并</p></li><li><p>删除链表倒数第 n 个结点</p></li><li><p>求链表的中间结点</p></li></ul><h4 id="单链表反转"><a href="#单链表反转" class="headerlink" title="单链表反转"></a>单链表反转</h4><p>我的想法是 假如有一个链表A，我们申明两个结点，一个持有当前结点的上一个结点O，一个持有当前结点的下一个结点Q，遍历链表A的所有结点P，Q指向P-&gt;next,P-&gt;next=O.需要注意边界问题</p><h4 id="链表中环的检测"><a href="#链表中环的检测" class="headerlink" title="链表中环的检测"></a>链表中环的检测</h4><p>单链的中环检测 概念 如图： （也就是单链中存在循环）</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fwh4sn63dsj30ix08nt9d.jpg" alt=""></p><ul><li>单链表中环的检测</li></ul><blockquote><p>首先设置两个指针，分别命名为fast和slow，fast指针每次向后移2步，slow指针每次向后移1步。</p><blockquote><p>如果，fast指针最后走到尾结点，则没有环。<br>如果，fast指针和slow指针相遇，则证明有环。</p></blockquote></blockquote><ul><li>环的起始结点的查询</li></ul><blockquote><p>当fast与slow相遇之后，<br>fast指针从头结点开始走，每次走1步<br>当fast再次与slow相遇以后，相遇处的结点为环的入口结点</p></blockquote><h4 id="两个有序的链表合并"><a href="#两个有序的链表合并" class="headerlink" title="两个有序的链表合并"></a>两个有序的链表合并</h4><p>我暂时没有很好的思路，只是想着用遍历A链表，用B链表的去比较大小，小，就插入A链表头，再用B链表的对比；如果，大，则比较下一个A链表结点。（里面需要用到多个临时结点）</p><h4 id="删除链表倒数第-n-个结点"><a href="#删除链表倒数第-n-个结点" class="headerlink" title="删除链表倒数第 n 个结点"></a>删除链表倒数第 n 个结点</h4><p>用3个指针，A，B，C，其中A正常， B落后A n 步，C 再落后 B 一步，同时遍历链表，等A走到链表结尾的时候，B就是要删除的结点P，C就是P的前一个结点。</p><h4 id="求链表的中间结点"><a href="#求链表的中间结点" class="headerlink" title="求链表的中间结点"></a>求链表的中间结点</h4><p>同理 快慢指针，还有注意最后快指针的奇偶。</p><p>我的作业Git地址 <a href="https://github.com/476139183/linkedlist" target="_blank" rel="noopener">传送门</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;没错，程序员节 节日快乐！！！  &lt;/p&gt;
&lt;p&gt;后续的 &lt;a href=&quot;https://time.geekbang.org/column/intro/133&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《数据结构与算法之美》&lt;/a&gt; 我就不发布了，毕竟这是大神的付费文章，有兴趣还是去订阅他的讲课，支持一下知识产权。不过我还是会贴出一些课后习题，记录自己的一些学习感受和成果吧。&lt;/p&gt;
&lt;h4 id=&quot;为什么要学算法？&quot;&gt;&lt;a href=&quot;#为什么要学算法？&quot; class=&quot;headerlink&quot; title=&quot;为什么要学算法？&quot;&gt;&lt;/a&gt;为什么要学算法？&lt;/h4&gt;&lt;p&gt;因为算法无处不在，在生活中我们也会遇到，比如&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://ws2.sinaimg.cn/large/006tNbRwgy1fwrdgxc59oj30qo0cgab9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;你看，不会算法，我们连Wi-Fi密码都破译不了，&lt;/p&gt;
&lt;p&gt;……&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>04 | 复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度</title>
    <link href="https://476139183.github.io/2018/10/16/04-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89%EF%BC%9A%E6%B5%85%E6%9E%90%E6%9C%80%E5%A5%BD%E3%80%81%E6%9C%80%E5%9D%8F%E3%80%81%E5%B9%B3%E5%9D%87%E3%80%81%E5%9D%87%E6%91%8A%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/"/>
    <id>https://476139183.github.io/2018/10/16/04-复杂度分析（下）：浅析最好、最坏、平均、均摊时间复杂度/</id>
    <published>2018-10-16T01:37:43.000Z</published>
    <updated>2018-10-16T06:44:09.496Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://time.geekbang.org/column/article/40447" target="_blank" rel="noopener">文章订阅</a></p><p><a href="">上一节，我们讲了复杂度的大 O 表示法和几个分析技巧</a>，还举了一些常见复杂度分析的例子，比如 O(1)、O(logn)、O(n)、O(nlogn) 复杂度分析。掌握了这些内容，对于复杂度分析这个知识点，你已经可以到及格线了。但是，我想你肯定不会满足于此。</p><p>今天我会继续给你讲四个复杂度分析方面的知识点，<strong><font color="darkOrange">最好情况时间复杂度</font></strong>（best case time complexity）、<strong><font color="darkOrange">最坏情况时间复杂度</font></strong>（worst case time complexity）、<strong><font color="darkOrange">平均情况时间复杂度</font></strong>（average case time complexity）、<strong><font color="darkOrange">均摊时间复杂度</font></strong>（amortized time complexity）。如果这几个概念你都能掌握，那对你来说，复杂度分析这部分内容就没什么大问题了。</p><a id="more"></a><h2 id="最好、最坏情况时间复杂度"><a href="#最好、最坏情况时间复杂度" class="headerlink" title="最好、最坏情况时间复杂度"></a><span id="1.0">最好、最坏情况时间复杂度</span></h2><p>上一节我举的分析复杂度的例子都很简单，今天我们来看一个稍微复杂的。你可以用我上节教你的分析技巧，自己先试着分析一下这段代码的时间复杂度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// n 表示数组 array 的长度</span><br><span class="line">int find(int[] array, int n, int x) &#123;</span><br><span class="line">  int i = 0;</span><br><span class="line">  int pos = -1;</span><br><span class="line">  for (; i &lt; n; ++i) &#123;</span><br><span class="line">    if (array[i] == x) pos = i;</span><br><span class="line">  &#125;</span><br><span class="line">  return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你应该可以看出来，这段代码要实现的功能是，在一个无序的数组（array）中，查找变量 x 出现的位置。如果没有找到，就返回 -1。按照上节课讲的分析方法，这段代码的复杂度是 O(n)，其中，n 代表数组的长度。</p><p>我们在数组中查找一个数据，并不需要每次都把整个数组都遍历一遍，因为有可能中途找到就可以提前结束循环了。但是，这段代码写得不够高效。我们可以这样优化一下这段查找代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// n 表示数组 array 的长度</span><br><span class="line">int find(int[] array, int n, int x) &#123;</span><br><span class="line">  int i = 0;</span><br><span class="line">  int pos = -1;</span><br><span class="line">  for (; i &lt; n; ++i) &#123;</span><br><span class="line">    if (array[i] == x) &#123;</span><br><span class="line">       pos = i;</span><br><span class="line">       break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，问题就来了。我们优化完之后，这段代码的时间复杂度还是 O(n) 吗？很显然，咱们上一节讲的分析方法，解决不了这个问题。</p><p>因为，要查找的变量 x 可能出现在数组的任意位置。如果数组中第一个元素正好是要查找的变量 x，那就不需要继续遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)。但如果数组中不存在变量 x，那我们就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)。所以，不同的情况下，这段代码的时间复杂度是不一样的。</p><p>为了表示代码在不同情况下的不同时间复杂度，我们需要引入三个概念：最好情况时间复杂度、最坏情况时间复杂度和平均情况时间复杂度。</p><p>顾名思义，<strong>最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度</strong>。就像我们刚刚讲到的，在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，这个时候对应的时间复杂度就是最好情况时间复杂度。</p><p>同理，<strong>最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度</strong>。就像刚举的那个例子，如果数组中没有要查找的变量 x，我们需要把整个数组都遍历一遍才行，所以这种最糟糕情况下对应的时间复杂度就是最坏情况时间复杂度。</p><h2 id="平均情况时间复杂度"><a href="#平均情况时间复杂度" class="headerlink" title="平均情况时间复杂度"></a><span id="2.0">平均情况时间复杂度<span></span></span></h2><p>我们都知道，最好情况时间复杂度和最坏情况时间复杂度对应的都是极端情况下的代码复杂度，发生的概率其实并不大。为了更好地表示平均情况下的复杂度，我们需要引入另一个概念：平均情况时间复杂度，后面我简称为平均时间复杂度。</p><p>平均时间复杂度又该怎么分析呢？我还是借助刚才查找变量 x 的例子来给你解释。</p><p>要查找的变量 x 在数组中的位置，有 n+1 种情况：<strong>在数组的 0～n-1 位置中和不在数组中</strong>。我们把每种情况下，查找需要遍历的元素个数累加起来，然后再除以 n+1，就可以得到需要遍历的元素个数的平均值，即：</p><p><img src="https://static001.geekbang.org/resource/image/d8/2f/d889a358b8eccc5bbb90fc16e327a22f.jpg" alt=""></p><p>我们知道，时间复杂度的大 O 标记法中，可以省略掉系数、低阶、常量，所以，咱们把刚刚这个公式简化之后，得到的平均时间复杂度就是 O(n)。</p><p>这个结论虽然是正确的，但是计算过程稍微有点儿问题。究竟是什么问题呢？我们刚讲的这 n+1 种情况，出现的概率并不是一样的。我带你具体分析一下。（这里要稍微用到一点儿概率论的知识，不过非常简单，你不用担心。）</p><p>我们知道，要查找的变量 x，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便你理解，我们假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0～n-1 这 n 个位置的概率也是一样的，为 1/n。所以，根据概率乘法法则，要查找的数据出现在 0～n-1 中任意位置的概率就是 1/(2n)。</p><p>因此，前面的推导过程中存在的最大问题就是，没有将各种情况发生的概率考虑进去。如果我们把每种情况发生的概率也考虑进去，那平均时间复杂度的计算过程就变成了这样：</p><p><img src="https://static001.geekbang.org/resource/image/36/7f/36c0aabdac69032f8a43368f5e90c67f.jpg" alt=""></p><p>这个值就是概率论中的 <strong>加权平均值</strong>，也叫作<strong>期望值</strong>，所以平均时间复杂度的全称应该叫<strong>加权平均时间复杂度</strong>或者<strong>期望时间复杂度</strong>。</p><p>引入概率之后，前面那段代码的加权平均值为 (3n+1)/4。用大 O 表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是 O(n)。</p><p>你可能会说，平均时间复杂度分析好复杂啊，还要涉及概率论的知识。实际上，在大多数情况下，我们并不需要区分最好、最坏、平均情况时间复杂度三种情况。像我们上一节课举的那些例子那样，很多时候，我们使用一个复杂度就可以满足需求了。只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。</p><h2 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a><span id="3.0">均摊时间复杂度<span></span></span></h2><p>到此为止，你应该已经掌握了算法复杂度分析的大部分内容了。下面我要给你讲一个更加高级的概念，均摊时间复杂度，以及它对应的分析方法，摊还分析（或者叫平摊分析）。</p><p>均摊时间复杂度，听起来跟平均时间复杂度有点儿像。对于初学者来说，这两个概念确实非常容易弄混。我前面说了，大部分情况下，我们并不需要区分最好、最坏、平均三种复杂度。平均复杂度只在某些特殊情况下才会用到，而均摊时间复杂度应用的场景比它更加特殊、更加有限。</p><p>老规矩，我还是借助一个具体的例子来帮助你理解。（当然，这个例子只是我为了方便讲解想出来的，实际上没人会这么写。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// array 表示一个长度为 n 的数组</span><br><span class="line"> // 代码中的 array.length 就等于 n</span><br><span class="line"> int[] array = new int[n];</span><br><span class="line"> int count = 0;</span><br><span class="line"> </span><br><span class="line"> void insert(int val) &#123;</span><br><span class="line">    if (count == array.length) &#123;</span><br><span class="line">       int sum = 0;</span><br><span class="line">       for (int i = 0; i &lt; array.length; ++i) &#123;</span><br><span class="line">          sum = sum + array[i];</span><br><span class="line">       &#125;</span><br><span class="line">       array[0] = sum;</span><br><span class="line">       count = 1;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    array[count] = val;</span><br><span class="line">    ++count;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我先来解释一下这段代码。这段代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 count == array.length 时，我们用 for 循环遍历数组求和，并<strong><font color="green">清空数组</font></strong><a href="这里的例子忽略数组的清空问题，采用覆盖旧值方法，只关心存储新值。">^1</a>，将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。</p><p>那这段代码的时间复杂度是多少呢？你可以先用我们刚讲到的三种时间复杂度的分析方法来分析一下。</p><p>最理想的情况下，数组中有空闲空间，我们只需要将数据插入到数组下标为 count 的位置就可以了，所以最好情况时间复杂度为 O(1)。最坏的情况下，数组中没有空闲空间了，我们需要先做一次数组的遍历求和，然后再将数据插入，所以最坏情况时间复杂度为 O(n)。</p><p>那平均时间复杂度是多少呢？答案是 O(1)。我们还是可以通过前面讲的概率论的方法来分析。</p><p>假设数组的长度是 n，根据数据插入的位置的不同，我们可以分为 n 种情况，每种情况的时间复杂度是 O(1)。除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)。而且，这 n+1 种情况发生的概率一样，都是 1/(n+1)。所以，根据加权平均的计算方法，我们求得的平均时间复杂度就是：</p><p><img src="https://static001.geekbang.org/resource/image/6d/ed/6df62366a60336d9de3bc34f488d8bed.jpg" alt=""></p><p>至此为止，前面的最好、最坏、平均时间复杂度的计算，理解起来应该都没有问题。但是这个例子里的平均复杂度分析其实并不需要这么复杂，不需要引入概率论的知识。这是为什么呢？我们先来对比一下这个 insert() 的例子和前面那个 find() 的例子，你就会发现这两者有很大差别。</p><p>首先，find() 函数在极端情况下，复杂度才为 O(1)。但 insert() 在大部分情况下，时间复杂度都为 O(1)。只有个别情况下，复杂度才比较高，为 O(n)。这是 insert()<strong>第一个</strong>区别于 find() 的地方。</p><p>我们再来看<code>第二个</code>不同的地方。对于 insert() 函数来说，O(1) 时间复杂度的插入和 O(n) 时间复杂度的插入，出现的频率是非常有规律的，而且有一定的前后时序关系，一般都是一个 O(n) 插入之后，紧跟着 n-1 个 O(1) 的插入操作，循环往复。</p><p>所以，针对这样一种特殊场景的复杂度分析，我们并不需要像之前讲平均复杂度分析方法那样，找出所有的输入情况及相应的发生概率，然后再计算加权平均值。</p><p>针对这种特殊的场景，我们引入了一种更加简单的分析方法：<strong>摊还分析法</strong>，通过摊还分析得到的时间复杂度我们起了一个名字，叫<strong>均摊时间复杂度</strong>。</p><p>那究竟如何使用摊还分析法来分析算法的均摊时间复杂度呢？</p><p>我们还是继续看在数组中插入数据的这个例子。每一次 O(n) 的插入操作，都会跟着 n-1 次 O(1) 的插入操作，所以把耗时多的那次操作均摊到接下来的 n-1 次耗时少的操作上，均摊下来，这一组连续的操作的均摊时间复杂度就是 O(1)。这就是均摊分析的大致思路。你都理解了吗？</p><p>均摊时间复杂度和摊还分析应用场景比较特殊，所以我们并不会经常用到。为了方便你理解、记忆，我这里简单总结一下它们的应用场景。如果你遇到了，知道是怎么回事儿就行了。</p><p>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，一般均摊时间复杂度就等于最好情况时间复杂度。</p><p>尽管很多数据结构和算法书籍都花了很大力气来区分平均时间复杂度和均摊时间复杂度，但其实我个人认为，<strong>均摊时间复杂度就是一种特殊的平均时间复杂度</strong>，我们没必要花太多精力去区分它们。你最应该掌握的是它的分析方法，摊还分析。至于分析出来的结果是叫平均还是叫均摊，这只是个说法，并不重要。</p><h2 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h2><p>今天我们学习了几个复杂度分析相关的概念，分别有：最好情况时间复杂度、最坏情况时间复杂度、平均情况时间复杂度、均摊时间复杂度。之所以引入这几个复杂度概念，是因为，同一段代码，在不同输入的情况下，复杂度量级有可能是不一样的。</p><p>在引入这几个概念之后，我们可以更加全面地表示一段代码的执行效率。而且，这几个概念理解起来都不难。最好、最坏情况下的时间复杂度分析起来比较简单，但平均、均摊两个复杂度分析相对比较复杂。如果你觉得理解得还不是很深入，不用担心，在后续具体的数据结构和算法学习中，我们可以继续慢慢实践！</p><h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>我们今天学的几个复杂度分析方法，你都掌握了吗？你可以用今天学习的知识，来分析一下下面这个 add() 函数的时间复杂度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// 全局变量，大小为 10 的数组 array，长度 len，下标 i。</span><br><span class="line">int array[] = new int[10]; </span><br><span class="line">int len = 10;</span><br><span class="line">int i = 0;</span><br><span class="line"> </span><br><span class="line">// 往数组中添加一个元素</span><br><span class="line">void add(int element) &#123;</span><br><span class="line">   if (i &gt;= len) &#123; // 数组空间不够了</span><br><span class="line">     // 重新申请一个 2 倍大小的数组空间</span><br><span class="line">     int new_array[] = new int[len*2];</span><br><span class="line">     // 把原来 array 数组中的数据依次 copy 到 new_array</span><br><span class="line">     for (int j = 0; j &lt; len; ++j) &#123;</span><br><span class="line">       new_array[j] = array[j];</span><br><span class="line">     &#125;</span><br><span class="line">     // new_array 复制给 array，array 现在大小就是 2 倍 len 了</span><br><span class="line">     array = new_array;</span><br><span class="line">     len = 2 * len;</span><br><span class="line">   &#125;</span><br><span class="line">   // 将 element 放到下标为 i 的位置，下标 i 加一</span><br><span class="line">   array[i] = element;</span><br><span class="line">   ++i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>欢迎留言和我分享，我会第一时间给你反馈。</p><h2 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h2><p>一、复杂度分析的4个概念</p><ol><li><a href="#1.0">最坏情况时间复杂度</a>：代码在最理想情况下执行的时间复杂度。</li><li><a href="#1.0">最好情况时间复杂度</a>：代码在最坏情况下执行的时间复杂度。</li><li><a href="#2.0">平均时间复杂度</a>：用代码在所有情况下执行的次数的加权（概率）平均值表示。</li><li><a href="#3.0">均摊时间复杂度</a>：在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，可以将个别高级别复杂度均摊到低级别复杂度上。基本上均摊结果就等于低级别复杂度。<strong>我认为这是一个特殊的平均时间复杂度，只不过概率有规律，且所有情况之间互有依赖关系，这样就可以把耗时多的操作分摊给耗时少的</strong></li></ol><p>二、为什么要引入这4个概念？<br>1.同一段代码在不同情况下时间复杂度会出现量级差异，为了更全面，更准确的描述代码的时间复杂度，所以引入这4个概念。<br>2.代码复杂度在不同情况下出现量级差别时才需要区别这四种复杂度。大多数情况下，是不需要区别分析它们的。</p><p>三、如何分析平均、均摊时间复杂度？   </p><ol><li>平均时间复杂度<br>代码在不同情况下复杂度出现量级差别，则用代码所有可能情况下执行次数的加权平均值表示。</li><li>均摊时间复杂度<br>两个条件满足时使用：<ul><li>代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；</li><li>低级别和高级别复杂度出现具有时序规律。均摊结果一般都等于低级别复杂度。</li></ul></li></ol><p>答案：<br>经过分析，最后的练习题的复杂度 最好是O(1)，最差是O(n),平均O(1),均摊是O(1)。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/40447&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章订阅&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;&quot;&gt;上一节，我们讲了复杂度的大 O 表示法和几个分析技巧&lt;/a&gt;，还举了一些常见复杂度分析的例子，比如 O(1)、O(logn)、O(n)、O(nlogn) 复杂度分析。掌握了这些内容，对于复杂度分析这个知识点，你已经可以到及格线了。但是，我想你肯定不会满足于此。&lt;/p&gt;
&lt;p&gt;今天我会继续给你讲四个复杂度分析方面的知识点，&lt;strong&gt;&lt;font color=&quot;darkOrange&quot;&gt;最好情况时间复杂度&lt;/font&gt;&lt;/strong&gt;（best case time complexity）、&lt;strong&gt;&lt;font color=&quot;darkOrange&quot;&gt;最坏情况时间复杂度&lt;/font&gt;&lt;/strong&gt;（worst case time complexity）、&lt;strong&gt;&lt;font color=&quot;darkOrange&quot;&gt;平均情况时间复杂度&lt;/font&gt;&lt;/strong&gt;（average case time complexity）、&lt;strong&gt;&lt;font color=&quot;darkOrange&quot;&gt;均摊时间复杂度&lt;/font&gt;&lt;/strong&gt;（amortized time complexity）。如果这几个概念你都能掌握，那对你来说，复杂度分析这部分内容就没什么大问题了。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://476139183.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="https://476139183.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="进阶" scheme="https://476139183.github.io/tags/%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>03 | 复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？</title>
    <link href="https://476139183.github.io/2018/10/02/03-%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89%EF%BC%9A%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E3%80%81%E7%BB%9F%E8%AE%A1%E7%AE%97%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87%E5%92%8C%E8%B5%84%E6%BA%90%E6%B6%88%E8%80%97%EF%BC%9F/"/>
    <id>https://476139183.github.io/2018/10/02/03-复杂度分析（上）：如何分析、统计算法的执行效率和资源消耗？/</id>
    <published>2018-10-02T02:28:27.000Z</published>
    <updated>2018-10-16T06:54:53.297Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://time.geekbang.org/column/article/40036" target="_blank" rel="noopener">文章订阅</a></p><p>我们都知道，数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。那如何来衡量你编写的算法代码的执行效率呢？这里就要用到我们今天要讲的内容：时间、空间复杂度分析。</p><p>其实，只要讲到数据结构与算法，就一定离不开时间、空间复杂度分析。而且，我个人认为，<strong>复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半</strong>。</p><p>复杂度分析实在太重要了，因此我准备用两节内容来讲。希望你学完这个内容之后，无论在任何场景下，面对任何代码的复杂度分析，你都能做到“庖丁解牛”般游刃有余。</p><a id="more"></a><h3 id="为什么需要复杂度分析？"><a href="#为什么需要复杂度分析？" class="headerlink" title="为什么需要复杂度分析？"></a>为什么需要复杂度分析？</h3><p>你可能会有些疑惑，我把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。为什么还要做时间、空间复杂度分析呢？这种分析方法能比我实实在在跑一遍得到的数据更准确吗？</p><p>首先，我可以肯定地说，你这种评估算法执行效率的方法是正确的。很多数据结构和算法书籍还给这种方法起了一个名字，叫 <code>事后统计法</code>。但是，这种统计方法有非常大的局限性。</p><h4 id="1-测试结果非常依赖测试环境"><a href="#1-测试结果非常依赖测试环境" class="headerlink" title="1. 测试结果非常依赖测试环境"></a>1. 测试结果非常依赖测试环境</h4><p>测试环境中硬件的不同会对测试结果有很大的影响。比如，我们拿同样一段代码，分别用 Intel Core i9 处理器和 Intel Core i3 处理器来运行，不用说，i9 处理器要比 i3 处理器执行的速度快很多。还有，比如原本在这台机器上 a 代码执行的速度比 b 代码要快，等我们换到另一台机器上时，可能会有截然相反的结果。</p><h4 id="2-测试结果受数据规模的影响很大"><a href="#2-测试结果受数据规模的影响很大" class="headerlink" title="2. 测试结果受数据规模的影响很大"></a>2. 测试结果受数据规模的影响很大</h4><p>后面我们会讲排序算法，我们先拿它举个例子。对同一个排序算法，待排序数据的有序度不一样，排序的执行时间就会有很大的差别。极端情况下，如果数据已经是有序的，那排序算法不需要做任何操作，执行时间就会非常短。除此之外，如果测试数据规模太小，测试结果可能无法真实地反应算法的性能。比如，对于小规模的数据排序，插入排序可能反倒会比快速排序要快！</p><p>所以，<strong>我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法</strong>。这就是我们今天要讲的时间、空间复杂度分析方法。</p><h3 id="大-O-复杂度表示法"><a href="#大-O-复杂度表示法" class="headerlink" title="大 O 复杂度表示法"></a><span id="1.0">大 O 复杂度表示法</span></h3><p>算法的执行效率，粗略地讲，就是算法代码执行的时间。但是，如何在不运行代码的情况下，用“肉眼”得到一段代码的执行时间呢？</p><p>这里有段非常简单的代码，求 1,2,3…n 的累加和。现在，我就带你一块来估算一下这段代码的执行时间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">   int sum = 0;</span><br><span class="line">   int i = 1;</span><br><span class="line">   for (; i &lt;= n; ++i) &#123;</span><br><span class="line">     sum = sum + i;</span><br><span class="line">   &#125;</span><br><span class="line">   return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：<strong>读数据-运算-写数据</strong>。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以假设每行代码执行的时间都一样，为 unit_time。在这个假设的基础之上，这段代码的总执行时间是多少呢？</p><p>第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以需要 <strong>2n<em>unit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)</em>unit_time</strong>。可以看出来，<strong>所有代码的执行时间 T(n) 与每行代码的执行次数成正比</strong>。</p><p>按照这个分析思路，我们再来看这段代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">  int sum = 0;</span><br><span class="line">  int i = 1;</span><br><span class="line">  int j = 1;</span><br><span class="line">  for (; i &lt;= n; ++i) &#123;</span><br><span class="line">    j = 1;</span><br><span class="line">    for (; j &lt;= n; ++j) &#123;</span><br><span class="line">      sum = sum +  i * j;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们依旧假设每个语句的执行时间是 unit_time。那这段代码的总执行时间 T(n) 是多少呢？</p><p>第 2、3、4 行代码，每行都需要 1 个 unit_time 的执行时间，第 5、6 行代码循环执行了 n 遍，需要 2n <em> unit_time 的执行时间，第 7、8 行代码循环执行了 n2遍，所以需要 2n2 </em> unit_time 的执行时间。所以，整段代码总的执行时间 T(n) = (2n2+2n+3)*unit_time。</p><p>尽管我们不知道 unit_time 的具体值，但是通过这两段代码执行时间的推导过程，我们可以得到一个非常重要的规律，那就是，<strong><font color="DarkOrange"></font></strong>所有代码的执行时间 T(n) 与每行代码的执行次数 n 成正比。</p><p>我们可以把这个规律总结成一个公式。注意，大 O 就要登场了！</p><p><img src="https://static001.geekbang.org/resource/image/22/ef/22900968aa2b190072c985a08b0e92ef.png" alt=""></p><p>我来具体解释一下这个公式。其中，T(n) 我们已经讲过了，它表示代码执行的时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和。因为这是一个公式，所以用 f(n) 来表示。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。</p><p>所以，第一个例子中的 T(n) = O(2n+2)，第二个例子中的 T(n) = O(2n2+2n+3)。这就是 <strong>大 O 时间复杂度表示法</strong>。大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作<strong>渐进时间复杂度</strong>（asymptotic time complexity），简称<strong>时间复杂度</strong>。</p><p>当 n 很大时，你可以把它想象成 10000、100000。而公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：T(n) = O(n)； T(n) = O(n2)。</p><h3 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a><span id="2.0">时间复杂度分析</span></h3><p>前面介绍了大 O 时间复杂度的由来和表示方法。现在我们来看下，如何分析一段代码的时间复杂度？我这儿有三个比较实用的方法可以分享给你。</p><h4 id="1-只关注循环执行次数最多的一段代码"><a href="#1-只关注循环执行次数最多的一段代码" class="headerlink" title="1. 只关注循环执行次数最多的一段代码"></a>1. 只关注循环执行次数最多的一段代码</h4><p>我刚才说了，大 O 这种复杂度表示方法只是表示一种变化趋势。我们通常会忽略掉公式中的常量、低阶、系数，只需要记录一个最大阶的量级就可以了。所以，<strong>我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了</strong>。这段核心代码执行次数的 n 的量级，就是整段要分析代码的时间复杂度。</p><p>为了便于你理解，我还拿前面的例子来说明。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">  int sum = 0;</span><br><span class="line">  int i = 1;</span><br><span class="line">  for (; i &lt;= n; ++i) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125;</span><br><span class="line">  return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中第 2、3 行代码都是常量级的执行时间，与 n 的大小无关，所以对于复杂度并没有影响。循环执行次数最多的是第 4、5 行代码，所以这块代码要重点分析。前面我们也讲过，这两行代码被执行了 n 次，所以总的时间复杂度就是 O(n)。</p><h4 id="2-加法法则：总复杂度等于量级最大的那段代码的复杂度"><a href="#2-加法法则：总复杂度等于量级最大的那段代码的复杂度" class="headerlink" title="2. 加法法则：总复杂度等于量级最大的那段代码的复杂度"></a><span id="2.1">2. 加法法则：总复杂度等于量级最大的那段代码的复杂度</span></h4><p>我这里还有一段代码。你可以先试着分析一下，然后再往下看跟我的分析思路是否一样。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">   int sum_1 = 0;</span><br><span class="line">   int p = 1;</span><br><span class="line">   for (; p &lt; 100; ++p) &#123;</span><br><span class="line">     sum_1 = sum_1 + p;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   int sum_2 = 0;</span><br><span class="line">   int q = 1;</span><br><span class="line">   for (; q &lt; n; ++q) &#123;</span><br><span class="line">     sum_2 = sum_2 + q;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   int sum_3 = 0;</span><br><span class="line">   int i = 1;</span><br><span class="line">   int j = 1;</span><br><span class="line">   for (; i &lt;= n; ++i) &#123;</span><br><span class="line">     j = 1; </span><br><span class="line">     for (; j &lt;= n; ++j) &#123;</span><br><span class="line">       sum_3 = sum_3 +  i * j;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   return sum_1 + sum_2 + sum_3;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>这个代码分为三部分，分别是求 sum_1、sum_2、sum_3。我们可以分别分析每一部分的时间复杂度，然后把它们放到一块儿，再取一个量级最大的作为整段代码的复杂度。</p><p>第一段的时间复杂度是多少呢？这段代码循环执行了 100 次，所以是一个常量的执行时间，跟 n 的规模无关。</p><p>这里我要再强调一下，即便这段代码循环 10000 次、100000 次，只要是一个已知的数，跟 n 无关，照样也是常量级的执行时间。当 n 无限大的时候，就可以忽略。尽管对代码的执行时间会有很大影响，但是回到时间复杂度的概念来说，它表示的是一个算法执行效率与数据规模增长的变化趋势，所以不管常量的执行时间多大，我们都可以忽略掉。因为它本身对增长趋势并没有影响。</p><p>那第二段代码和第三段代码的时间复杂度是多少呢？答案是 O(n) 和 O(n2)，你应该能容易就分析出来，我就不啰嗦了。</p><p>综合这三段代码的时间复杂度，我们取其中最大的量级。所以，整段代码的时间复杂度就为 O(n2)。也就是说：<strong>总的时间复杂度就等于量级最大的那段代码的时间复杂度</strong>。那我们将这个规律抽象成公式就是：</p><p>如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n))).</p><h4 id="3-乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"><a href="#3-乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积" class="headerlink" title="3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积"></a><span id="2.2">3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</span></h4><p>我刚讲了一个复杂度分析中的加法法则，这儿还有一个<strong>乘法法则</strong>。类比一下，你应该能“猜到”公式是什么样子的吧？</p><p>如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 <strong><font color="DarkOrange">T(n)=T1(n)<em>T2(n)=O(f(n))</em>O(g(n))=O(f(n)*g(n))</font></strong>.</p><p>也就是说，假设 T1(n) = O(n)，T2(n) = O(n2)，则 T1(n) * T2(n) = O(n3)。落实到具体的代码上，我们可以把乘法法则看成是<strong>嵌套循环</strong>，我举个例子给你解释一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int cal(int n) &#123;</span><br><span class="line">   int ret = 0; </span><br><span class="line">   int i = 1;</span><br><span class="line">   for (; i &lt; n; ++i) &#123;</span><br><span class="line">     ret = ret + f(i);</span><br><span class="line">   &#125; </span><br><span class="line"> &#125; </span><br><span class="line"> </span><br><span class="line"> int f(int n) &#123;</span><br><span class="line">  int sum = 0;</span><br><span class="line">  int i = 1;</span><br><span class="line">  for (; i &lt; n; ++i) &#123;</span><br><span class="line">    sum = sum + i;</span><br><span class="line">  &#125; </span><br><span class="line">  return sum;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们单独看 cal() 函数。假设 f() 只是一个普通的操作，那第 4～6 行的时间复杂度就是，T1(n) = O(n)。但 f() 函数本身不是一个简单的操作，它的时间复杂度是 T2(n) = O(n)，所以，整个 cal() 函数的时间复杂度就是，T(n) = T1(n) <em> T2(n) = O(n</em>n) = O(n2)。</p><p>我刚刚讲了三种复杂度的分析技巧。不过，你并不用刻意去记忆。实际上，复杂度分析这个东西关键在于“熟练”。你只要多看案例，多分析，就能做到“无招胜有招”。</p><h3 id="几种常见时间复杂度实例分析"><a href="#几种常见时间复杂度实例分析" class="headerlink" title="几种常见时间复杂度实例分析"></a>几种常见时间复杂度实例分析</h3><p>虽然代码千差万别，但是常见的复杂度量级并不多。我稍微总结了一下，这些复杂度量级几乎涵盖了你今后可以接触的所有代码的复杂度量级。</p><p><img src="https://static001.geekbang.org/resource/image/37/0a/3723793cc5c810e9d5b06bc95325bf0a.jpg" alt=""></p><p>对于刚罗列的复杂度量级，我们可以粗略地分为两类，<strong>多项式量级</strong>和<strong>非多项式量级</strong>。其中，非多项式量级只有两个：O(2n) 和 O(n!)。</p><p>我们把时间复杂度为非多项式量级的算法问题叫作 <strong>NP</strong>（Non-Deterministic Polynomial，非确定多项式）<strong>问题</strong>。</p><p>当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。所以，非多项式时间复杂度的算法其实是非常低效的算法。因此，关于 NP 时间复杂度我就不展开讲了。我们主要来看几种常见的 <strong>多项式时间复杂度</strong>。</p><h4 id="1-O-1"><a href="#1-O-1" class="headerlink" title="1. O(1)"></a>1. O(1)</h4><p>首先你必须明确一个概念，O(1) 只是常量级时间复杂度的一种表示方法，并不是指只执行了一行代码。比如这段代码，即便有 3 行，它的时间复杂度也是 O(1），而不是 O(3)。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i = 8;</span><br><span class="line">int j = 6;</span><br><span class="line">int sum = i + j;</span><br></pre></td></tr></table></figure><p>我稍微总结一下，只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说,<strong>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)</strong>。</p><h4 id="2-O-logn-、O-nlogn"><a href="#2-O-logn-、O-nlogn" class="headerlink" title="2. O(logn)、O(nlogn)"></a>2. O(logn)、O(nlogn)</h4><p>对数阶时间复杂度非常常见，同时也是最难分析的一种时间复杂度。我通过一个例子来说明一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=1;</span><br><span class="line">while (i &lt;= n)  &#123;</span><br><span class="line">  i = i * 2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据我们前面讲的复杂度分析方法，第三行代码是循环执行次数最多的。所以，我们只要能计算出这行代码被执行了多少次，就能知道整段代码的时间复杂度。</p><p>从代码中可以看出，变量 i 的值从 1 开始取，每循环一次就乘以 2。当大于 n 时，循环结束。还记得我们高中学过的等比数列吗？实际上，变量 i 的取值就是一个等比数列。如果我把它一个一个列出来，就应该是这个样子的：</p><p><img src="https://static001.geekbang.org/resource/image/9b/9a/9b1c88264e7a1a20b5954be9bc4bec9a.jpg" alt=""></p><p>所以，我们只要知道 x 值是多少，就知道这行代码执行的次数了。通过 2x=n 求解 x 这个问题我们想高中应该就学过了，我就不多说了。x=log2n，所以，这段代码的时间复杂度就是 O(log2n)。</p><p>现在，我把代码稍微改下，你再看看，这段代码的时间复杂度是多少？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i=1;</span><br><span class="line">while (i &lt;= n)  &#123;</span><br><span class="line">  i = i * 3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据我刚刚讲的思路，很简单就能看出来，这段代码的时间复杂度为 O(log3n)。</p><p>实际上，不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)。为什么呢？</p><p>我们知道，对数之间是可以互相转换的，log3n 就等于 log32 <em> log2n，所以 O(log3n) = O(C </em> log2n)，其中 C=log32 是一个常量。基于我们前面的一个理论：在 <strong>采用大 O 标记复杂度的时候，可以忽略系数，即 O(Cf(n)) = O(f(n))</strong>。所以，O(log2n) 就等于 O(log3n)。因此，在对数阶时间复杂度的表示方法里，我们忽略对数的“底”，统一表示为 O(logn)。</p><p>如果你理解了我前面讲的 O(logn)，那 O(nlogn) 就很容易理解了。还记得我们刚讲的乘法法则吗？如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。</p><h4 id="3-O-m-n-、O-m-n"><a href="#3-O-m-n-、O-m-n" class="headerlink" title="3. O(m+n)、O(m*n)"></a>3. O(m+n)、O(m*n)</h4><p>我们再来讲一种跟前面都不一样的时间复杂度，代码的复杂度由<strong>两个数据的规模</strong>来决定。老规矩，先看代码！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int cal(int m, int n) &#123;</span><br><span class="line">  int sum_1 = 0;</span><br><span class="line">  int i = 1;</span><br><span class="line">  for (; i &lt; m; ++i) &#123;</span><br><span class="line">    sum_1 = sum_1 + i;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  int sum_2 = 0;</span><br><span class="line">  int j = 1;</span><br><span class="line">  for (; j &lt; n; ++j) &#123;</span><br><span class="line">    sum_2 = sum_2 + j;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  return sum_1 + sum_2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中可以看出，m 和 n 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。</p><p>针对这种情况，原来的加法法则就不正确了，我们需要将加法规则改为：T1(m) + T2(n) = O(f(m) + g(n))。但是乘法法则继续有效：T1(m)<em>T2(n) = O(f(m) </em> f(n))。</p><h3 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a><span id="3.0">空间复杂度分析</span></h3><p>前面，咱们花了很长时间讲大 O 表示法和时间复杂度分析，理解了前面讲的内容，空间复杂度分析方法学起来就非常简单了。</p><p>前面我讲过，时间复杂度的全称是<strong>渐进时间复杂度，表示算法的执行时间与数据规模之间的增长关系</strong>。 类比一下，空间复杂度全称就是<strong>渐进空间复杂度</strong>（asymptotic space complexity），<strong>表示算法的存储空间与数据规模之间的增长关系</strong>。</p><p>我还是拿具体的例子来给你说明。（这段代码有点“傻”，一般没人会这么写，我这么写只是为了方便给你解释。）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">void print(int n) &#123;</span><br><span class="line">  int i = 0;</span><br><span class="line">  int[] a = new int[n];</span><br><span class="line">  for (i; i &lt;n; ++i) &#123;</span><br><span class="line">    a[i] = i * i;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  for (i = n-1; i &gt;= 0; --i) &#123;</span><br><span class="line">    print out a[i]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟时间复杂度分析一样，我们可以看到，第 2 行代码中，我们申请了一个空间存储变量 i，但是它是常量阶的，跟数据规模 n 没有关系，所以我们可以忽略。第 3 行申请了一个大小为 n 的 int 类型数组，除此之外，剩下的代码都没有占用更多的空间，所以整段代码的空间复杂度就是 O(n)。</p><p>我们常见的空间复杂度就是 O(1)、O(n)、O(n2 )，像 O(logn)、O(nlogn) 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。所以，对于空间复杂度，掌握刚我说的这些内容已经足够了。</p><h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>基础复杂度分析的知识到此就讲完了，我们来总结一下。</p><p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率越低。常见的复杂度并不多，从低阶到高阶有：O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。等你学完整个专栏之后，你就会发现几乎所有的数据结构和算法的复杂度都跑不出这几个。</p><p><img src="https://static001.geekbang.org/resource/image/49/04/497a3f120b7debee07dc0d03984faf04.jpg" alt=""></p><p><strong>复杂度分析并不难，关键在于多练</strong>。 之后讲后面的内容时，我还会带你详细地分析每一种数据结构和算法的时间、空间复杂度。只要跟着我的思路学习、练习，你很快就能和我一样，每次看到代码的时候，简单的一眼就能看出其复杂度，难的稍微分析一下就能得出答案。</p><h3 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h3><p>有人说，我们项目之前都会进行性能测试，再做代码的时间复杂度、空间复杂度分析，是不是多此一举呢？而且，每段代码都分析一下时间复杂度、空间复杂度，是不是很浪费时间呢？你怎么看待这个问题呢？</p><p>欢迎留言和我分享，我会第一时间给你反馈。</p><h3 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h3><p>复杂度分析法则（<a href="#2.0">时间复杂度</a>，<a href="#2.0">空间复杂度</a>）：</p><p>1）单段代码看高频：比如循环。<br>2）多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。<br>3）嵌套代码求乘积：比如递归、多重循环等<br>4）多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。      </p><p>概念：</p><p>1.<br><a href="#1.0">大O表示法</a><br>    </p><ul><li>来源<br>算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。</li><li>特点<br>以时间复杂度为例，由于时间复杂度描述的是算法执行时间与数据规模的增长变化趋势，所以常量阶、低阶以及系数实际上对这种增长趋势不产决定性影响，所以在做时间复杂度分析时忽略这些项。</li></ul><p><a href="#2.1">加法法则</a><br></p><p>总复杂度等于量级最大的那段代码的复杂度</p><p><a href="#2.2">乘法法则</a> <br></p><p>嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</p><p>多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，<br>O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）</p><p>非多项式阶：非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，<br>O(2^n)（指数阶）、O(n!)（阶乘阶）</p><h5 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h5><p>公式中的低阶、常量、系数三部分并不左右增长趋势，所以都可以忽略。换句话说，就是去掉可控因素，留下不可控因素。<br>这些概念需要多看，记熟。方便以后的阅读理解</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/40036&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章订阅&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;我们都知道，数据结构和算法本身解决的是“快”和“省”的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。那如何来衡量你编写的算法代码的执行效率呢？这里就要用到我们今天要讲的内容：时间、空间复杂度分析。&lt;/p&gt;
&lt;p&gt;其实，只要讲到数据结构与算法，就一定离不开时间、空间复杂度分析。而且，我个人认为，&lt;strong&gt;复杂度分析是整个算法学习的精髓，只要掌握了它，数据结构和算法的内容基本上就掌握了一半&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;复杂度分析实在太重要了，因此我准备用两节内容来讲。希望你学完这个内容之后，无论在任何场景下，面对任何代码的复杂度分析，你都能做到“庖丁解牛”般游刃有余。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://476139183.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="https://476139183.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="进阶" scheme="https://476139183.github.io/tags/%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>02 | 如何抓住重点，系统高效地学习数据结构与算法？</title>
    <link href="https://476139183.github.io/2018/09/29/02-%E5%A6%82%E4%BD%95%E6%8A%93%E4%BD%8F%E9%87%8D%E7%82%B9%EF%BC%8C%E7%B3%BB%E7%BB%9F%E9%AB%98%E6%95%88%E5%9C%B0%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%9F/"/>
    <id>https://476139183.github.io/2018/09/29/02-如何抓住重点，系统高效地学习数据结构与算法？/</id>
    <published>2018-09-29T02:28:15.000Z</published>
    <updated>2018-10-16T07:05:51.689Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://time.geekbang.org/column/article/40011" target="_blank" rel="noopener">文章订阅</a></p><p>你是否曾跟我一样，因为看不懂数据结构和算法，而一度怀疑是自己太笨？实际上，很多人在第一次接触这门课时，都会有这种感觉，觉得数据结构和算法很抽象，晦涩难懂，宛如天书。正是这个原因，让很多初学者对这门课望而却步。</p><p>我个人觉得，其实真正的原因是你 <strong>没有找到好的学习方法</strong>, <strong>没有抓住学习的重点</strong>。实际上，数据结构和算法的东西并不多，常用的、基础的知识点更是屈指可数。只要掌握了正确的学习方法，学起来并没有看上去那么难，更不需要什么高智商、厚底子。</p><a id="more"></a><p>还记得大学里每次考前老师都要划重点吗？今天，我就给你划划我们这门课的重点，再告诉你一些我总结的学习小窍门。相信有了这些之后，你学起来就会有的放矢、事半功倍了。</p><h3 id="什么是数据结构？什么是算法？"><a href="#什么是数据结构？什么是算法？" class="headerlink" title="什么是数据结构？什么是算法？"></a>什么是数据结构？什么是算法？</h3><p>大部分数据结构和算法教材，在开篇都会给这两个概念下一个明确的定义。但是，这些定义都很抽象，对理解这两个概念并没有实质性的帮助，反倒会让你陷入死抠定义的误区。毕竟，我们现在学习，并不是为了考试，所以，概念背得再牢，不会用也就没什么用。</p><p><strong>虽然我们说没必要深挖严格的定义，但是这并不等于不需要理解概念</strong>。  下面我就从广义和狭义两个层面，来帮你理解数据结构与算法这两个概念。</p><p>从广义上讲，数据结构就是指一组数据的存储结构。算法就是操作数据的一组方法。</p><p>图书馆储藏书籍你肯定见过吧？为了方便查找，图书管理员一般会将书籍分门别类进行“存储”。按照一定规律编号，就是书籍这种“数据”的存储结构。</p><p>那我们如何来查找一本书呢？有很多种办法，你当然可以一本一本地找，也可以先根据书籍类别的编号，是人文，还是科学、计算机，来定位书架，然后再依次查找。笼统地说，这些查找方法都是算法。</p><p>图书馆储藏书籍你肯定见过吧？为了方便查找，图书管理员一般会将书籍分门别类进行“存储”。按照一定规律编号，就是书籍这种“数据”的存储结构。</p><p>那我们如何来查找一本书呢？有很多种办法，你当然可以一本一本地找，也可以先根据书籍类别的编号，是人文，还是科学、计算机，来定位书架，然后再依次查找。笼统地说，这些查找方法都是算法。</p><p>从狭义上讲，也就是我们专栏要讲的，是指某些著名的数据结构和算法，比如队列、栈、堆、二分查找、动态规划等。这些都是前人智慧的结晶，我们可以直接拿来用。我们要讲的这些经典数据结构和算法，都是前人从很多实际操作场景中抽象出来的，经过非常多的求证和检验，可以高效地帮助我们解决很多实际的开发问题。</p><p>那数据结构和算法有什么关系呢？为什么大部分书都把这两个东西放到一块儿来讲呢？</p><p>这是因为，数据结构和算法是相辅相成的。<strong>数据结构是为算法服务的，算法要作用在特定的数据结构之上</strong>。  因此，我们无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。</p><p>比如，因为数组具有随机访问的特点，常用的二分查找算法需要用数组来存储数据。但如果我们选择链表这种数据结构，二分查找算法就无法工作了，因为链表并不支持随机访问。</p><p>数据结构是静态的，它只是组织数据的一种方式。如果不在它的基础上操作、构建算法，孤立存在的数据结构就是没用的。</p><p>现在你对数据结构与算法是不是有了比较清晰的理解了呢？有了这些储备，下面我们来看看，究竟该怎么学数据结构与算法。</p><h3 id="学习这个专栏需要什么基础？"><a href="#学习这个专栏需要什么基础？" class="headerlink" title="学习这个专栏需要什么基础？"></a>学习这个专栏需要什么基础？</h3><p>看到数据结构和算法里的“算法”两个字，很多人就会联想到“数学”，觉得算法会涉及到很多深奥的数学知识。那我数学基础不是很好，学起来会不会很吃力啊？</p><p>数据结构和算法课程确实会涉及一些数学方面的推理、证明，尤其是在分析某个算法的时间、空间复杂度的时候，但是这个你完全不需要担心。</p><p>这个专栏不会像《算法导论》那样，里面有非常复杂的数学证明和推理。我会由浅入深，从概念到应用，一点一点给你解释清楚。你只要有高中数学水平，就完全可以学习。</p><p>当然，我希望你最好有些编程基础，如果有项目经验就更好了。这样我给你讲数据结构和算法如何提高效率、如何节省存储空间，你就会有很直观的感受。因为，对于每个概念和实现过程，我都会从实际场景出发，不仅教你“<strong>是什么</strong>”，还会教你“<strong>为什么</strong>”，并且告诉你遇到同类型问题应该“<strong>怎么做</strong>”。</p><h3 id="学习的重点在什么地方？"><a href="#学习的重点在什么地方？" class="headerlink" title="学习的重点在什么地方？"></a>学习的重点在什么地方？</h3><p>提到数据结构和算法，很多人就很头疼，因为这里面的内容实在是太多了。这里，我就帮你梳理一下，应该先学什么，后学什么。你可以对照看看，你属于哪个阶段，然后有针对地进行学习。</p><p>想要学习数据结构与算法，<strong>首先要掌握一个数据结构与算法中最重要的概念——复杂度分析</strong>。</p><p>这个概念究竟有多重要呢？可以这么说，它几乎占了数据结构和算法这门课的半壁江山，是数据结构和算法学习的精髓。</p><p>数据结构和算法解决的是如何更省、更快地存储和处理数据的问题，因此，我们就需要一个考量效率和资源消耗的方法，这就是复杂度分析方法。所以，如果你只掌握了数据结构和算法的特点、用法，但是没有学会复杂度分析，那就相当于只知道操作口诀，而没掌握心法。只有把心法了然于胸，才能做到无招胜有招！</p><p>所以，复杂度分析这个内容，我会用很大篇幅给你讲透。你也一定要花大力气来啃，必须要拿下，并且要搞得非常熟练。否则，后面的数据结构和算法也很难学好。</p><p>搞定复杂度分析，下面就要进入<strong>数据结构与算法的正文内容</strong>了。</p><p>为了让你对数据结构和算法能有个全面的认识，我画了一张图，里面几乎涵盖了所有数据结构和算法书籍中都会讲到的知识点。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fw18kjzrvmj316m2kq14h.jpg" alt=""></p><blockquote><p>（图谱内容较多，建议长按保存后浏览）</p></blockquote><p>但是，作为初学者，或者一个非算法工程师来说，你并不需要掌握图里面的所有知识点。很多高级的数据结构与算法，比如二分图、最大流等，这些在我们平常的开发中很少会用到。所以，你暂时可以不用看。我还是那句话，咱们学习要学会找重点。如果不分重点地学习，眉毛胡子一把抓，学起来肯定会比较吃力。</p><p>所以，结合我自己的学习心得，还有这些年的面试、开发经验，我总结了<strong>20 个最常用的、最基础</strong> 数据结构与算法，<strong>不管是应付面试还是工作需要，只要集中精力逐一攻克这 20 个知识点就足够了</strong>。</p><p>这里面有 10 个数据结构：<br><strong><font color="DarkOrange">数组</font></strong>、<br><strong><font color="DarkOrange">链表</font></strong>、<br><strong><font color="DarkOrange">栈</font></strong>、<br><strong><font color="DarkOrange">队列</font></strong>、<br><strong><font color="DarkOrange">散列表</font></strong>、<br><strong><font color="DarkOrange">二叉树</font></strong>、<br><strong><font color="DarkOrange">堆</font></strong>、<br><strong><font color="DarkOrange">跳表</font></strong>、<br><strong><font color="DarkOrange">图</font></strong>、<br><strong><font color="DarkOrange">Trie 树</font></strong>；</p><p>10 个算法：<br><strong><font color="DarkOrange">递归</font></strong>、<br><strong><font color="DarkOrange">排序</font></strong>、<br><strong><font color="DarkOrange">二分查找</font></strong>、<br><strong><font color="DarkOrange">搜索</font></strong>、<br><strong><font color="DarkOrange">哈希算法</font></strong>、<br><strong><font color="DarkOrange">贪心算法</font></strong>、<br><strong><font color="DarkOrange">分治算法</font></strong>、<br><strong><font color="DarkOrange">回溯算法</font></strong>、<br><strong><font color="DarkOrange">动态规划</font></strong>、<br><strong><font color="DarkOrange">字符串匹配算法</font></strong>。</p><p>掌握了这些基础的数据结构和算法，再学更加复杂的数据结构和算法，就会非常容易、非常快。</p><p>在学习数据结构和算法的过程中，你也要注意，不要只是死记硬背，不要为了学习而学习，而是<strong>要学习它的“来历”“自身的特点”“适合解决的问题”以及“实际的应用场景”</strong>。对于每一种数据结构或算法，我都会从这几个方面进行详细讲解。只要你掌握了我每节课里讲的内容，就能在开发中灵活应用。</p><p>学习数据结构和算法的过程，是非常好的思维训练的过程，所以，千万不要被动地记忆，要多辩证地思考，多问为什么。如果你一直这么坚持做，你会发现，等你学完之后，写代码的时候就会不由自主地考虑到很多性能方面的事情，时间复杂度、空间复杂度非常高的垃圾代码出现的次数就会越来越少。你的编程内功就真正得到了修炼。</p><h3 id="一些可以让你事半功倍的学习技巧"><a href="#一些可以让你事半功倍的学习技巧" class="headerlink" title="一些可以让你事半功倍的学习技巧"></a>一些可以让你事半功倍的学习技巧</h3><p>前面我给你划了学习的重点，也讲了学习这门课需要具备的基础。作为一个过来人，现在我就给你分享一下，专栏学习的一些技巧。掌握了这些技巧，可以让你化被动为主动，学起来更加轻松，更加有动力！</p><h4 id="1-边学边练，适度刷题"><a href="#1-边学边练，适度刷题" class="headerlink" title="1. 边学边练，适度刷题"></a>1. 边学边练，适度刷题</h4><p>“边学边练”这一招非常有用。建议你每周花 1～2 个小时的时间，集中把这周的三节内容涉及的数据结构和算法，全都自己写出来，用代码实现一遍。这样一定会比单纯地看或者听的效果要好很多！</p><p>有面试需求的同学，可能会问了，那我还要不要去刷题呢？</p><p>我个人的观点是<strong>可以“适度”刷题，但一定不要浪费太多时间在刷题上</strong>。我们<strong>学习的目的还是掌握，然后应用</strong>。除非你要面试 Google、Facebook 这样的公司，它们的算法题目非常非常难，必须大量刷题，才能在短期内提升应试正确率。如果是应对国内公司的技术面试，即便是 BAT 这样的公司，你只要彻底掌握这个专栏的内容，就足以应对。</p><h4 id="2-多问、多思考、多互动"><a href="#2-多问、多思考、多互动" class="headerlink" title="2. 多问、多思考、多互动"></a>2. 多问、多思考、多互动</h4><p><strong>学习最好的方法是，找到几个人一起学习，一块儿讨论切磋，有问题及时寻求老师答疑</strong>。 但是，离开大学之后，既没有同学也没有老师，这个条件就比较难具备了。</p><p>不过，这也就是咱们专栏学习的优势。专栏里有很多跟你一样的学习者。你可以多在留言区写下自己的疑问、思考和总结，也可以经常看看别人的留言，和他们进行互动。</p><p>除此之外，如果你有疑问，你可以随时在留言区给我留言，我只要有空就会及时回复你。你不要担心问的问题太小白。因为我初学的时候，也常常会被一些小白问题困扰。不懂一点都不丢人，只要你勇敢提出来，我们一起解决了就可以了。</p><p>我也会力争每节课都最大限度地给你讲透，帮你扫除知识盲点，而你要做的就是，避免一知半解，要想尽一切办法去搞懂我讲的所有内容。</p><h4 id="3-打怪升级学习法"><a href="#3-打怪升级学习法" class="headerlink" title="3. 打怪升级学习法"></a>3. 打怪升级学习法</h4><p><strong>学习的过程中，我们碰到最大的问题就是，坚持不下来</strong>。  是的，很多基础课程学起来都非常枯燥。为此，我自己总结了一套“打怪升级学习法”。</p><p>游戏你肯定玩过吧？为什么很多看起来非常简单又没有乐趣的游戏，你会玩得不亦乐乎呢？这是因为，当你努力打到一定级别之后，每天看着自己的经验值、战斗力在慢慢提高，那种每天都在一点一点成长的成就感就不由自主地产生了。</p><p>所以，<strong>我们在枯燥的学习过程中，也可以给自己设立一个切实可行的目标</strong>，就像打怪升级一样。</p><p>比如，针对这个专栏，你就可以设立这样一个目标：每节课后的思考题都认真思考，并且回复到留言区。当你看到很多人给你点赞之后，你就会为了每次都能发一个漂亮的留言，而更加认真地学习。</p><p>当然，还有很多其他的目标，比如，每节课后都写一篇学习笔记或者学习心得；或者你还可以每节课都找一下我讲得不对、不合理的地方……诸如此类，你可以总结一个适合你的“打怪升级攻略”。</p><p>如果你能这样学习一段时间，不仅能收获到知识，你还会有意想不到的成就感。因为，这其实帮你改掉了一点学习的坏习惯。这个习惯一旦改掉了，你的人生也会变得不一样。</p><h4 id="4-知识需要沉淀，不要想试图一下子掌握所有"><a href="#4-知识需要沉淀，不要想试图一下子掌握所有" class="headerlink" title="4. 知识需要沉淀，不要想试图一下子掌握所有"></a>4. 知识需要沉淀，不要想试图一下子掌握所有</h4><p>在学习的过程中，一定会碰到“拦路虎”。如果哪个知识点没有怎么学懂，不要着急，这是正常的。因为，想听一遍、看一遍就把所有知识掌握，这肯定是不可能的。<strong>学习知识的过程是反复迭代、不断沉淀的过程</strong>。</p><p>如果碰到“拦路虎”，你可以尽情地在留言区问我，也可以先沉淀一下，过几天再重新学一遍。所谓，书读百遍其义自见，我觉得是很有道理的！</p><p>我讲的这些学习方法，不仅仅针对咱们这一个课程的学习，其实完全适用任何知识的学习过程。你可以通过这个专栏的学习，实践一下这些方法。如果效果不错，再推广到之后的学习过程中。</p><h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>今天，我带你划了划数据结构和算法的学习重点，复杂度分析，以及 10 个数据结构和 10 个算法。</p><p>这些内容是我根据平时的学习和工作、面试经验积累，精心筛选出来的。只要掌握这些内容，应付日常的面试、工作，基本不会有问题。</p><p>除此之外，我还给你分享了我总结的一些学习技巧，比如边学边练、多问、多思考，还有两个比较通用的学习方法，打怪升级法和沉淀法。掌握了这些学习技巧，可以让你学习过程中事半功倍。所以，你一定要好好实践哦！</p><h3 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h3><p>今天的内容是一个准备课，从下节开始，我们就要正式开始学习精心筛选出的这 20 个数据结构和算法了。所以，今天给你布置一个任务，对照我上面讲的“打怪升级学习法”，请思考一下你自己学习这个专栏的方法，让我们一起在留言区立下 Flag，相互鼓励！</p><p>另外，你在之前学习数据结构和算法的过程中，遇到过什么样的困难或者疑惑吗？</p><p>欢迎留言和我分享，我会第一时间给你反馈。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/40011&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章订阅&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你是否曾跟我一样，因为看不懂数据结构和算法，而一度怀疑是自己太笨？实际上，很多人在第一次接触这门课时，都会有这种感觉，觉得数据结构和算法很抽象，晦涩难懂，宛如天书。正是这个原因，让很多初学者对这门课望而却步。&lt;/p&gt;
&lt;p&gt;我个人觉得，其实真正的原因是你 &lt;strong&gt;没有找到好的学习方法&lt;/strong&gt;, &lt;strong&gt;没有抓住学习的重点&lt;/strong&gt;。实际上，数据结构和算法的东西并不多，常用的、基础的知识点更是屈指可数。只要掌握了正确的学习方法，学起来并没有看上去那么难，更不需要什么高智商、厚底子。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://476139183.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="https://476139183.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="进阶" scheme="https://476139183.github.io/tags/%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>01 | 为什么要学习数据结构和算法？</title>
    <link href="https://476139183.github.io/2018/09/28/01-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%A6%E4%B9%A0%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95%EF%BC%9F/"/>
    <id>https://476139183.github.io/2018/09/28/01-为什么要学习数据结构和算法？/</id>
    <published>2018-09-28T02:28:05.000Z</published>
    <updated>2018-10-16T06:58:52.787Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://time.geekbang.org/column/article/39922" target="_blank" rel="noopener">文章订阅</a></p><p>你是不是觉得数据结构和算法，跟操作系统、计算机网络一样，是脱离实际工作的知识？可能除了面试，这辈子也用不着？</p><p>尽管计算机相关专业的同学在大学都学过这门课程，甚至很多培训机构也会培训这方面的知识，但是据我了解，很多程序员对数据结构和算法依旧一窍不通。还有一些人也只听说过数组、链表、快排这些最最基本的数据结构和算法，稍微复杂一点的就完全没概念。</p><a id="more"></a><p>当然，也有很多人说，自己实际工作中根本用不到数据结构和算法。所以，就算不懂这块知识，只要 Java API、开发框架用得熟练，照样可以把代码写得“飞”起来。事实真的是这样吗？</p><p>今天我们就来详细聊一聊，为什么要学习数据结构和算法。</p><h3 id="想要通关大厂面试，千万别让数据结构和算法拖了后腿"><a href="#想要通关大厂面试，千万别让数据结构和算法拖了后腿" class="headerlink" title="想要通关大厂面试，千万别让数据结构和算法拖了后腿"></a>想要通关大厂面试，千万别让数据结构和算法拖了后腿</h3><p>很多大公司，比如 BAT、Google、Facebook，面试的时候都喜欢考算法、让人现场写代码。有些人虽然技术不错，但每次去面试都会“跪”在算法上，很是可惜。那你有没有想过，为什么这些大公司都喜欢考算法呢？</p><p>校招的时候，参加面试的学生通常没有实际项目经验，公司只能考察他们的基础知识是否牢固。社招就更不用说了，越是厉害的公司，越是注重考察数据结构与算法这类基础知识。相比短期能力，他们更看中你的长期潜力。</p><p>你可能要说了，我不懂数据结构与算法，照样找到了好工作啊。那我是不是就不用学数据结构和算法呢？当然不是，你别忘了，<strong>我们学任何知识都是为了“用”的，是为了解决实际工作问题的</strong> ，学习数据结构和算法自然也不例外。</p><h3 id="业务开发工程师，你真的愿意做一辈子-CRUD-boy-吗？"><a href="#业务开发工程师，你真的愿意做一辈子-CRUD-boy-吗？" class="headerlink" title="业务开发工程师，你真的愿意做一辈子 CRUD boy 吗？"></a>业务开发工程师，你真的愿意做一辈子 CRUD boy 吗？</h3><p>如果你是一名业务开发工程师，你可能要说，我整天就是做数据库 CRUD（增删改查），哪里用得到数据结构和算法啊？</p><p>是的，对于大部分业务开发来说，我们平时可能更多的是利用已经封装好的现成的接口、类库来堆砌、翻译业务逻辑，很少需要自己实现数据结构和算法。但是，<strong>不需要自己实现，并不代表什么都不需要了解</strong></p><p>如果不知道这些类库背后的原理，不懂得时间、空间复杂度分析，你如何能用好、用对它们？存储某个业务数据的时候，你如何知道应该用 ArrayList，还是 Linked List 呢？调用了某个函数之后，你又该如何评估代码的性能和资源的消耗呢？</p><p>作为业务开发，我们会用到各种框架、中间件和底层系统，比如 Spring、RPC 框架、消息中间件、Redis 等等。<strong>在这些基础框架中，一般都揉和了很多基础数据结构和算法的设计思想</strong>。</p><p>比如，我们常用的 Key-Value 数据库 Redis 中，里面的有序集合是用什么数据结构来实现的呢？为什么要用跳表来实现呢？为什么不用二叉树呢？</p><p>如果你能弄明白这些底层原理，你就能更好地使用它们。即便出现问题，也很容易就能定位。因此，<strong>掌握数据结构和算法，不管对于阅读框架源码，还是理解其背后的设计思想，都是非常有用的</strong>。</p><p>在平时的工作中，数据结构和算法的应用到处可见。我来举一个你非常熟悉的例子：如何实时地统计业务接口的 99% 响应时间？</p><p>你可能最先想到，每次查询时，从小到大排序所有的响应时间，如果总共有 1200 个数据，那第 1188 个数据就是 99% 的响应时间。很显然，每次用这个方法查询的话都要排序，效率是非常低的。但是，如果你知道“堆”这个数据结构，用两个堆可以非常高效地解决这个问题。</p><h3 id="基础架构研发工程师，写出达到开源水平的框架才是你的目标！"><a href="#基础架构研发工程师，写出达到开源水平的框架才是你的目标！" class="headerlink" title="基础架构研发工程师，写出达到开源水平的框架才是你的目标！"></a>基础架构研发工程师，写出达到开源水平的框架才是你的目标！</h3><p>现在互联网上的技术文章、架构分享、开源项目满天飞，照猫画虎做一套基础框架并不难。我就拿 RPC 框架举例。</p><p>不同的公司、不同的人做出的 RPC 框架，架构设计思路都差不多，最后实现的功能也都差不多。但是有的人做出来的框架，Bug 很多、性能一般、扩展性也不好，只能在自己公司仅有的几个项目里面用一下。而有的人做的框架可以开源到 GitHub 上给很多人用，甚至被 Apache 收录。为什么会有这么大的差距呢？</p><p>我觉得，高手之间的竞争其实就在细节。这些细节包括：你用的算法是不是够优化，数据存取的效率是不是够高，内存是不是够节省等等。这些累积起来，决定了一个框架是不是优秀。所以，如果你还不懂数据结构和算法，没听说过大 O 复杂度分析，不知道怎么分析代码的时间复杂度和空间复杂度，那肯定说不过去了，赶紧来补一补吧！</p><h3 id="对编程还有追求？不想被行业淘汰？那就不要只会写凑合能用的代码！"><a href="#对编程还有追求？不想被行业淘汰？那就不要只会写凑合能用的代码！" class="headerlink" title="对编程还有追求？不想被行业淘汰？那就不要只会写凑合能用的代码！"></a>对编程还有追求？不想被行业淘汰？那就不要只会写凑合能用的代码！</h3><p>何为编程能力强？是代码的可读性好、健壮？还是扩展性好？我觉得没法列，也列不全。但是，在我看来，<strong>性能好坏起码是其中一个非常重要的评判标准</strong> 。但是，如果你连代码的时间复杂度、空间复杂度都不知道怎么分析，怎么写出高性能的代码呢？</p><p>你可能会说，我在小公司工作，用户量很少，需要处理的数据量也很少，开发中不需要考虑那么多性能的问题，完成功能就可以，用什么数据结构和算法，差别根本不大。但是你真的想“十年如一日”地做一样的工作吗？</p><p>经常有人说，程序员 35 岁之后很容易陷入瓶颈，被行业淘汰，我觉得原因其实就在此。有的人写代码的时候，从来都不考虑非功能性的需求，只是完成功能，凑合能用就好；做事情的时候，也从来没有长远规划，只把眼前事情做好就满足了。</p><p>我曾经面试过很多大龄候选人，简历能写十几页，经历的项目有几十个，但是细看下来，每个项目都是重复地堆砌业务逻辑而已，完全没有难度递进，看不出有能力提升。久而久之，十年的积累可能跟一年的积累没有任何区别。这样的人，怎么不会被行业淘汰呢？</p><p>如果你在一家成熟的公司，或者 BAT 这样的大公司，面对的是千万级甚至亿级的用户，开发的是 TB、PB 级别数据的处理系统。性能几乎是开发过程中时刻都要考虑的问题。一个简单的 ArrayList、Linked List 的选择问题，就可能会产生成千上万倍的性能差别。这个时候，数据结构和算法的意义就完全凸显出来了。</p><p>其实，我觉得，数据结构和算法这个东西，如果你不去学，可能真的这辈子都用不到，也感受不到它的好。但是一旦掌握，你就会常常被它的强大威力所折服。之前你可能需要费很大劲儿来优化的代码，需要花很多心思来设计的架构，用了数据结构和算法之后，很容易就可以解决了。</p><h3 id="内容小结"><a href="#内容小结" class="headerlink" title="内容小结"></a>内容小结</h3><p>我们学习数据结构和算法，并不是为了死记硬背几个知识点。我们的目的是建立时间复杂度、空间复杂度意识，写出高质量的代码，能够设计基础架构，提升编程技能，训练逻辑思维，积攒人生经验，以此获得工作回报，实现你的价值，完善你的人生。</p><p>所以，不管你是业务开发工程师，还是基础架构工程师；不管你是初入职场的初级工程师，还是工作多年的资深架构师，又或者是想转人工智能、区块链这些热门领域的程序员，数据结构与算法作为计算机的基础知识、核心知识，都是必须要掌握的。</p><p><strong>掌握了数据结构与算法，你看待问题的深度，解决问题的角度就会完全不一样</strong> 。因为这样的你，就像是站在巨人的肩膀上，拿着生存利器行走世界。数据结构与算法，会为你的编程之路，甚至人生之路打开一扇通往新世界的大门。</p><h3 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h3><p>你为什么要学习数据结构和算法呢？在过去的软件开发中，数据结构和算法在哪些地方帮到了你？</p><p>欢迎留言和我分享，我会第一时间给你反馈。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/39922&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章订阅&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你是不是觉得数据结构和算法，跟操作系统、计算机网络一样，是脱离实际工作的知识？可能除了面试，这辈子也用不着？&lt;/p&gt;
&lt;p&gt;尽管计算机相关专业的同学在大学都学过这门课程，甚至很多培训机构也会培训这方面的知识，但是据我了解，很多程序员对数据结构和算法依旧一窍不通。还有一些人也只听说过数组、链表、快排这些最最基本的数据结构和算法，稍微复杂一点的就完全没概念。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://476139183.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="https://476139183.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="进阶" scheme="https://476139183.github.io/tags/%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>《Weex》初探</title>
    <link href="https://476139183.github.io/2018/09/27/%E3%80%8AWeex%E3%80%8B%E5%88%9D%E6%8E%A2/"/>
    <id>https://476139183.github.io/2018/09/27/《Weex》初探/</id>
    <published>2018-09-27T02:56:53.000Z</published>
    <updated>2018-12-19T07:59:51.211Z</updated>
    
    <content type="html"><![CDATA[<ul><li><a href="http://weex.apache.org/cn/guide/" target="_blank" rel="noopener">Weex</a> 是2016年6月由阿里巴巴推出的一个动态化的高扩展跨平台解决方案，可以类比一下React Native,能够完美的兼容性能与动态性，让移动开发者通过简捷前端语法写出原生级别的性能体验,目前支持iOS、安卓及Web等多端开发部署。weex主要解决的是频繁发版和多端研发两大痛点，同时又解决了前端语言性能差和显示效果受限的问题，极大地解放开发者的同时又保证了用户体验。</li><li>同年12月捐赠给Apache。</li><li>Weex 号称<code>一次编写 处处运行</code> 积极拥抱 Web 标准，专注于 Native 渲染层优化的细致工作，也清晰地展示了这个项目的自身定位和发展方向</li></ul><a id="more"></a><p>–</p><ul><li>搭载 Node 基础环境        </li><li>可以直接在浏览器中调试JS代码,需要一些<a href="http://es6.ruanyifeng.com" target="_blank" rel="noopener">ES6基础</a></li><li>基于<a href="https://cn.vuejs.org/v2/guide/" target="_blank" rel="noopener">Vue.js</a></li><li>我使用的<code>Atom</code> 插件<br><code>language-vue-component</code><br><code>language-weex</code></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h4 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h4><h5 id="Homebrew"><a href="#Homebrew" class="headerlink" title="Homebrew"></a><a href="https://brew.sh" target="_blank" rel="noopener">Homebrew</a></h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><h5 id="使用Homebrew来安装Node-js"><a href="#使用Homebrew来安装Node-js" class="headerlink" title="使用Homebrew来安装Node.js"></a>使用Homebrew来安装<a href="https://nodejs.org/en/" target="_blank" rel="noopener"><code>Node.js</code></a></h5><p><code>brew install node</code>    </p><p>安装完 node 后建议设置 npm 镜像以加速后面的过程（或使用科学上网工具）。注意：不要使用cnpm！cnpm安装的模块路径比较奇怪，packager不能正常识别！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org --global</span><br><span class="line">npm config set disturl https://npm.taobao.org/dist --global</span><br></pre></td></tr></table></figure><p>(这里需要是用 npm 还是 yarn 可以去 react native 官网 看看 )</p><h4 id="然后全局安装-weex-toolkit"><a href="#然后全局安装-weex-toolkit" class="headerlink" title="然后全局安装 weex-toolkit"></a>然后全局安装 <code>weex-toolkit</code></h4><p><code>npm install weex-toolkit -g</code></p><p>cd 到文件夹 创建项目<br><code>weex create awesome-app</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">? May weex-toolkit anonymously report usage statistics to improve the tool over</span><br><span class="line">time? Yes</span><br><span class="line">? Which npm registry you perfer to use? taobao</span><br><span class="line">? Project name newproject</span><br><span class="line">? Project description new</span><br><span class="line">? Author duanyutian</span><br><span class="line">? Select weex web render lts</span><br><span class="line">? Babel compiler (https:<span class="comment">//babeljs.io/docs/plugins/#stage-x-experimental-presets)</span></span><br><span class="line"> stage<span class="number">-0</span></span><br><span class="line">? Use vue-router to manage your view router? (not recommended) No</span><br><span class="line">? Use ESLint to lint your code? Yes</span><br><span class="line">? Pick an ESLint preset Standard</span><br><span class="line">? Set up unit tests No</span><br><span class="line">? Should we run `npm install` <span class="keyword">for</span> you after the project has been created? (recom</span><br><span class="line">mended) yarn</span><br></pre></td></tr></table></figure><blockquote><p>Ps:已经安装了 yarn 使用 yarn 否则使用 npm ,同理下面的命令行也是(因为之前看了rect native 的安装，所以建议使用yarn)</p></blockquote><h3 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd awesome-app</span><br><span class="line">yarn install</span><br><span class="line">yarn start</span><br></pre></td></tr></table></figure><h3 id="iOS"><a href="#iOS" class="headerlink" title="iOS"></a>iOS</h3><p>weex platform add ios    </p><p>&lt;&lt; <code>if</code> 网速够好 可以直接 weex run ios &gt;&gt;<br>&lt;&lt; <code>else</code> 到platforms/ios目录下为ios工程用cocoaPods安装第三方依赖，这里ios工程需要安装的依赖可以打开ios目录下的Podfile文件查看,如下（修改版本为0.17.0）</p><p><img src="/2018/09/27/《Weex》初探/11.jpg" alt="图一"> </p><p> 。。<br>好了，接下来用pod命令对这些依赖进行安装，cd 到 ios 目录，pod install就可以了，前提是要先安装好cocoaPods，ios开发对它都比较熟悉，这个网上有很多教程。还有如果pod库很久没有更新的话很可能会安装失败，因为找不到上图中新版本的weex相关的库，建义pod setup，pod update更新一下库。这个最好翻-墙操作，否则会等很久。如果之前更新过pod，那使用 pod install –no-repo-update 安装会更快。安装好后如下：   （使用pod update –no-repo-update –verbose 来代替 pod update）&gt;&gt;    </p><p><img src="/2018/09/27/《Weex》初探/12.jpg" alt="图二">      </p><ol start="5"><li>再回到weex根目录，启动ios 模拟器</li></ol><p>　　weex run ios</p><p>　　这一行命令下去，会先启动weex的webpack服务，即它在浏览器中打开，同时又弹出另一个命令行，显示蓝色字，如下。     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=&gt; Will start iOS app</span><br><span class="line">=&gt; pod update</span><br></pre></td></tr></table></figure><p>　　这个时候就静静等着就好，然后会出来选择模拟器界面，如下<br>　　<br>　　<img src="/2018/09/27/《Weex》初探/13.jpg" alt="图三">        </p><p>6.我选择了一个iphonex模拟器，启动后如下图，和pc上浏览器上显示内容一样     </p><p><img src="/2018/09/27/《Weex》初探/14.jpg" alt="图四">    </p><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><p>优点：</p><ol><li>跨平台 一套代码多端运行</li><li>远程部署</li><li>加载网页更加流畅 功能更加强大</li><li>相比其他跨平台，门槛相对要低</li></ol><p>缺点： </p><blockquote><p>跨平台通病:     </p></blockquote><ol><li>用户体验不如原生的完美     </li><li>开源库不如原生的丰富，完成复杂的功能比较困难</li><li>缺少安全性 类型难以扩展、重构易出错</li><li>每一次原生或者 weex 内嵌的第三方的变动都需要 weex 先更新，适配，然后才到原生支持。</li></ol><blockquote><p>Weex 缺点:    </p></blockquote><ol><li>不好debug，没有客户端调试工具，而web页调试和实际显示效果可能会有偏差    </li><li>css 不是是所有的都支持 比如 <code>border-width:50%</code> 被解读成50px     </li><li>本地资源文件读取各端都不一样，需要各端分别配置      </li><li>开源社区不活跃，项目由apache开发，文档却是阿里编写，文档简单且更新慢， demo bug 多     </li><li>weex有web组件支持显示web端。但是没有提供任何交互API，也没办法拦截     </li><li>在Github上主要贡献人员以阿里为主，额外贡献人很少， 目前已交由apache维护，但是官方文档还是由阿里编写，文档更新很慢，demo bug 较多。而且目前社区规模较少</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><center>总结</center></h2><p>感觉weex的生态环境有点类似 <code>Windows Phone</code>, <code>Windows Phone</code>号称第三大手机系统，由微软推出，在出来的时候 我也买了华为 WP1，动态磁贴很不错，系统比较整洁，但是直到WP2 才支持内存卡存储。但是应用市场app很少，且功能简单，开发者也不活跃，微软也没有太多作为，到现在都没落了。</p><p>目前其实还不太适合全面开发，生态环境不够稳定，开源社区活跃度不够。</p><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>　　自从Weex出生的那一天起，就无法摆脱和<a href="https://reactnative.cn" target="_blank" rel="noopener">React Native</a>相互比较的命运。React Native宣称“Learn once, write anywhere”，而Weex宣称“Write Once, Run Everywhere”。Weex从出生那天起，就被给予了一统三端的厚望。React Native可以支持iOS、Android，而Weex可以支持iOS、Android、HTML5。</p><p>　　在Native端，两者的最大的区别可能就是在对JSBundle是否分包。React Native官方只允许将React Native基础JS库和业务JS一起打成一个JS bundle，没有提供分包的功能，所以如果想节约流量就必须制作分包打包工具。而Weex默认打的JS bundle只包含业务JS代码，体积小很多，基础JS库包含在Weex SDK中，这一点Weex与Facebook的React Native和微软的Cordova相比，Weex更加轻量，体积小巧。在JS端，Weex又被人称为Vue Native，所以 React Native 和 Weex 的区别就在 React 和 Vue 两者上了。　　</p><h4 id="使用过程"><a href="#使用过程" class="headerlink" title="使用过程"></a>使用过程</h4><ul><li>单页面中，web通过前进 回退按钮切换界面，而在客户端 weex提供<a href="http://weex.apache.org/cn/references/modules/navigator.html" target="_blank" rel="noopener">navigator</a>组件实现类似的效果，并内置了动画效果。但这个组件对web端无效</li><li>多页面中，weex可以使用路由器<code>vue-router</code>进行界面跳转，iOS、Android、Web 三端适用 </li><li>遗憾的是这两个组件不能同时使用，也就是无法实现客户端上面的Tabbar+navigationbar 的布局，所以需要使用自定义一个组件来替换<code>vue-router</code>.</li><li>文档简单到只能让人写一个demo 很多东西一笔带过</li><li>每一次运行客户端都需要等待大量时间，还非常依赖网速，一旦网速不行 超时就无法运行成功。</li><li>我在编写的时候 很多都无法全部填充 <code>flex:1</code> 感觉有的时候没有效果，比如我在web上可以看到全部填充，list组件显示，但是在模拟器上效果不一样</li><li>本地资源文件读取这个是重点，各端路径不一致，而官网语焉不详</li></ul><h2 id="关于Weex与iOS开发者的思考"><a href="#关于Weex与iOS开发者的思考" class="headerlink" title="关于Weex与iOS开发者的思考"></a>关于Weex与iOS开发者的思考</h2><ol><li>不同的开发模式</li></ol><p>从去年开始，移动端的开发模式就有很多更新，包括ionic（就是后来的cordova），React Native，今年开源的Weex，原生+网页，当然最传统的还是原生开发方式。新技术是因为新需要，跨平台和混合的方式确实解决了部分的效率问题。由于公司需要我最近也研究了一下。感触颇深</p><blockquote><p>在最开始，你会觉得未来如此美丽，我还需要写原生吗？我还需要多平台吗？不用了！前端搞定一切！但是当你真的了解了之后发现并不是这样的。你需要解决的事情太多了。</p></blockquote><p>RN的复杂，就不说React本来就很复杂，JSX的语法我个人感觉有点说不出来的头痛，恕我技穷，我都找不到一个完美支持代码补全的合适的IDE。Redux把本来很简单的事情搞的相当复杂，Action Reducer…</p><p>ionic 的存在表示很尴尬，外壳包着web。。我浏览器，微信公众号就搞定了，还需要你的外壳吗？？</p><p>原生+网页。倒是很灵活，貌似也解决不了跨平台的效率问题。。不过对于大公司倒是一切都不是问题。</p><p>最后说道Weex ，</p><p>是我迄今为止看到的比较完美的解决方案。上手简单。与普通的前端开发衔接顺畅，但是毕竟开源不久，第三方组件和库都不是非常完整，而且据说阿里的开源项目一般都XXX(此处省略一万字)。对于原生开发者来说，有很多优势，语法简单，虽然砍掉了一些web的原生支持的方法，比如一些css样式，适配也仅仅是把width固定位750px，所有其他屏幕都是按比例缩放，选择器只支持类，而且没有子代选择。有些控件 比如a，p，这些标签也砍掉了，虽然对比完整的额web开发，少了灵活性，但是这无形中也给一些原生开发者带来了便利。上手更简单了，不用考虑那么多了。有利有弊。对于原生开发者倒是很值得一试，就当web入门了也行。</p><p>对了，weex是基于vue的，vue的易用性在web开发中可见一斑。</p><p>其实现在最担心的就是weex后期的维护，希望能把上面漏掉的一些web的东西都补起来。希望他能经得起时间的考验吧！</p><p>当然听说 <a href="https://flutter-io.cn" target="_blank" rel="noopener">Flutter</a>的体验和生态更好，可以去试试了</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><h4 id="学习链接"><a href="#学习链接" class="headerlink" title="学习链接"></a>学习链接</h4><p><a href="https://www.jianshu.com/p/497f1a9ff33f" target="_blank" rel="noopener">《Weex 踩坑攻略》</a></p><p><a href="https://www.cnblogs.com/saytome/p/7205132.html" target="_blank" rel="noopener">《Weex 二》</a></p><p><a href="https://blog.csdn.net/qianqianyihao/article/details/76037543" target="_blank" rel="noopener">《Weex 入门》</a></p><p><a href="https://www.weexdaxue.com" target="_blank" rel="noopener">《Weex 学院》</a></p><p><a href="https://github.com/alibaba/weex" target="_blank" rel="noopener">《Weex GitHub》</a></p><p><a href="https://github.com/ShowJoy-com/showjoy-blog/labels/weex" target="_blank" rel="noopener">《Weex Blog》</a></p><p><a href="https://www.jianshu.com/c/f152a6d31479" target="_blank" rel="noopener">《Weex 简书》</a></p><p><a href="http://www.cocoachina.com/programmer/20171013/20790.html?utm_source=debugrun&amp;utm_medium=referral" target="_blank" rel="noopener">网易严选</a></p><p><a href="https://yq.aliyun.com/articles/57995" target="_blank" rel="noopener">云栖社区</a></p><p><a href="http://www.chungold.com/course/3" target="_blank" rel="noopener">Weex 视频</a></p><p><a href="https://segmentfault.com/a/1190000007560611" target="_blank" rel="noopener">关于Weex 的一些知识</a></p><p><a href="http://jspang.com/tag/weex" target="_blank" rel="noopener">技术胖的博客</a></p><h4 id="相关框架"><a href="#相关框架" class="headerlink" title="相关框架"></a>相关框架</h4><p><a href="https://zhuanlan.zhihu.com/p/38905196" target="_blank" rel="noopener">EROS</a></p><p><a href="https://blog.csdn.net/hopeyouknow/article/details/51800715" target="_blank" rel="noopener">调试框架</a></p><p><a href="https://www.jianshu.com/p/bccad91fc327" target="_blank" rel="noopener">Weex入门教学 (iOS端读取js ,拦截点击)</a></p><p><a href="https://www.jianshu.com/p/f842811bd895" target="_blank" rel="noopener">现有iOS集成weex</a></p><p><a href="https://alibaba.github.io/weex-ui/#/cn/" target="_blank" rel="noopener">Weex Ui 半年开源之路</a></p>]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://weex.apache.org/cn/guide/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Weex&lt;/a&gt; 是2016年6月由阿里巴巴推出的一个动态化的高扩展跨平台解决方案，可以类比一下React Native,能够完美的兼容性能与动态性，让移动开发者通过简捷前端语法写出原生级别的性能体验,目前支持iOS、安卓及Web等多端开发部署。weex主要解决的是频繁发版和多端研发两大痛点，同时又解决了前端语言性能差和显示效果受限的问题，极大地解放开发者的同时又保证了用户体验。&lt;/li&gt;
&lt;li&gt;同年12月捐赠给Apache。&lt;/li&gt;
&lt;li&gt;Weex 号称&lt;code&gt;一次编写 处处运行&lt;/code&gt; 积极拥抱 Web 标准，专注于 Native 渲染层优化的细致工作，也清晰地展示了这个项目的自身定位和发展方向&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>是它，是它，就是它！ ---- 《小丑回魂》</title>
    <link href="https://476139183.github.io/2018/09/25/%E6%98%AF%E5%AE%83%EF%BC%8C%E6%98%AF%E5%AE%83%EF%BC%8C%E5%B0%B1%E6%98%AF%E5%AE%83%EF%BC%81/"/>
    <id>https://476139183.github.io/2018/09/25/是它，是它，就是它！/</id>
    <published>2018-09-25T08:29:09.000Z</published>
    <updated>2018-10-08T09:46:18.965Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>二零一七年九月份，北美炸出一部现象级电影，一举打破北美九月份票房影史纪录，完全碾压之前开启招魂恐怖电影宇宙的《安娜贝尔2》！成本仅3500万美元，上映两周票房已跻身R级恐怖片影史第三。影片改编自恐怖大师史蒂芬·金的同名作品，名字只有一个字：它（It）。</p></blockquote><p>是它，是它，就是它！2017年度恐怖最佳！</p><a id="more"></a><p>《小丑回魂》，英文名It，原译“它”，<code>从英文直译角度来说，更让人浮想联翩：这部恐怖片面对的是什么“鬼”</code>。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvm5gl3jsij30go0am0uv.jpg" alt=""></p><p>影片改编自恐怖大师 <em>史蒂芬·金</em>（<code>著有肖申克的救赎，魔女嘉莉，迷雾，1408幻影凶间等</code>）1986年的同名经典小说，一经上映便成黑马，打破多项票房纪录：</p><h3 id="北美恐怖片票房首映日影史最高，9月北美票房影史最高……"><a href="#北美恐怖片票房首映日影史最高，9月北美票房影史最高……" class="headerlink" title="北美恐怖片票房首映日影史最高，9月北美票房影史最高……"></a>北美恐怖片票房首映日影史最高，9月北美票房影史最高……</h3><p>从9月8日公映至今，评分人数已超8万人，IMDb评分仍保持8.0分。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm5h2zhizj30fq05hmxq.jpg" alt=""></p><p>就是这货：</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvm5hwg11wg307z03r1kx.gif" alt=""></p><blockquote><p> 放慢0.5倍速，截自预告</p></blockquote><p>烂番茄85分，Metacritic70分，都表现不俗。但你要知道，在IMDb，评分过7的恐怖片就是佳作，评分超8分，人数超2.5万人的恐怖片更<em>不超过20部</em>。恐怖类型片下，《小丑回魂》<em>跻身第五</em>，排在它前面的是两部经典：[闪灵]和[怪形]（[闪灵]也是根据史蒂芬·金小说改编）。</p><p>作为一部成本仅3500万美元的R级恐怖片，《小丑回魂》票房现在已挤进<em>影史第三</em>。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvm5imnbw7j30gb0g90uq.jpg" alt=""></p><p>别猜了，第一是[异形]，第二是希胖的[精神病患者]</p><p><a href="https://baike.baidu.com/tashuo/authorcenter?authorId=465f421a9dfba9bbf1492220" target="_blank" rel="noopener"> 秋裤 </a>(本文作者)是恐怖片变态级粉丝，刷完长篇巨制的原著和90年代的剧集之后，今天跟大家解析下这个票房和口碑都爆炸的“它”。</p><h2 id="小丑"><a href="#小丑" class="headerlink" title="小丑"></a>小丑</h2><h3 id="来自超级宇宙的死光"><a href="#来自超级宇宙的死光" class="headerlink" title="来自超级宇宙的死光"></a>来自超级宇宙的死光</h3><h3 id="故事简介"><a href="#故事简介" class="headerlink" title="故事简介"></a>故事简介</h3><h4 id="德里镇儿童失踪案"><a href="#德里镇儿童失踪案" class="headerlink" title="德里镇儿童失踪案"></a>德里镇儿童失踪案</h4><p>故事发生在虚构的缅因州小镇德里（Derry），它已经被诡异的恐怖事件笼罩了上百年。</p><p>这些诡异的恐怖事件就是神秘的儿童失踪案。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvm5kxhzdjg307s030awu.gif" alt=""></p><blockquote><p>预告</p></blockquote><p>男主弟弟乔治·邓布洛的失踪是影片故事的开端，这也是原著中开篇经典场景，预告中就可以看到：</p><p>雨中乔治拿着哥哥威廉做的纸船玩耍，而纸船SS.乔治号顺着水流坠入下水管道。</p><p>在下水管道中，乔治遇到了自称潘尼歪斯Pennywise（又译“小气鬼”）的小丑。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvm5liydcrg306v02p7rn.gif" alt=""></p><blockquote><p>预告</p><blockquote><p>小丑演员：<br><code>比尔.斯科斯佳</code>,<code>导演需要小丑翻白眼，但这不是一般的眼珠子往上翻这么简单，而是需要两个眼珠子分别往左右方向翻</code>.本来导演说做特效完成，但<code>比尔.斯科斯佳</code>说不需要，因为他居然能做到两个眼珠子往左右不同方向翻白眼。这真是#@*&amp;%牛^#B啊。</p></blockquote></blockquote><p>诡异的不是孩子的失踪，而是留下的<code>被肢解的尸体</code>。乔治胳膊被撕下，有的遇难者的遗体甚至散落各处。影片开始不到5分钟就呈现了这个经典的场景，不少观众寒毛竖起。</p><p>和镇上一些其他孩子一样，哥哥威廉开始看到可怕的东西，原著中有的孩子看到巨型飞鸟，有的看到木乃伊和狼人，这些元素在影片中被改编，成为致敬的彩蛋。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvm5lu74e4j30ga08rq3d.jpg" alt=""></p><blockquote><p>预告中小丑变化出狼人的手</p></blockquote><p>小女孩贝弗莉从盥洗池中听到失踪的孩子的惨叫，靠近去听却看到鲜血喷涌，这是原著中最惊悚的场景之一，在影片中被完美呈现。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm5mbj8shg307o0337e2.gif" alt=""></p><blockquote><p>预告</p></blockquote><p>然而最让人恐惧的还不是这怪异的血崩，而是所有的大人对此都视而不见。想象一下，你眼睁睁的看着亲人用鲜血淋漓的洗手槽洗脸是什么样的感受？</p><p>[小丑回魂]的恐惧来源于<code>未知与无助</code>——最能给你安全感的人对你的恐惧的无视。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm5mbj8shg307o0337e2.gif" alt=""></p><blockquote><p>小丑回魂1990</p></blockquote><h4 id="窝囊废联盟Losers’-Club"><a href="#窝囊废联盟Losers’-Club" class="headerlink" title="窝囊废联盟Losers’ Club"></a>窝囊废联盟Losers’ Club</h4><p>Losers’ Club是影片主角，有些翻译成“失败者俱乐部”，但感觉还是国内早期原版翻译的比较好——窝囊废联盟。</p><p>小镇上无数的孩子被这种恐怖折磨。其中有7个孩子，命中注定要走到一起，他们就是窝囊废联盟Loser’s club。</p><p>可以看到石膏上写的Loser（窝囊废）字样，但被改成Lover（情人），原著中他们都在埃迪手臂的石膏上签名，代表着联盟的约定与承诺。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm5p5oc8og308h03j7sm.gif" alt=""></p><blockquote><p>预告</p></blockquote><p>他们是德里镇最普通的孩子，是每个成年人曾经的自己。</p><p>他们有的出生在贫民区，有的被同学骂作肥猪，有的被大孩子欺负，而欺负他们的人称他们为窝囊废Loser，这是原著中他们名字的由来。但他们长大后都很成功，绝不是什么窝囊废或失败者。</p><p>他们在暑假相遇，尽情的玩耍，终于，他们都谈到自己看到的恐怖形象。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvm5pu1ekqg30cn056hdt.gif" alt=""></p><blockquote><p>预告</p></blockquote><p>虽然每个人看到的景象各不相同，但恐怖之源都指向同一个东西—— <code>它（it）</code>，也就是乔治的弟弟在下水管道中看到潘尼歪斯小丑。</p><p>也就是乔治的弟弟在下水管道中看到 <code>潘尼歪斯小丑</code>。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvm5qgjaaqg30gm0bc7g6.gif" alt=""></p><blockquote><p>预告</p></blockquote><p>七个人袒露心扉，成为挚友，互相支持，他们组成了窝囊废联盟，决定和这个魔鬼小丑战斗到底。</p><p>然而事情并没有这么简单。</p><h4 id="潘尼歪斯小丑"><a href="#潘尼歪斯小丑" class="headerlink" title="潘尼歪斯小丑"></a>潘尼歪斯小丑</h4><p>如何击败小丑，窝囊废联盟毫无头绪。他们甚至不知道这个东西到底是什么，只好管它叫做</p><p><code>“它”</code>。</p><p>窝囊废联盟发现不仅孩子们饱受它的折磨，整个小镇都被它玩弄鼓掌，而且玩弄了很久，至少有 <code>200年</code> 。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm5qrrx5sj30q90ao3zr.jpg" alt=""></p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvm5qy1xu9j30qc0al0tj.jpg" alt=""></p><blockquote><p>预告，小胖墩本在德里史料中发现久远的意外事件</p></blockquote><p>从1900年，这个恶魔就开始吞噬德里。他们发现，<code>每过27年</code>，德里的失踪案和死亡率就会出现一个峰值。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm5shfh71g308203uwsd.gif" alt=""></p><blockquote><p>预告</p></blockquote><p>更令人感到脊背发凉的是，2017年版的[小丑回魂]和1990年版相隔27年，1990年版男主角威廉的扮演者乔纳森·布兰迪斯于2003年自杀身亡，正好也是27岁。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvm5ss6mzdj30co063jrx.jpg" alt=""></p><blockquote><p>乔纳森·布兰迪斯</p></blockquote><p>2017年版的小丑扮演者比尔·斯卡斯加德现在也是27岁。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvm5t04wdbj30i408t75b.jpg" alt=""></p><blockquote><p>比尔·斯卡斯加德</p></blockquote><p>小丑似乎从小镇建立之日起就一直存在，每隔27年，它就会重返人间，残害儿童，更吞噬这个小镇。</p><p>窝囊废联盟的7个孩子决定站出来，和这个东西决斗，不管它是什么……</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvm5tjlwahg307x04n4ly.gif" alt=""></p><blockquote><p>预告</p></blockquote><h3 id="小丑来自何方？"><a href="#小丑来自何方？" class="headerlink" title="小丑来自何方？"></a>小丑来自何方？</h3><p>和[蝙蝠侠]中的小丑Joker一样，潘尼歪斯小丑已经成为一个经典形象。第一部大获成功，[小丑回魂II]已经板上钉钉，第一部中许多疑问将在第二部中揭开，其中最大的疑问就是小丑的身世。</p><p>小丑之所以这么令人恐惧，也是来自他神秘的身世，显然，它在德里已经存在了很久很久。  </p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm5tss5iwj30nt09u75d.jpg" alt=""></p><blockquote><p>预告</p></blockquote><h4 id="吞噬德里镇两百年"><a href="#吞噬德里镇两百年" class="headerlink" title="吞噬德里镇两百年"></a>吞噬德里镇两百年</h4><p>影片中，小胖墩本通过简报发现小丑其实已经在德里镇存在了200多年，在小镇历史上无数的意外和死亡事件中，都有潘尼歪斯的身影。</p><p>比如发生在1906年复活节的 <code>钢铁厂爆炸事件</code> ：102人死亡，其中88人为儿童。</p><p>现场有人目击到小丑。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm5u1kgwhj30qc0al0tj.jpg" alt=""></p><blockquote><p>预告</p></blockquote><p>比如27年后的 <code>黑点酒吧大火</code>，黑人男孩麦克的父亲就目睹了整个事件。</p><p>麦克的父亲看到了小丑。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvm5uhqsaig308q04ktjn.gif" alt=""></p><blockquote><p>预告</p></blockquote><p>镇上的许多大人也都见过小丑，但他们都闭口不谈，选择遗忘，比如麦克的父亲，直到临死前才告诉儿子，大火的那一天，他看到天空中有一只巨鸟，就像后来麦克看到的一样。</p><p>它不是在飞，而是悬停在空中，它在 <code>飘</code>，而它的翅膀上还绑着 <code>气球</code>。</p><blockquote><blockquote><p>“它没有停在空中，”他说，“他是在飘。在飘。它两边翅膀上都绑了一大堆气球，它在飘。”说完他就睡着了。—— 《小丑回魂》穆卓芸译本</p></blockquote></blockquote><p>而 <code>“飘”</code>，像气球一样飘，正是小丑最令人胆寒的台词。</p><p>在小丑的世界，飘意味着死亡。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvm5ur8rmpj30m909pjro.jpg" alt=""></p><blockquote><p>预告</p></blockquote><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvm5uy1wy3j30qo0k0myi.jpg" alt=""></p><blockquote><p>小丑回魂1990</p></blockquote><h4 id="来自宇宙的死光"><a href="#来自宇宙的死光" class="headerlink" title="来自宇宙的死光"></a>来自宇宙的死光</h4><p>原著中，最早的神秘事件发生1741年，德里镇早期的340名居民突然在10月份消失不见。可怕的是，周边城镇对此事没有任何记载。</p><p>小丑似乎已经存在了200多年。</p><p>事实上，小丑已经存在了 <code>数百万年</code> 。</p><p>在原著中，小丑被描述为来自外太空的东西，早在人类诞生之前，它坠落地球，而它是要 <code>“抢夺地球上所有女人和强暴所有男人”</code>。</p><blockquote><blockquote><p>“告诉你的朋友，我是某个灭绝物种的最后幸存者，”它一边说着，一边摇摇晃晃跟着她走下门廊，露出瘦削的狞笑，“是垂死星球上的唯一生还者。我来是为了抢走所有女人……强暴所有男人……”——《小丑回魂》穆卓芸译本</p></blockquote></blockquote><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm5vrx8rbg30710554qp.gif" alt=""></p><blockquote><p>小丑回魂1990中对死光的呈现</p></blockquote><p>它没有实体，只有一个名字—— <code>死光Deadlight</code>。</p><p>它会读懂你的思想，幻化成你内心最害怕的东西，利用你的恐惧从而吸食脆弱的灵魂。</p><p>所以，不同的人看到小丑会看到不同的景象，有的甚至就是条狗。而有时，小丑还能操控他人，让凡人成为诡异事件的替罪羊。</p><p>比如片中的流氓亨利·鲍威尔，原著中，年老的鲍威尔成为小丑的兵卒，到图书馆大开杀戒，这把刀子来自小丑，由神秘人寄送，最后消失不见。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvm5w00ivsj30g907fdg4.jpg" alt=""></p><h2 id="如何与小丑战斗？"><a href="#如何与小丑战斗？" class="headerlink" title="如何与小丑战斗？"></a>如何与小丑战斗？</h2><p>知道了小丑是什么，接着就要知道如何和它战斗。</p><p>和小丑的战斗第一部中就有所体现，不怕剧透，7个孩子肯定打败了小丑。但真正打败它的方法可能要在第二部中揭晓。</p><h4 id="Chud仪式"><a href="#Chud仪式" class="headerlink" title="Chud仪式"></a>Chud仪式</h4><p>在原著中，提到一种喜玛拉雅人用的驱魔仪式——Chud。</p><p>你需要和魔鬼互相咬住舌头，讲笑话和谜语，如果魔鬼先笑，它就会消失一百年。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvm5wrbygmg30am04e4m4.gif" alt=""></p><blockquote><p>小丑回魂1990</p></blockquote><p>原著中，少年时代的窝囊废联盟和小丑由两场大战，一场在下连接水道的枢纽，内波特街29号，一场在小丑的据点——下水道深处。</p><blockquote><p>预告</p></blockquote><p>剧组还为了下水道镜头专门搭建了实景，因为27年后，窝囊废们还要回来再次和小丑决战。  </p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvm5xem8y4j30go06s75h.jpg" alt=""></p><blockquote><p>花絮</p></blockquote><p>实际上，咬住舌头并不是肉体上的咬住，而是心灵和意志的纠缠。通俗了讲就是战胜恐惧的勇气，和不屈的意志。</p><h4 id="而Chud就是勇敢，挺身而出和信念。"><a href="#而Chud就是勇敢，挺身而出和信念。" class="headerlink" title="而Chud就是勇敢，挺身而出和信念。"></a>而Chud就是勇敢，挺身而出和信念。</h4><p>窝囊废联盟是通过一个叫 <code>“乌龟”</code> 的东西知道这个方法，虽然第一部中没有体现，但已埋下彩蛋。</p><p>乌龟彩蛋：</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm5xlf9zaj30hd074jro.jpg" alt=""></p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvm5xrjk3sj30hg075glq.jpg" alt=""></p><blockquote><p>预告，乐高机器人就是个乌龟</p></blockquote><p>原著中，乌龟告诉威廉一句话，那句话成为他对抗小丑的武器：</p><blockquote><p>他上拳砸柱子，坚信自己见到鬼。      </p></blockquote><blockquote><p>He thrusts his fist against the posts and still insists he sees the ghosts.</p></blockquote><p>威廉小时候口吃很厉害，尤其在弟弟乔治死去以后，恐惧，让他口吃更严重。这句话是她妈妈教他的一个用来矫正口吃的绕口令。</p><p>对抗小丑，你越是恐惧，他就越强大。</p><p>当威廉信心满满，无所畏惧时，他可以流利的说出这个句子，而他无畏的勇气和信念就是他对抗小丑的最大力量。</p><h2 id="史蒂夫·金恐怖宇宙"><a href="#史蒂夫·金恐怖宇宙" class="headerlink" title="史蒂夫·金恐怖宇宙"></a>史蒂夫·金恐怖宇宙</h2><p>提到乌龟，就不得不提史蒂芬·金笔下的恢弘宇宙观。他笔下的故事都有着千丝万缕的联系，甚至可以称为史蒂夫·金恐怖宇宙。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvm5xxzqbhj30zk0m841i.jpg" alt=""></p><blockquote><p>电影黑暗塔概念图</p></blockquote><p>而[小丑回魂]是众多作品的纽带。</p><p>比如德里镇许多罪犯，都被送到了 <code>肖申克监狱</code>。而德里镇还被认为是通往众多宇宙的门户，就像[黑暗塔]。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm5y55qxnj30xc0m4q87.jpg" alt=""></p><blockquote><p>肖申克的救赎，同样改编自史蒂芬·金的原作小说</p></blockquote><p>在[黑暗塔]中，宇宙有12个守护神，其中一个就是乌龟。</p><p>在原著中，窝囊废联盟的成员一直感受到有股力量的支持，这个力量有时就来自乌龟。</p><p>但少年时代的窝囊废们并没有杀死小丑，他立下血誓，27年后，如果小丑重生，他们一定都回来续和小丑战斗。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm5yd156yj30ha06sdgf.jpg" alt=""></p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvm5z0792sj30jw0840t8.jpg" alt=""></p><blockquote><p>预告，对原著中手掌两道疤痕的还原</p></blockquote><p>原著中小说的高潮发生在27年后，最感人的故事也在27年后，远离了德里的6个人分别接到电话，除了一个人畏惧自杀，其他人都毫不犹豫的回到故乡，再次回到那个梦魇之地。</p><p>[小丑回魂2]应该会再现这个高潮，让人无比期待。</p><h2 id="小丑带来的恐惧"><a href="#小丑带来的恐惧" class="headerlink" title="小丑带来的恐惧"></a>小丑带来的恐惧</h2><p>虽然小丑就像是来自外太空的邪恶魔鬼，但[小丑回魂]和温子仁式的恐怖不同，这一点从原著可以读出。</p><p>[小丑回魂]描写的是恐怖本身，但它的内核却不是恐惧，而是人的自私与冷漠。</p><h4 id="为什么只有孩子才能看见小丑的行径？"><a href="#为什么只有孩子才能看见小丑的行径？" class="headerlink" title="为什么只有孩子才能看见小丑的行径？"></a>为什么只有孩子才能看见小丑的行径？</h4><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvm5z8do7yj30qo0k0n18.jpg" alt=""></p><blockquote><p>小丑回魂1990</p></blockquote><p>因为孩子最单纯，他们相信眼睛看到的东西。除此之外，他们相信圣诞老人，就像我们小时候相信月食的时候有吃月亮的天狗。</p><p>而窝囊废联盟的力量也来源于此，他们有着无限的想象力，相信自己，就拥有了力量。</p><p>小丑代表着黑暗与邪恶，窝囊废们代表着勇气与美好。</p><p>没有大人的支持，他们瘦弱的手掌连在一起，便拥有了巨大的（原著中称为原始的）力量。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm5znl9oog30af042nc8.gif" alt=""></p><blockquote><p>预告</p></blockquote><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvm5zvy45wj30qo0k0n0f.jpg" alt=""></p><blockquote><p>小丑回魂1990</p></blockquote><h4 id="为什么小丑的行径大人们都视而不见？"><a href="#为什么小丑的行径大人们都视而不见？" class="headerlink" title="为什么小丑的行径大人们都视而不见？"></a>为什么小丑的行径大人们都视而不见？</h4><p>其实并不是他们看不见，而是长大成人后的我们，变得太复杂，不敢面对未知的恐惧，选择无视和遗忘，对可怕的事情更是闭口不谈，以为这样它就能消失。</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwly1fvm6025fknj30js08yab3.jpg" alt=""></p><p>正如现实世界中，面对路边撕心裂肺的求救，有多少人围观？多少人伸出援手？</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvm608no6sj30m20dpjtz.jpg" alt=""></p><blockquote><p>长春一女子街头遭暴打路人冷漠旁观，图片来自网络</p></blockquote><p>[小丑回魂]中就对原著进行了还原（原著是贝弗莉在被欺负时一个邻居视而不见），本在路边被一群大孩子欺负，路过的两个大人只露出冷漠的眼光。</p><h6 id="这时，小丑的气球出现。"><a href="#这时，小丑的气球出现。" class="headerlink" title="这时，小丑的气球出现。"></a>这时，小丑的气球出现。</h6><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvm60mquixg30aj04ckcw.gif" alt=""></p><blockquote><p>预告</p></blockquote><h6 id="有冷漠，有遗忘的地方就有小丑。"><a href="#有冷漠，有遗忘的地方就有小丑。" class="headerlink" title="有冷漠，有遗忘的地方就有小丑。"></a>有冷漠，有遗忘的地方就有小丑。</h6><p>[小丑回魂]得人心的地方，在于他描绘了在复杂的社会中，站出来的几个人，而那几个人却只是十多岁的孩子。</p><p>冷漠的社会只会更加的冰冷恐怖，必须有人站出来，阻止这些“坏”东西吞噬世界。年少单纯的窝囊废们不知道像大人一样躲在别人身后。</p><p>他们坚信，自己不可以袖手旁观。</p><p><img src="https://ws3.sinaimg.cn/large/006tNbRwly1fvm60u90qnj30ju090gmp.jpg" alt=""></p><h4 id="为什么小丑选择27年后重返人间？"><a href="#为什么小丑选择27年后重返人间？" class="headerlink" title="为什么小丑选择27年后重返人间？"></a>为什么小丑选择27年后重返人间？</h4><p>因为 <code>磨掉一个人、一群人的信念，27年够了</code>。</p><p>傻孩子不懂世故，冒着生命危险跑在最前面，然而27年后呢？他们还会坚持当初的承诺么？</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvm60zqzzgj30jp094q3d.jpg" alt=""></p><blockquote><p>史蒂芬·金接受采访</p></blockquote><p>在[小丑回魂]原著中，27年后，6个窝囊废都远离的了德里，远离了儿时的梦魇，他们也选择遗忘，将曾经可怕的回忆永久的封印。</p><p>但一通电话，将他们再次拖回地狱般恐怖的回忆中。他们大可以事不关己，继续过着自己的生活，眼不见心不烦，对德里置之不理。</p><p>但他们没有任何犹豫，都马不停蹄的回到那个带来恐惧与噩梦的地方，选择继续和魔鬼战斗。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm616xs6kj30qo0k0n08.jpg" alt=""></p><blockquote><p>小丑回魂1990</p></blockquote><p>他们都选择回到家乡，选择再一次站出来，即使他们可能永远被留在黑暗的下水道中。</p><p>正如哈维尔的名言：我们坚持一件事情，并不是因为这样做了会有效果，而是坚信，这样做是对的。</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm61ds22uj30qo0k0gp1.jpg" alt=""></p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwly1fvm61jg1uvj30qo0k00vt.jpg" alt=""></p><blockquote><p>小丑回魂1990</p></blockquote><p>窝囊废们长大成人，他们依然坚信当初的选择，选择直面恐惧，更直面社会的不公与冷漠。</p><p>其实，小丑就在我们身边。</p><p>你会选择听他狂笑，还是站出来和它战斗？</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwly1fvm61p9a5sj30qo0k040p.jpg" alt=""></p><blockquote><p>小丑回魂1990</p></blockquote><h2 id="我的观后感"><a href="#我的观后感" class="headerlink" title="我的观后感"></a>我的观后感</h2><p>这是一部细思极恐的电影，<code>连斯蒂芬金自己都说，这种《小丑回魂》类型的小说，我只写一次就好，因为他自己写的时候都觉得太恐怖</code>. 但实际上看的时候不感到多恐怖，毕竟不同于那种声乐渲染的鬼片，反而有匪夷所思的感觉，但看完之后会让人有一点点反思，电影被归类恐怖片却是在教人如何面对自身恐惧，如何走进充满邪恶鬼怪深渊的黑屋，不是因为年轻气盛不是因为无聊作死，这一切存在于内心的恐惧每个人都必须克服，你不去直视，它便可以依附你掏空你就跟黑山老妖一样，最终把你变成一具行尸走肉，无论你飘在哪里都只能面无表情。（嗯，鸵鸟心理？）</p><p>当然， 小说比起电影更能吸引人的地方在于主人公们是在27年后的成年时代与27年前的童年时期进行平行空间交叉叙事，小丑27年轮回一次，这两段时空的交横更能刻画出各个人物的性格成长，让读者在对比中发现蛛丝马迹。所以，让我们一起期待下一部吧。</p><p>比如 <code>《小丑回魂2》将于2019年9月6日上映</code>。</p><h2 id="文章主要来源"><a href="#文章主要来源" class="headerlink" title="文章主要来源"></a>文章主要来源</h2><p><a href="https://baike.baidu.com/tashuo/browse/content?id=753cd009c6bf2726a0c031f9" target="_blank" rel="noopener">百度TA说</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;二零一七年九月份，北美炸出一部现象级电影，一举打破北美九月份票房影史纪录，完全碾压之前开启招魂恐怖电影宇宙的《安娜贝尔2》！成本仅3500万美元，上映两周票房已跻身R级恐怖片影史第三。影片改编自恐怖大师史蒂芬·金的同名作品，名字只有一个字：它（It）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;是它，是它，就是它！2017年度恐怖最佳！&lt;/p&gt;
    
    </summary>
    
      <category term="杂谈" scheme="https://476139183.github.io/categories/%E6%9D%82%E8%B0%88/"/>
    
    
  </entry>
  
  <entry>
    <title>开篇词 | 从今天起，跨过“数据结构与算法”这道坎</title>
    <link href="https://476139183.github.io/2018/09/25/%E5%BC%80%E7%AF%87%E8%AF%8D-%E4%BB%8E%E4%BB%8A%E5%A4%A9%E8%B5%B7%EF%BC%8C%E8%B7%A8%E8%BF%87%E2%80%9C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%9D%E8%BF%99%E9%81%93%E5%9D%8E/"/>
    <id>https://476139183.github.io/2018/09/25/开篇词-从今天起，跨过“数据结构与算法”这道坎/</id>
    <published>2018-09-25T02:27:53.000Z</published>
    <updated>2018-10-16T06:57:50.765Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://time.geekbang.org/column/article/39922" target="_blank" rel="noopener">文章订阅</a></p><p>你好，我是王争，毕业于西安交通大学计算机专业。现在回想起来，本科毕业的时候，我的编程水平其实是很差的。直到读研究生的时候，一个师兄给了我一本《算法导论》，说你可以看看，对你的编程会很有帮助。</p><p>没想到，从此我对算法的“迷恋”便一发不可收拾。之后，我如饥似渴地把图书馆里几乎所有数据结构和算法书籍都读了一遍。</p><p>我常常边读边练。没多久，我就发现，写代码的时候，我会不由自主考虑很多性能方面的问题。我写出时间复杂度高、空间复杂度高的垃圾代码越来越少了，算法能力提升了很多，编程能力也有了质的飞跃。得益于此，研究生毕业后，我直接进入 Google，从事 Google 翻译相关的开发工作。</p><a id="more"></a><p>这是我自己学习数据结构与算法的经历，现在，你可以想想你的情况。</p><ul><li>是不是从学校开始，你就觉得数据结构难学，然后一直没认真学？</li><li>工作中，一遇到数据结构这个坑，你又发自本能地迅速避让，因为你觉得自己不懂，所以也不想深究，反正看起来无关大局？</li><li>当你想换工作面试，或者研究某个开源项目源码，亦或者和团队讨论某个非框架层面的高可用难题的时候，你又发现，自己的基础跟不上别人的节奏？</li></ul><p>如果你是这种情况，其实你并不孤独，这不是你一个人遇到的问题。工作十年间，我见过许多程序员。他们有着各种各样的背景，有很多既有潜力又非常努力，但始终无法在自己现有水平上更进一步。</p><p>在技术圈里，我们经常喜欢谈论高大上的架构，比如高可用、微服务、服务治理等等。鲜有人关注代码层面的编程能力，而愿意沉下心来，花几个月时间啃一啃计算机基础知识、认认真真夯实基础的人，简直就是凤毛麟角。</p><p>我认识一位原来腾讯 T4 的技术大牛。在区块链大潮之前，他在腾讯工作了 10 多年，长期负责手机 QQ 后台整体建设。他经历了手机 QQ 从诞生到亿级用户在线的整个过程。后来他去了微众银行，有一天老板让他去做区块链。<strong>他用了不到半年时间，就把区块链的整个技术脉络摸清楚了</strong>。 现在，他是微众银行的区块链负责人，微众科技创新产品部的老总。你说厉害不？你可以花半年时间就能精通一个新的领域吗？为什么他就可以做到？</p><p>我觉得这其中最重要的就是基础足够扎实。他曾经跟我说，像区块链、人工智能这些看似很新的技术，其实一点儿都不“新”。最初学编程的时候，他就把那些基础的知识都学透了。当面临行业变动、新技术更迭的时候，他不断发现，那些所谓的新技术，核心和本质的东西其实就是当初学的那些知识。掌握了这个“规律”之后，他学任何东西都很快，任何新技术都能快速迎头赶上。这就是他快速学习并且获得成功的秘诀。</p><p>所以说，<strong>基础知识就像是一座大楼的地基，它决定了我们的技术高度。而要想快速做出点事情，前提条件一定是基础能力过硬，“内功”要到位</strong></p><p>那技术人究竟都需要修炼哪些“内功”呢？我觉得，无外乎就是大学里的那些基础课程，操作系统、计算机网络、编译原理等等，当然还有数据结构和算法。</p><p>可是，我们都知道，像《算法导论》这些经典书籍，虽然很全面，但是过于理论，学起来非常枯燥；而市面很多课程大多缺失真实的开发场景，费劲学完感觉好像还是用不上，过不了几天就忘了。</p><p>所以，我尝试做 <strong><font color="DarkOrange">一个让你能真正受用的数据结构与算法课程，希望给你指明一个简洁、高效的学习路径，教你一个学习基础知识的通用方法</font></strong> 。那么，关于专栏内容，我是怎样设计的呢？</p><ol><li>我根据自己研读数十本算法书籍和多年项目开发的经验，在众多的数据结构和算法中，精选了最实用的内容进行讲解。</li><li>我不只会教你怎么用，还会告诉你，我们为什么需要这种数据结构和算法，一点点帮你捋清它们背后的设计思想，培养你举一反三的能力。</li><li>对于每种数据结构和算法，我都会结合真实的软件开发案例来讲解，让你知道，数据结构和算法，究竟应该如何应用到实际的编码中。</li></ol><p>为了 <strong>由浅入深</strong> 地带你学习，我把专栏分成四个 <strong>递进</strong> 的模块。</p><h3 id="1-入门篇"><a href="#1-入门篇" class="headerlink" title="1. 入门篇"></a>1. 入门篇</h3><p>时间、空间复杂度分析是数据结构和算法中非常重要的知识点，贯穿整个专栏的学习过程。但同时也是比较难掌握的，所以我用了 2 节课来讲这部分内容，而且还举了大量的实例，让你一边学一边练，真正能掌握复杂度分析，为后面的学习铺路。</p><p>我希望通过这一模块，你能掌握时间、空间复杂度的概念，大 O 表示法的由来，各种复杂度分析技巧，以及最好、最坏、平均、均摊复杂度分析方法。之后，面对任何代码的复杂度分析，你都能游刃有余、毫不畏惧！</p><h3 id="2-基础篇"><a href="#2-基础篇" class="headerlink" title="2. 基础篇"></a>2. 基础篇</h3><p>这部分是专栏中篇幅最大的内容，也是我们学习的重点，共有 26 节内容，涵盖了最基础、最常用的数据结构和算法。针对每种数据结构和算法，我都会结合具体的软件开发实例，由浅入深进行讲解，并适时总结一些实用“宝典”，保证你印象深刻、学有所用。</p><p>比如递归这一节，我会讲到，为什么递归代码比较难写？如何避免堆栈溢出？如何避免递归冗余计算？如何将递归代码转化为非递归代码？</p><h3 id="3-高级篇"><a href="#3-高级篇" class="headerlink" title="3. 高级篇"></a>3. 高级篇</h3><p>这部分我会讲一些不是那么常用的数据结构和算法。虽然不常用，但是这些内容你也需要知道。设置这一部分的目的，是为了让你开拓视野，强化训练算法思维、逻辑思维。如果说学完基础部分可以考 80 分，那掌握这一部分就能让你成为尖子生！</p><h3 id="4-实战篇"><a href="#4-实战篇" class="headerlink" title="4. 实战篇"></a>4. 实战篇</h3><p>我们整个专栏都是围绕数据结构和算法在具体软件实践中的应用来讲的，所以最后我会通过实战部分串讲一下前面讲到的数据结构和算法。我会拿一些开源项目、框架或者系统设计问题，剖析它们背后的数据结构和算法，让你有一个更加直观的感受。</p><p>人生路上，我们会遇到很多的坎。跨过去，你就可以成长，跨不过去就是困难和停滞。而在后面很长的一段时间里，你都需要为这个困难买单。对于我们技术人来说，更是这样。 <strong>既然数据结构和算法这个坎，我们总归是要跨过去，为什么不是现在呢</strong>？</p><p>我很感激师兄当年给我的那本《算法导论》，这是我人生中为数不多的转折点之一。没有那本书，也可能就没有今天的我。我希望这个专栏也能成为你的一个人生转折点。</p><p>我希望，通过这个专栏，不仅能帮你跨过数据结构与算法这个坎，还能帮你掌握一种学习知识和技能的方法，帮你度过职场甚至人生的重要时刻！一起加油吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://time.geekbang.org/column/article/39922&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章订阅&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;你好，我是王争，毕业于西安交通大学计算机专业。现在回想起来，本科毕业的时候，我的编程水平其实是很差的。直到读研究生的时候，一个师兄给了我一本《算法导论》，说你可以看看，对你的编程会很有帮助。&lt;/p&gt;
&lt;p&gt;没想到，从此我对算法的“迷恋”便一发不可收拾。之后，我如饥似渴地把图书馆里几乎所有数据结构和算法书籍都读了一遍。&lt;/p&gt;
&lt;p&gt;我常常边读边练。没多久，我就发现，写代码的时候，我会不由自主考虑很多性能方面的问题。我写出时间复杂度高、空间复杂度高的垃圾代码越来越少了，算法能力提升了很多，编程能力也有了质的飞跃。得益于此，研究生毕业后，我直接进入 Google，从事 Google 翻译相关的开发工作。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://476139183.github.io/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="算法" scheme="https://476139183.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="进阶" scheme="https://476139183.github.io/tags/%E8%BF%9B%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>推荐两个实用开源项目</title>
    <link href="https://476139183.github.io/2018/09/21/%E6%8E%A8%E8%8D%90%E4%B8%A4%E4%B8%AA%E5%AE%9E%E7%94%A8%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    <id>https://476139183.github.io/2018/09/21/推荐两个实用开源项目/</id>
    <published>2018-09-21T06:48:43.000Z</published>
    <updated>2018-09-21T07:17:18.405Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/Bm6cwzA2yAxr5kpDwUz9YQ" target="_blank" rel="noopener">文章来源</a></p><p>终于周五了，周末一定要好好休息一波，每逢周五的文章都会较为轻松。</p><p>大家在平时开发过程中，是不是经常要查一些单词的意思，或者某个中文词语、某段中文希望翻译成英文。</p><p>一般情况下，我们可以通过某个翻译app，比如有道；又或者打开浏览器打开web 在线翻译。</p><p>那么这两个操作我还是觉得有点重，我觉得这样翻译才有意思：</p><p><img src="/2018/09/21/推荐两个实用开源项目/640.gif" alt="目录">    </p><a id="more"></a> <p>我们可以不跳出 Studio，直接翻译，或者在自己喜欢的 命令行工具中直接敲英文。</p><p>是不是更加轻量。</p><p>那么还有个场景，例如我正在看源码，看到一段英文注释或者单词想要翻译，当时我正在源码中操作，我并不希望copy 到命令行，再来看结果，你可以这样：</p><p><img src="/2018/09/21/推荐两个实用开源项目/640-1.gif" alt="目录">    </p><p>这样的操作就连贯很多了，而且支持多种语言，还能直接播放声音。</p><p>至于推荐它还有个更大的原因就是，目前有700多次提交，近期还在更新。</p><p>接下来就是详细介绍一哈了。</p><h2 id="1-翻译插件"><a href="#1-翻译插件" class="headerlink" title="1. 翻译插件"></a>1. 翻译插件</h2><p><a href="https://github.com/YiiGuxing/TranslationPlugin" target="_blank" rel="noopener">https://github.com/YiiGuxing/TranslationPlugin</a></p><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>网络良好的很开心了，搜索安装即可：</p><p><code>Preferences(Settings)</code> &gt; <code>Plugins</code> &gt; <code>Browse repositories...</code> &gt; 搜索并找到 <code>Translation</code> &gt; <code>Install Plugin</code></p><p>网络不太流畅的，可以下载zip 包: </p><p><code>下载最新发布的插件包</code> -&gt; <code>Preferences(Settings)</code> &gt; <code>Plugins</code> &gt; <code>Install plugin from disk...</code></p><p>这个文档写的很清楚，而且还有一些别的功能，比如，我并不是划词查询，我就想查某个单词的意思，也可以唤起翻译面板：</p><p><img src="/2018/09/21/推荐两个实用开源项目/640-2.gif" alt="目录">    </p><p>当然这样就是通过快捷键打开了，具体支持哪些快捷键，自己看文档吧。</p><h2 id="2-命令行翻译"><a href="#2-命令行翻译" class="headerlink" title="2. 命令行翻译"></a>2. 命令行翻译</h2><blockquote><p>项目介绍：不喜欢安装有道词典的应用程序，因为太耗资源还一堆广告，但是用浏览器打开dict.youdao.com也挺麻烦的，不是吗？快来试试我的有道词典命令行工具吧！</p></blockquote><p> <a href="https://github.com/kenshinji/yddict" target="_blank" rel="noopener">https://github.com/kenshinji/yddict</a></p><h4 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install yddict -g</span><br></pre></td></tr></table></figure><blockquote><p>安装如果因为权限为问题失败，可以加上以管理员身份运行；如果安装完成后提示node.js 版本过低，记得升级。</p></blockquote><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p><code>yd &lt;要查询的单词&gt;</code></p><p>默认情况下，查出来的单词是白色的文字，如果 AS 是默认主题，那么就会看不到。当然，颜色支持我们自己设置。</p><p>默认在 <em><code>用户主目录下.config/configstore/yddict.json</code></em></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.config/configstore/yddict.json </span><br><span class="line">&#123;</span><br><span class="line">    &quot;color&quot;: &quot;green&quot;,</span><br><span class="line">    &quot;spinner&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以自由修改这个字的颜色。</p><p>推荐完毕，祝大家周末愉快！</p><p>推荐阅读：</p><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650826203&amp;idx=1&amp;sn=4c83f119ae3a7e818a65357cb78e5df5&amp;chksm=80b7b145b7c038538ef46e7b16d41b6dc5d622b6a3c72ce67ce9735c49709f011d334e1366f9&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">启动优化提升60%</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650826201&amp;idx=1&amp;sn=3b843ffedf6d8fe56288612b0f9360c9&amp;chksm=80b7b147b7c0385171c9a69668abe86921360adfa123c136b13243a0d09fbd3e80723645397c&amp;scene=21#wechat_redirect" target="_blank" rel="noopener">给大家分享一个面试经验</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s/Bm6cwzA2yAxr5kpDwUz9YQ&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;文章来源&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;终于周五了，周末一定要好好休息一波，每逢周五的文章都会较为轻松。&lt;/p&gt;
&lt;p&gt;大家在平时开发过程中，是不是经常要查一些单词的意思，或者某个中文词语、某段中文希望翻译成英文。&lt;/p&gt;
&lt;p&gt;一般情况下，我们可以通过某个翻译app，比如有道；又或者打开浏览器打开web 在线翻译。&lt;/p&gt;
&lt;p&gt;那么这两个操作我还是觉得有点重，我觉得这样翻译才有意思：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/09/21/推荐两个实用开源项目/640.gif&quot; alt=&quot;目录&quot;&gt;    &lt;/p&gt;
    
    </summary>
    
      <category term="工具" scheme="https://476139183.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
  </entry>
  
  <entry>
    <title>MAC安装JDK及环境变量配置</title>
    <link href="https://476139183.github.io/2018/09/19/MAC%E5%AE%89%E8%A3%85JDK%E5%8F%8A%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E9%85%8D%E7%BD%AE/"/>
    <id>https://476139183.github.io/2018/09/19/MAC安装JDK及环境变量配置/</id>
    <published>2018-09-19T09:45:36.000Z</published>
    <updated>2018-09-21T07:13:10.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h1><ol><li>访问<a href="http://www.oracle.com" target="_blank" rel="noopener">Oracle官网</a>，浏览到首页的底部菜单 ,然后按下图提示操作:     </li></ol><p><img src="http://images2015.cnblogs.com/blog/877813/201601/877813-20160113135011647-96008710.png" alt=""></p><a id="more"></a><ol start="2"><li>点击“JDK DOWNLOAD”按钮：</li></ol><p><img src="http://images2015.cnblogs.com/blog/877813/201601/877813-20160113135051835-861363050.png" alt=""></p><ol start="3"><li>选择“Accept Lisence Agreement”同意协议:</li></ol><p><img src="http://images2015.cnblogs.com/blog/877813/201601/877813-20160113135219866-685515947.png" alt=""></p><ol start="4"><li>点击Mac OS X x64后面的下载链接：<br><img src="http://images2015.cnblogs.com/blog/877813/201601/877813-20160113135306585-54248836.png" alt=""></li></ol><p>下载完成后点击安装包，按提示即可完成安装。</p><ol start="5"><li>打开Finder,可以在下图所示的路径中找到安装好的jdk 1.8.0_40.jdk:(建议直接使用<code>/Library/Java</code>前往,因为我居然找不到该目录)</li></ol><p><img src="http://images2015.cnblogs.com/blog/877813/201604/877813-20160416153110191-1153954158.png" alt=""></p><ol start="6"><li>其中Contents下的Home文件夹，是该JDK的根目录。</li></ol><p><img src="http://images2015.cnblogs.com/blog/877813/201604/877813-20160416153449941-591903183.png" alt=""></p><blockquote><p>其中：</p></blockquote><blockquote><p><code>bin目录</code>下存放JDK用于开发的一些终端命令工具。常见的工具如：<br>“javac”的作用是将java源文件编译为class文件(即自解码文件)；<br>“java”命令的作用是运行class文件。</p></blockquote><blockquote><p><code>db目录</code>下是java开发的一个开源的关系型数据库；</p></blockquote><blockquote><p><code>include目录</code>下是一些C语言的头文件；</p></blockquote><blockquote><p><code>jre目录</code>下JDK所依赖的java运行时；</p></blockquote><blockquote><p><code>lib目录</code>下存放JDK开发工具所依赖的一些库文件；</p></blockquote><blockquote><p><code>man目录</code>下存放JDK开发工具的说明文档。</p></blockquote><ol start="7"><li>安装好JDK后需要配置JDK的环境变量，方法请参考：<a href="http://www.cnblogs.com/quickcodes/p/5398709.html" target="_blank" rel="noopener">Mac下如何配置环境变量</a>，方法有部分不对，下面以配置JDK的环境变量为例，示范如何配置环境变量，后续在安装Android、Maven、MongoDB等时都会需要配置相应的环境变量。</li></ol><h1 id="配置JDK的环境变量"><a href="#配置JDK的环境变量" class="headerlink" title="配置JDK的环境变量"></a>配置JDK的环境变量</h1><ol><li><p>打开终端。（cd /Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk）</p></li><li><p>如果你是第一次配置环境变量，可以使用 <code>touch ~/.bash_profile</code> 创建一个 <code>.bash_profile</code> 的隐藏配置文件(如果你是为编辑已存在的配置文件，则使用 <code>open -e ~/.bash_profile</code> 命令)：</p></li></ol><p><img src="http://images2015.cnblogs.com/blog/877813/201604/877813-20160416164957082-1418925235.png" alt=""></p><ol start="3"><li>输入 <code>open -e ~/.bash_profile</code> 命令：</li></ol><p><img src="http://images2015.cnblogs.com/blog/877813/201604/877813-20160416165627113-2136824168.png" alt=""></p><blockquote><p>ps:如果没有权限 就使用<code>sudo touch ~/.bash_profile</code>,而编辑的时候我是用sublime打开的。</p></blockquote><ol start="4"><li>输入如下配置：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home</span><br><span class="line">PATH=$JAVA_HOME/bin:$PATH:.</span><br><span class="line">CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.</span><br><span class="line">export JAVA_HOME</span><br><span class="line">export PATH</span><br><span class="line">export CLASSPATH</span><br></pre></td></tr></table></figure><p>然后保存关闭该窗口。（我的是jdk-10.0.2.jdk）</p><p><img src="https://ws3.sinaimg.cn/large/0069RVTdgy1fv5of7a721j30zk0mwacf.jpg" alt=""></p><p>5.使用”source ~/.bash_profile”使配置生效 然后输入”java -version”，如果看到jdk版本为10.0.2则说明配置已经生效：</p><p>6.输入 echo $JAVA_HOME 显示刚才配置的路径</p><p><img src="https://ws1.sinaimg.cn/large/0069RVTdgy1fv5jtc8u1ej30fu0a6mxk.jpg" alt=""></p><p><img src="http://images2015.cnblogs.com/blog/877813/201604/877813-20160416170843160-212359895.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装JDK&quot;&gt;&lt;a href=&quot;#安装JDK&quot; class=&quot;headerlink&quot; title=&quot;安装JDK&quot;&gt;&lt;/a&gt;安装JDK&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;访问&lt;a href=&quot;http://www.oracle.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Oracle官网&lt;/a&gt;，浏览到首页的底部菜单 ,然后按下图提示操作:     &lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;http://images2015.cnblogs.com/blog/877813/201601/877813-20160113135011647-96008710.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>jenkins 安装</title>
    <link href="https://476139183.github.io/2018/09/19/jenkins-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    <id>https://476139183.github.io/2018/09/19/jenkins-自动化部署/</id>
    <published>2018-09-19T09:39:58.000Z</published>
    <updated>2018-09-21T08:53:12.621Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、简述"><a href="#一、简述" class="headerlink" title="一、简述"></a>一、简述</h2><ol><li>Jenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。<br><code>Jenkins</code> 本身是用 <code>java</code> 语言开发的，所以安装 <code>Jenkins</code> 之前，要保证你的电脑有<code>jdk</code>，如果没有，请到参考<a href="">《MAC安装JDK及环境变量配置》</a> ，另外建议git、ant、maven、gradle、groovy等工具也一并安装好，方便与这些构建工具集成。</li></ol><p>根据官方定义，Jenkins有以下的用途：</p><ul><li>构建项目      </li><li>跑测试用例检测bug      </li><li>静态代码检测       </li><li>部署      </li></ul><a id="more"></a> <h2 id="二、Jenkins的安装"><a href="#二、Jenkins的安装" class="headerlink" title="二、Jenkins的安装"></a>二、Jenkins的安装</h2><h3 id="1-1-jenkins-pkg"><a href="#1-1-jenkins-pkg" class="headerlink" title="1.1 jenkins.pkg"></a>1.1 jenkins.pkg</h3><p>进入<a href="https://jenkins.io/index.html" target="_blank" rel="noopener">Jenkins的官网</a> ,然后下载并安装Jenkins</p><blockquote><p>也可以直接点击下载<a href="http://mirrors.jenkins-ci.org/osx/latest" target="_blank" rel="noopener">最新版本</a></p></blockquote><p> <strong><em>1.</em></strong> 点击链接进入官网</p><p> <img src="http://upload-images.jianshu.io/upload_images/3008243-84988033422d9c16.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p> <strong><em>2.</em></strong> 点击download</p><p> <img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fvezxiaiajj31ga11egsn.jpg" alt=""> </p><p> <strong><em>3.</em></strong> 我选择的是Mac OS X下载并安装</p><p> <strong><em>4.</em></strong> 点击直接安装即可，在下图中，选择自定义，取消 <code>start at boot as“jenkins”</code>，一般不需要自启动<br> <img src="http://upload-images.jianshu.io/upload_images/3008243-26bfb9a02d0f5d07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="1-2-命令行安装"><a href="#1-2-命令行安装" class="headerlink" title="1.2 命令行安装"></a>1.2 命令行安装</h3><p>命令行使用 <code>homebrew</code> 安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ brew search jenkins</span><br><span class="line">jenkins</span><br><span class="line">$ brew install jenkins</span><br></pre></td></tr></table></figure><p>启动jenkins    </p><p><code>$ jenkins</code></p><h3 id="2-进入页面"><a href="#2-进入页面" class="headerlink" title="2. 进入页面"></a>2. 进入页面</h3><p>安装完成后，会直接跳转到如下界面，如果没有跳转或者跳转失败，可通过执行如下命令 <code>open /Applications/Jenkins/jenkins.war</code> 进入到该界面<br><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fvfywcg9ewj30ri09tabf.jpg" alt=""></p><blockquote><p>如果打开没有反应，启动不了，就在浏览器直接打开：<a href="http://localhost:8080/" target="_blank" rel="noopener">http://localhost:8080/</a> ，就可以进入到上面界面了。</p></blockquote><blockquote><blockquote><p>发现还是打不开， cd进入到jenkins.war包所在目录,执行以下命令:</p></blockquote></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar jenkins.war --httpPort=8080</span><br></pre></td></tr></table></figure><blockquote><p>httpPort指的就是Jenkins所使用的http端口,这里指定8080(默认的就是这个),可根据具体情况来修改。待Jenkins启动后,在浏览器页面输入以下地址:<br><a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></p></blockquote><blockquote><p>这个时候可能会报一个错误。如果出现了上面的问题，原因可能是Java环境有问题，重新安装JDK环境即可。</p></blockquote><p> <strong><em>6.</em></strong> 观察图中的路径，将地址中的文件打开，或者打开你的终端，执行<code>cat</code>命令（注意：该命令仅在安装Jenkins的过程中执行才有效；安装成功后，再在终端中执行是无效的）：    </p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fvfyxf1rl8j30vg054wga.jpg" alt="">     </p><p> <strong><em>7.</em></strong> 然后将我们得到的 <code>password</code> 输入到 <code>Administrator password</code> 中，即可进入如下界面, 选第一个,接着安装一些建议的插件，安装过程中，有的插件可能会安装失败，可以跳过，之后需要对应的插件时，再重新安装即可，具体后面会讲到：</p><p> <img src="http://upload-images.jianshu.io/upload_images/3008243-cf1635160604dc56?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p> <strong><em>8.</em></strong> 插件安装完成后，可能会卡在如下界面，不会自动跳转，刷新下界面即可：</p><p> <img src="http://upload-images.jianshu.io/upload_images/3008243-03f427bb5a3553da?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p> <strong><em>9.</em></strong> 在刷新后的界面中注册，输入用户名和密码，如下：</p><p> <img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fvezybgexnj31iw1byado.jpg" alt=""></p><p> <strong><em>10.</em></strong> 注册成功后，点击”Start using Jenkins”</p><p> <img src="http://upload-images.jianshu.io/upload_images/3008243-bb59d4a3085e0e4c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h2 id="三、Jenkins的使用"><a href="#三、Jenkins的使用" class="headerlink" title="三、Jenkins的使用"></a>三、Jenkins的使用</h2><h3 id="安装常用插件"><a href="#安装常用插件" class="headerlink" title="安装常用插件"></a>安装常用插件</h3><ul><li>Xcode</li><li>Keychains and provisioning profiles management</li><li>Git Plugin</li><li>Xcode integration<br>…. </li></ul><p>如下图，进行管理:<br><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fvezz4ovfnj31kw0nxn2d.jpg" alt=""></p><p><img src="http://upload-images.jianshu.io/upload_images/80578-e68106251e4a5eaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="项目实战"><a href="#项目实战" class="headerlink" title="项目实战"></a>项目实战</h3><h4 id="1-新建一个自由风格的软件项目"><a href="#1-新建一个自由风格的软件项目" class="headerlink" title="1.新建一个自由风格的软件项目"></a>1.新建一个自由风格的软件项目</h4><h4 id="2-配置git地址"><a href="#2-配置git地址" class="headerlink" title="2.配置git地址"></a>2.配置git地址</h4><p><img src="http://upload-images.jianshu.io/upload_images/80578-98eb62f65d91d0b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="立即构建下，提示构建成功"><a href="#立即构建下，提示构建成功" class="headerlink" title="立即构建下，提示构建成功"></a>立即构建下，提示构建成功</h4><p><img src="http://upload-images.jianshu.io/upload_images/80578-747f024d24255bab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>那么构建后的项目在哪里呢？<br>通过系统管理-&gt;系统设置-&gt;主目录 点击高级，可以查看到<br><img src="http://upload-images.jianshu.io/upload_images/80578-a7d73b8be1152ced.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在jenkins的workspace目录中，可以看到构建的项目</p><p><img src="http://upload-images.jianshu.io/upload_images/80578-7398252ed1c1104c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="编译配置（很关键）"><a href="#编译配置（很关键）" class="headerlink" title="编译配置（很关键）"></a>编译配置（很关键）</h4><p>上面虽然编译成功了，但是你发现根本没有看到ipa文件，所以还需要进行下面的配置：增加构建步骤</p><p>这就用到我们上面安装的Xcode插件了</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvh8d0pc1aj30hm0hsmyp.jpg" alt=""></p><p>Xcode插件配置</p><p><img src="http://upload-images.jianshu.io/upload_images/80578-0da04c60564cecca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/80578-60758d04253a56b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>配置完成，点击立即构建，查看ipa所在的路径</p><p><img src="http://upload-images.jianshu.io/upload_images/80578-084d215fb776d43c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>OK，一个简单的打包就完成了。</p><h2 id="结合FastLane"><a href="#结合FastLane" class="headerlink" title="结合FastLane"></a>结合FastLane</h2><p>配置好Git，在 <code>增加构建步骤</code> 的时候，选择脚本</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvh897f6v0j30ii0kw760.jpg" alt=""></p><p>添加 shell 命令：<br><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fvh8al45v2j31f80giabm.jpg" alt=""></p><blockquote><p>我这里做了三步，1.cd 到项目路径  2，执行fastlane 打包  3，发送qq邮件</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h3><p>Jenkins的安装方式不同（<a href="http://www.cnblogs.com/ihojin/p/mac-install-jenkins.html" target="_blank" rel="noopener">Mac 安装 Jenkins</a>），卸载方法也不同</p><h4 id="一-通过安装包安装的卸载方式"><a href="#一-通过安装包安装的卸载方式" class="headerlink" title="一.通过安装包安装的卸载方式"></a>一.通过安装包安装的卸载方式</h4><ul><li><p>方法1：打开终端，执行命令 /Library/Application Support/Jenkins/Uninstall.command</p></li><li><p>方法2：Finder 前往文件夹：<code>/Library/Application Support/Jenkins</code>，双击 <code>Uninstall.command</code></p></li></ul><h4 id="二-通过-Homebrew-安装的卸载方式"><a href="#二-通过-Homebrew-安装的卸载方式" class="headerlink" title="二.通过 Homebrew 安装的卸载方式"></a>二.通过 Homebrew 安装的卸载方式</h4><ul><li>打开终端 <code>brew uninstall jenkins</code></li></ul><p>完成之后再次打开<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a>  访问不了，说明卸载成功</p><h2 id=""><a href="#" class="headerlink" title="#"></a>#</h2><p>Jenkins做的操作其实很简单，它只是将我们平时做的每一步重复的操作自动化了而已。因此，iOS中Jenkins要做的分为以下几步：</p><ol><li>拉取远端代码      </li><li>由于某种条件触发后开始自动编译，打包     </li><li>将生成的ipa文件上传到指定位置，供测试下载测试      </li></ol><p>这三步中，每一步Jenkins什么都没做，它只是调用了Mac中的一些工具，具体的说就是使用了命令行工具。有的做成了可视化的插件，有的还是要通过自己写命令来实现。典型的就是编译和打包的命令是调用xcodebuild命令。<br>也就是说我们可以也可以结合 <code>Fastlane</code> 来打包，简化 <code>Jenkins</code>的操作和需要安装的插件。</p><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p><a href="https://www.jianshu.com/p/41ecb06ae95f" target="_blank" rel="noopener">Jenkins持续集成iOS项目</a></p><p><a href="https://www.imooc.com/article/26327?block_id=tuijian_wz#" target="_blank" rel="noopener">Jenkins踩坑记录</a></p><p><a href="https://www.cnblogs.com/Rocky_/p/8297260.html" target="_blank" rel="noopener">Jenkins 构建触发器</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、简述&quot;&gt;&lt;a href=&quot;#一、简述&quot; class=&quot;headerlink&quot; title=&quot;一、简述&quot;&gt;&lt;/a&gt;一、简述&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;Jenkins 是一个开源项目，提供了一种易于使用的持续集成系统，使开发者从繁杂的集成中解脱出来，专注于更为重要的业务逻辑实现上。同时 Jenkins 能实施监控集成中存在的错误，提供详细的日志文件和提醒功能，还能用图表的形式形象地展示项目构建的趋势和稳定性。&lt;br&gt;&lt;code&gt;Jenkins&lt;/code&gt; 本身是用 &lt;code&gt;java&lt;/code&gt; 语言开发的，所以安装 &lt;code&gt;Jenkins&lt;/code&gt; 之前，要保证你的电脑有&lt;code&gt;jdk&lt;/code&gt;，如果没有，请到参考&lt;a href=&quot;&quot;&gt;《MAC安装JDK及环境变量配置》&lt;/a&gt; ，另外建议git、ant、maven、gradle、groovy等工具也一并安装好，方便与这些构建工具集成。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据官方定义，Jenkins有以下的用途：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建项目      &lt;/li&gt;
&lt;li&gt;跑测试用例检测bug      &lt;/li&gt;
&lt;li&gt;静态代码检测       &lt;/li&gt;
&lt;li&gt;部署      &lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Fastlane （二）</title>
    <link href="https://476139183.github.io/2018/09/18/Fastlane-%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://476139183.github.io/2018/09/18/Fastlane-（二）/</id>
    <published>2018-09-18T08:59:29.000Z</published>
    <updated>2018-10-11T09:46:27.042Z</updated>
    
    <content type="html"><![CDATA[<h1 id="打包到-AppStore"><a href="#打包到-AppStore" class="headerlink" title="打包到 AppStore"></a>打包到 AppStore</h1><p><a href="">上篇文章</a> 我们已经成功的打包app到蒲公英了。那么我们也可以尝试将app上传到AppStore.<br>废话不多说，先简单的打包一个 ipa 到 AppStore 。  </p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">desc &quot;release&quot;</span><br><span class="line">lane :release do</span><br><span class="line">sigh # 更新证书</span><br><span class="line">gym(</span><br><span class="line">      scheme:&quot;your need up schemeName&quot;, # scheme,</span><br><span class="line">    configuration: &quot;Release&quot;, # 配置 Release or Debug</span><br><span class="line">      export_method: &quot;app-store&quot;)       # 打包类型，前文已经讲过</span><br><span class="line"></span><br><span class="line"> deliver(submit_for_review: false, #是否自动提交审核</span><br><span class="line">         skip_screenshots: true,  # 是否跳过截图</span><br><span class="line">       skip_metadata: true,  # 是否跳过元数据（标题，描述）</span><br><span class="line">         force: true)</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>关于<code>scheme</code>的设置请查看<a href="https://developer.apple.com/library/archive/documentation/IDEs/Conceptual/xcode_guide-continuous_integration/ConfigureBots.html#//apple_ref/doc/uid/TP40013292-CH9-SW3" target="_blank" rel="noopener">文档</a></p><p>调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane release</span><br></pre></td></tr></table></figure><p>在项目无误的情况下,提交成功！<br><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fvezjej76pj30ve0ge766.jpg" alt="success"></p><h1 id="了解更多"><a href="#了解更多" class="headerlink" title="了解更多"></a>了解更多</h1><p>在<a href="">上篇文章</a>的基础上，因为我们选择的是自定义，所以并没有创建 <code>Deliverfile</code>，<code>screenshots</code>和<code>metadata</code>目录，也就没有app的更多的设置,比如提交的各种信息，截图等。我们可以使用如下命令进行创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deliver init</span><br></pre></td></tr></table></figure><p>此时会要求输入你的 <code>Your Apple ID Username</code> 和 <code>password</code>,<code>The Bundle Identifier of your App</code>.(因为我已经登录过了。所以并未出现要输入账号的密码，也可以在 <code>Appfile</code> 编辑你的账号和 Bundle Identifier)。</p><p><img src="https://upload-images.jianshu.io/upload_images/1533163-d4cae722f895945e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/787" alt=""></p><blockquote><p>如果开发者账号上没有对应的bundle id的App，会提示是否创建一个新的App,这里我们选择否(n)，因为这样快速创建的App设置的信息有限，只能设置App名称等一些基本信息，我们可以通过produce工具创建一个可以设置更多信息的App</p></blockquote><h1 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h1><p>我们可以通过编辑 <code>Deliverfile</code>来设置app的相关属性:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"># Apple ID用户名，账号名称</span><br><span class="line">username &quot;xxxx@xxxxx.com&quot; </span><br><span class="line"></span><br><span class="line"># bundle identifier</span><br><span class="line">app_identifier &quot;xxx.com.cn&quot; # The bundle identifier of your app</span><br><span class="line"></span><br><span class="line"># 版权声明</span><br><span class="line">copyright &quot;深圳xxxx有限公司&quot;</span><br><span class="line"></span><br><span class="line"># 支持的语言</span><br><span class="line">supportedLanguages = &#123;</span><br><span class="line">    &quot;cmn-Hans&quot; =&gt; &quot;zh-Hans&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 副标题</span><br><span class="line">subtitle(</span><br><span class="line">  &apos;zh-Hans&apos; =&gt; &quot;副标题&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># App应用名称</span><br><span class="line">name(</span><br><span class="line">  &apos;zh-Hans&apos; =&gt; &quot;应用名称&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># 关键字</span><br><span class="line">keywords(</span><br><span class="line">  &apos;zh-Hans&apos; =&gt; &quot;各种关键字,用逗号隔开&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 支持网址</span><br><span class="line">support_url(&#123;</span><br><span class="line">  &apos;zh-Hans&apos; =&gt; &quot;http://baidu.com&quot;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># App价格</span><br><span class="line">price_tier 0</span><br><span class="line"></span><br><span class="line"># 应用程序图标的路径</span><br><span class="line"># app_icon &apos;./fastlane/metadata/AppIcon.png&apos;</span><br><span class="line"></span><br><span class="line"># 屏幕截图的文件夹的路径</span><br><span class="line">screenshots_path &apos;./fastlane/screenshots&apos;</span><br><span class="line"></span><br><span class="line"># 指定上传ipa路径,</span><br><span class="line">ipa &apos;./Ipa/xxxx.ipa&apos;</span><br><span class="line"></span><br><span class="line"># 自动发布 app: false,则需要手动发布</span><br><span class="line">automatic_release false</span><br><span class="line"></span><br><span class="line"># 提交审核信息:加密, idfa 等，对应的是提交审核的时候，需选择的选项</span><br><span class="line">submission_information(&#123;    </span><br><span class="line">    export_compliance_encryption_updated: false,</span><br><span class="line">    export_compliance_uses_encryption: false,</span><br><span class="line">    content_rights_contains_third_party_content: false,</span><br><span class="line">    add_id_info_uses_idfa: false,</span><br><span class="line">    </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"># 应用审核小组的联系信息 app 审核信息</span><br><span class="line">app_review_information(</span><br><span class="line">  first_name: &quot;姓&quot;,</span><br><span class="line">  last_name: &quot;名字&quot;,</span><br><span class="line">  phone_number: &quot;+86 18237485911&quot;,</span><br><span class="line">  email_address: &quot;xxxx@ apple.com.cn&quot;,</span><br><span class="line">  demo_user: &quot;测试登录账号&quot;,</span><br><span class="line">  demo_password: &quot;测试登录密码&quot;,</span><br><span class="line">  notes: &quot;这里可以写一些备注，完全和网页一致的写法就行了&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>更多 <a href="https://www.jianshu.com/p/867b397c7939" target="_blank" rel="noopener">编辑内容</a></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><p>等待初始化完成之后，工程目录下就多了一个 fastlane目录，其内容如下：<br><img src="http://cc.cocimg.com/api/uploads/20170519/1495177333947263.png" alt=""></p><blockquote><p><code>metadata</code> 是包含应用在ITC上面的各种信息，可以使用它配置我们的ITC，配置项，宣传文本、app名称、关键字、隐私网址、app的logo, 但建议使用 <code>Deliverfile</code>，因为<code>Deliverfile</code>会覆盖 <code>metadata</code> 的设置<br>screenshots 屏幕截图数据。</p></blockquote><p>咱们来看主要的，Appfile 和 Fastfile, Deliverfile。</p><h2 id="Appfile"><a href="#Appfile" class="headerlink" title="Appfile"></a>Appfile</h2><p>Appfile用来存放 <code>app_identifier</code>，<code>apple_id</code>和 <code>team_id</code>。 了解详情，它的格式是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app_identifier &quot;com.xxx.xxx&quot; # app的bundle identifier</span><br><span class="line">apple_id &quot;xxx@xxx.com&quot; # 你的Apple ID</span><br><span class="line"> </span><br><span class="line">team_id &quot;XXXXXXXXXX&quot; # Team ID</span><br><span class="line">···</span><br></pre></td></tr></table></figure><p>你也可以为每个lane(后面会讲到)提供不同的 <code>app_identifier</code>, <code>apple_id</code> 和 <code>team_id</code>，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">app_identifier &quot;com.aaa.aaa&quot;</span><br><span class="line">apple_id &quot;aaa@aaa.com&quot;</span><br><span class="line">team_id &quot;AAAAAAAAAA&quot;</span><br><span class="line"> </span><br><span class="line">for_lane :inhouse do</span><br><span class="line">  app_identifier &quot;com.bbb.bbb&quot;</span><br><span class="line">  apple_id &quot;bbb@bbb.com&quot;</span><br><span class="line">  team_id &quot;AAAAAAAAAA&quot;</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>配置好<code>Appfile</code>，fastlane就不会每一次都询问你的账号和id了</p><h2 id="Fastfile"><a href="#Fastfile" class="headerlink" title="Fastfile"></a>Fastfile</h2><p>Fastfile 管理你所创建的 lane ，<code>了解详情</code>。它的格式是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line"># 自动更新fastlane 工具</span><br><span class="line"># update_fastlane</span><br><span class="line"> </span><br><span class="line">#需要的fastlane的最小版本，在每次执行之后会检查是否有新版本，如果有会在最后末尾追加新版本提醒</span><br><span class="line">fastlane_version &quot;2.30.1&quot;</span><br><span class="line"> </span><br><span class="line">#默认使用平台是 ios，也就是说文件可以定义多个平台</span><br><span class="line">default_platform :ios</span><br><span class="line"> </span><br><span class="line">platform :ios do</span><br><span class="line">  before_all do</span><br><span class="line">    # ENV[&quot;SLACK_URL&quot;] = &quot;https://hooks.slack.com/services/...&quot;</span><br><span class="line">    cocoapods</span><br><span class="line"> </span><br><span class="line">  end</span><br><span class="line"> </span><br><span class="line">  desc &quot;Runs all the tests&quot;</span><br><span class="line">  lane :test do</span><br><span class="line">    scan</span><br><span class="line">  end</span><br><span class="line"> </span><br><span class="line">  desc &quot;提交一个新的Beta版本到 Apple TestFlight&quot;</span><br><span class="line">  desc &quot;This will also make sure the profile is up to date&quot;</span><br><span class="line">  lane :beta do</span><br><span class="line">    # match(type: &quot;appstore&quot;) # more information: https://codesigning.guide</span><br><span class="line">    gym(scheme: &quot;Docment&quot;) # Build your app - more options available</span><br><span class="line">    pilot</span><br><span class="line"> </span><br><span class="line">    # sh &quot;your_script.sh&quot;</span><br><span class="line">  end</span><br><span class="line"> </span><br><span class="line">  desc &quot;部署一个新版本到App Store&quot;</span><br><span class="line">  lane :release do</span><br><span class="line">    # match(type: &quot;appstore&quot;)</span><br><span class="line">    # snapshot</span><br><span class="line">    gym(scheme: &quot;Docment&quot;) # Build your app - more options available</span><br><span class="line">    deliver(force: true)</span><br><span class="line">    # frameit</span><br><span class="line">  end</span><br><span class="line"> </span><br><span class="line">  # 你可以定义自己的lane</span><br><span class="line"> </span><br><span class="line">  #执行lane成功后的回调</span><br><span class="line">  after_all do |lane|</span><br><span class="line">    # slack(</span><br><span class="line">    #   message: &quot;Successfully deployed new App Update.&quot;</span><br><span class="line">    # )</span><br><span class="line">  end</span><br><span class="line"> </span><br><span class="line">  # 如果流程发生异常会走这里并终止</span><br><span class="line">  error do |lane, exception|</span><br><span class="line">    # slack(</span><br><span class="line">    #   message: exception.message,</span><br><span class="line">    #   success: false</span><br><span class="line">    # )</span><br><span class="line">  end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>系统级lane      </p><table><thead><tr><th>执行顺序</th><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>before_all</td><td>在执行 lane 之前只执行一次。</td></tr><tr><td>2</td><td>before_each</td><td>每次执行 lane 之前都会执行一次。</td></tr><tr><td>3</td><td>lane</td><td>自定义的任务。</td></tr><tr><td>4</td><td>after_each</td><td>每次执行 lane 之后都会执行一次。</td></tr><tr><td>5</td><td>after_all</td><td>在执行 lane 成功结束之后执行一次。</td></tr><tr><td>6</td><td>error</td><td>在执行上述情况任意环境报错都会中止并执行一次。</td></tr></tbody></table><p>我们也可以定义一个自己的lane：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">desc &quot;企业版&quot;</span><br><span class="line">  lane :inHouse do</span><br><span class="line">  gym(scheme: &quot;XXX&quot;,</span><br><span class="line">      export_method:&quot;enterprise&quot;,</span><br><span class="line">      output_directory &quot;./build&quot;, # 打包后的 ipa 文件存放的目录</span><br><span class="line">      output_name &quot;XXX&quot;  # ipa 文件名</span><br><span class="line">   )</span><br><span class="line">  end</span><br></pre></td></tr></table></figure><p>其中一个lane就是一个任务，里面是一个个的action组成的工作流。<br>利用目前支持的工具可以做所有包含自动化和可持续化构建的每个环节，详情请查看<a href="">上篇文章的工具类</a></p><h2 id="Deliverfile"><a href="#Deliverfile" class="headerlink" title="Deliverfile"></a>Deliverfile</h2><p>交付文件。在这个文件里面可以设置iTunes connect的所有配置项，例如：</p><p><code>release_notes</code>，此版本新增内容。</p><p><code>copyright</code>，版权信息。</p><p><code>submit_for_review</code>，上传完成后是否直接提交新版本进行审查。</p><p><code>force</code>，跳过HTML报告文件验证。</p><p>…</p><p>请在设置 <code>release_nores</code> 、<code>support_url</code> 、<code>private_url</code> 等配置的时候，采用 hash 的方式写，<a href="https://www.cnblogs.com/Mien/archive/2008/08/22/1273950.html" target="_blank" rel="noopener">国家代码</a>，例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">release_notes(</span><br><span class="line"># 中国</span><br><span class="line">&apos;zh-Hans&apos; =&gt; ENV[&apos;RELEASE_NOTES&apos;],</span><br><span class="line"># 澳大利亚</span><br><span class="line">&apos;en-au&apos; =&gt; ENV[&apos;RELEASE_NOTES_AU&apos;],</span><br><span class="line"># 美国</span><br><span class="line">&apos;en-us&apos; =&gt; ENV[&apos;RELEASE_NOTES_US&apos;]</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>具体的配置可以在文章最后查看.</p><h1 id="工具使用"><a href="#工具使用" class="headerlink" title="工具使用"></a>工具使用</h1><h3 id="使用produce，在iTunes-Connect或者Apple-Developer-Center上创建新的iOS应用程序"><a href="#使用produce，在iTunes-Connect或者Apple-Developer-Center上创建新的iOS应用程序" class="headerlink" title="使用produce，在iTunes Connect或者Apple Developer Center上创建新的iOS应用程序"></a>使用produce，在iTunes Connect或者Apple Developer Center上创建新的iOS应用程序</h3><p>进入项目根目录，找到fastlane文件夹下的Fastfile文件， 编辑文件，内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">platform :ios do</span><br><span class="line"> desc &quot;create new app&quot;</span><br><span class="line"> lane :produce_app do</span><br><span class="line">   produce(</span><br><span class="line">     username: &quot;xxxx@gmail.com&quot;,# APPle ID</span><br><span class="line">     app_name: &quot;小鱼小鱼吃虾米&quot;,#App 名称</span><br><span class="line">     app_identifier: &quot;com.test.www.FastlaneTest&quot;,#App bundle id</span><br><span class="line">     app_version: &quot;1.0&quot;,#App 版本</span><br><span class="line">     sku: &quot;10023500&quot;,#App sku</span><br><span class="line">     language: &quot;Simplified Chinese&quot;,#App 语言，默认English</span><br><span class="line">   )</span><br><span class="line"> end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1533163-dabebfdee644cc43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/855" alt=""></p><p><strong>备注：language这个选项不能直接写Chinese，语言选项如下</strong><br><em>[“Brazilian Portuguese”, “Danish”, “Dutch”, “English”, “English_Australian”, “English_CA”, “English_UK”, “Finnish”, “French”, “French_CA”, “German”, “Greek”, “Indonesian”, “Italian”, “Japanese”, “Korean”, “Malay”, “Norwegian”, “Portuguese”, “Russian”, “Simplified Chinese”, “Spanish”, “Spanish_MX”, “Swedish”, “Thai”, “Traditional Chinese”, “Turkish”, “Vietnamese”]</em></p><p>在terminal中执行fastlane produce_app命令，创建成功提示如下：<br><img src="https://upload-images.jianshu.io/upload_images/1533163-ea43827f2e8ffd7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/855" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/1533163-361175ae5018d974.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/949" alt=""></p><h3 id="使用cert创建签名证书-Certificates"><a href="#使用cert创建签名证书-Certificates" class="headerlink" title="使用cert创建签名证书(Certificates)"></a>使用cert创建签名证书(Certificates)</h3><p>在Fastfile中添加以下内容</p><h4 id="生成开发证书"><a href="#生成开发证书" class="headerlink" title="生成开发证书:"></a>生成开发证书:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lane :create_certificates do</span><br><span class="line">    cert(</span><br><span class="line">      username: &quot;xxxx@gmail.com&quot;,# APPle ID</span><br><span class="line">      development: true,# 创建一个开发证书</span><br><span class="line">      force: &quot;false&quot;,#即使存在现有证书，也要创建证书，默认为false</span><br><span class="line">      output_path: &quot;./certs/development&quot;,#存储所有证书和私钥的目录的路径</span><br><span class="line">    )</span><br><span class="line">  end</span><br></pre></td></tr></table></figure><p>结果如下：<br><img src="https://upload-images.jianshu.io/upload_images/1533163-bc94a147af5bdb6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/857" alt=""></p><h4 id="生成生产证书"><a href="#生成生产证书" class="headerlink" title="生成生产证书:"></a>生成生产证书:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">lane :create_dcertificates do</span><br><span class="line">    cert(</span><br><span class="line">      username: &quot;xxxx@gmail.com&quot;,# APPle ID</span><br><span class="line">      development: false,# 创建一个开发证书</span><br><span class="line">      force: &quot;false&quot;,#即使存在现有证书，也要创建证书，默认为false</span><br><span class="line">      output_path: &quot;./certs/distribution&quot;,#存储所有证书和私钥的目录的路径</span><br><span class="line">    )</span><br><span class="line">  end</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1533163-cc38aa742b08fc2f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/845" alt=""></p><p><strong>开发和生产证书，修改development的boolean值及output_path路径即可</strong></p><h3 id="使用sigh-生成描述文件-mobileprovision"><a href="#使用sigh-生成描述文件-mobileprovision" class="headerlink" title="使用sigh 生成描述文件(mobileprovision)"></a>使用sigh 生成描述文件(mobileprovision)</h3><p>在Fastfile中</p><h4 id="生成开发mobileprovision"><a href="#生成开发mobileprovision" class="headerlink" title="生成开发mobileprovision"></a>生成开发mobileprovision</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lane :get_dev_provisioningProfile do</span><br><span class="line">  get_provisioning_profile(</span><br><span class="line">    username: &quot;xxxx@gmail.com&quot;,# APPle ID</span><br><span class="line">    development: true,# 创建一个开发mobileprovision</span><br><span class="line">    app_identifier: &quot;com.test.www.FastlaneTest&quot;,#bundle identifier</span><br><span class="line">    output_path: &quot;./certs/development&quot;,#存储mobileprovision的目录的路径</span><br><span class="line">    filename: &quot;fastlane_dev.mobileprovision&quot;,#用于生成的供应配置文件的文件名（必须包含.mobileprovision）</span><br><span class="line">  )</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1533163-db43c3e1861439bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/853" alt=""></p><h4 id="生成生产mobileprovision"><a href="#生成生产mobileprovision" class="headerlink" title="生成生产mobileprovision"></a>生成生产mobileprovision</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">lane :get_provisioningProfile do</span><br><span class="line">   get_provisioning_profile(</span><br><span class="line">     username: &quot;xxxx@gmail.com&quot;,# APPle ID</span><br><span class="line">     development: false,# 创建一个开发证书</span><br><span class="line">     app_identifier: &quot;com.test.www.FastlaneTest&quot;,#bundle identifier</span><br><span class="line">     output_path: &quot;./certs/distribution&quot;,#存储mobileprovision的目录的路径</span><br><span class="line">     filename: &quot;fastlane_distr.mobileprovision&quot;,#用于生成的供应配置文件的文件名（必须包含.mobileprovision）</span><br><span class="line">   )</span><br><span class="line"> end</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/1533163-a5eaaeed82991868.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/853" alt=""><br>找到 <code>certs/development&amp;&amp;distribution</code>目录下的证书及<code>.mobileprovision</code>文件，并安装到电脑上<br><img src="https://upload-images.jianshu.io/upload_images/1533163-de34c42dd8886483.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/595" alt=""></p><h3 id="使用gym来打包ipa"><a href="#使用gym来打包ipa" class="headerlink" title="使用gym来打包ipa"></a>使用gym来打包ipa</h3><p>示例   </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">lane :inhouse do</span><br><span class="line">  # 以下两个action来自fastlane-plugin-versioning，</span><br><span class="line">  # 第一个递增 Build，第二个设定Version。</span><br><span class="line">  # 如果你有多个target，就必须指定target的值，否则它会直接找找到的第一个plist修改</span><br><span class="line">    increment_build_number_in_plist(target: &apos;FastlaneTest&apos;)</span><br><span class="line">    increment_version_number_in_plist(</span><br><span class="line">      target: &apos;FastlaneTest&apos;,</span><br><span class="line">      version_number: &apos;1.0&apos;</span><br><span class="line">    )</span><br><span class="line">    # gym用来编译ipa</span><br><span class="line">    gym(scheme: &apos;FastlaneTest&apos;,#打包scheme</span><br><span class="line">    export_method:&quot;enterprise&quot;,#打包类型app-store, ad-hoc, enterprise, development</span><br><span class="line">    output_directory: &quot;./build&quot;,#ipa打包存放路径</span><br><span class="line">    output_name: &apos;inhouse.ipa&apos;#ipa名称</span><br><span class="line">    )</span><br><span class="line">  end</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>这里是官方提供的一些 <a href="https://github.com/fastlane/examples" target="_blank" rel="noopener">例子</a>。      </li><li>想了解 fastlane 命令的话可以执行 <code>fastlane --help</code>      </li><li>查看可用任务的列表，可以执行命令 <code>fastlane lanes</code></li><li><p>可以安装一些插件来辅助，查看插件 <code>fastlane search_plugins</code>, 比如修改版本号的 <a href="https://github.com/SiarheiFedartsou/fastlane-plugin-versioning" target="_blank" rel="noopener">versioning</a>,以及 同样功能的 <code>fastlane-plugin-versioning</code><br>安装上面的插件,使用 <code>fastlane add_plugin [name] # 安装方法</code><br>比如      </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane add_plugin versioning</span><br></pre></td></tr></table></figure></li><li><p>多个 lane 的话实际上是可以相互调用的，这个其实特别实用。例如：</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">default_platform :ios</span><br><span class="line"> </span><br><span class="line">platform :ios do</span><br><span class="line"> </span><br><span class="line">  lane :prepare do</span><br><span class="line">    cocoapods</span><br><span class="line">    match</span><br><span class="line">  end</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  desc &apos;fastlane build&apos;   &apos;fastlane build type:adhoc&apos;</span><br><span class="line">  lane :build do |options|</span><br><span class="line">    # 调用上面的 prepare 任务</span><br><span class="line">    prepare</span><br><span class="line"> </span><br><span class="line">    case options[:type]</span><br><span class="line">    when &apos;adhoc&apos;</span><br><span class="line">      adhoc</span><br><span class="line">    else</span><br><span class="line">      appstore</span><br><span class="line">    end</span><br><span class="line">  end</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  lane : adhoc do</span><br><span class="line">  ···</span><br><span class="line">  end</span><br><span class="line"> </span><br><span class="line">  lane : appstore do</span><br><span class="line">  ···</span><br><span class="line">  end</span><br><span class="line"> </span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>我们可以在 Fastfile 文件中添加一个函数来设置version号和build号。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">default_platform :ios</span><br><span class="line"> </span><br><span class="line">def prepare_version(options)</span><br><span class="line">    increment_version_number(</span><br><span class="line">        version_number: options[:version]</span><br><span class="line">    )</span><br><span class="line"> </span><br><span class="line">    increment_build_number(</span><br><span class="line">        build_number: options[:build]</span><br><span class="line">    )</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>然后可以在一个lane中使用这个函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lane :appstore do |options|</span><br><span class="line">   ···</span><br><span class="line">    prepare_version(options)</span><br><span class="line">   ···</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>然后执行这个lane的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fastlane appstore version:2.4.0 build:2.0</span><br></pre></td></tr></table></figure><h1 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h1><p><a href="https://www.jianshu.com/p/ecaca8ac86e3" target="_blank" rel="noopener">相关文章</a></p><p><a href="https://www.jianshu.com/p/44bbe1a31b52" target="_blank" rel="noopener">fastlane 实现自定义Action</a></p><p><a href="https://www.jianshu.com/p/46118a562b5b" target="_blank" rel="noopener">使用fastlane自动增加版本号</a></p><h4 id="Deliverfile-编辑示例"><a href="#Deliverfile-编辑示例" class="headerlink" title="Deliverfile 编辑示例"></a><a href="https://docs.fastlane.tools/actions/deliver/" target="_blank" rel="noopener">Deliverfile 编辑示例</a></h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"># app_identifier</span><br><span class="line">app_identifier ENV[&apos;APP_IDENTIFIER&apos;]</span><br><span class="line"># 用户名,Apple ID电子邮件地址</span><br><span class="line">username ENV[&apos;APPLE_ID&apos;]</span><br><span class="line"># 团队ID</span><br><span class="line">team_id ENV[&apos;TEAM_ID&apos;]</span><br><span class="line"># 团队name</span><br><span class="line">team_name ENV[&apos;TEAM_NAME&apos;]</span><br><span class="line"># copyright</span><br><span class="line">copyright ENV[&apos;COPYRIGHT&apos;]</span><br><span class="line"># 关键字</span><br><span class="line">keywords(</span><br><span class="line">    &apos;zh-Hans&apos; =&gt; ENV[&apos;KEYWORDS&apos;],</span><br><span class="line">)</span><br><span class="line"># 新版本修改记录</span><br><span class="line">release_notes(</span><br><span class="line">    # 中国</span><br><span class="line">    &apos;zh-Hans&apos; =&gt; ENV[&apos;RELEASE_NOTES&apos;],</span><br><span class="line">    # 澳大利亚</span><br><span class="line">    &apos;en-au&apos; =&gt; ENV[&apos;RELEASE_NOTES_AU&apos;],</span><br><span class="line">    # 美国</span><br><span class="line">    &apos;en-us&apos; =&gt; ENV[&apos;RELEASE_NOTES_US&apos;]</span><br><span class="line">)</span><br><span class="line"># 支持网址</span><br><span class="line">support_url(</span><br><span class="line">    # 中国</span><br><span class="line">    &apos;zh-Hans&apos; =&gt; ENV[&apos;SUPPORT_URL&apos;],</span><br><span class="line">    # 澳大利亚</span><br><span class="line">    &apos;en-au&apos; =&gt; ENV[&apos;SUPPORT_URL_AU&apos;],</span><br><span class="line">    # 美国</span><br><span class="line">    &apos;en-us&apos; =&gt; ENV[&apos;SUPPORT_URL_US&apos;]</span><br><span class="line">)</span><br><span class="line"># 隐私政策网址 国家代码 https://www.cnblogs.com/Mien/archive/2008/08/22/1273950.html</span><br><span class="line">privacy_url(</span><br><span class="line">    # 中国</span><br><span class="line">    &apos;zh-Hans&apos; =&gt; ENV[&apos;PRIVACY_URL&apos;],</span><br><span class="line">    # 澳大利亚</span><br><span class="line">    &apos;en-au&apos; =&gt; ENV[&apos;PRIVACY_URL_AU&apos;],</span><br><span class="line">    # 美国</span><br><span class="line">    &apos;en-us&apos; =&gt; ENV[&apos;PRIVACY_URL_US&apos;]</span><br><span class="line">)</span><br><span class="line"># 上传完成后提交新版本进行审查</span><br><span class="line">submit_for_review false</span><br><span class="line"># 跳过HTML报告文件验证</span><br><span class="line">force true</span><br><span class="line"># 启用iTC的分阶段发布功能 灰度发布</span><br><span class="line">phased_release true</span><br><span class="line"># 应用审核小组的联系信息 app 审核信息</span><br><span class="line">app_review_information(</span><br><span class="line">  first_name: &quot;xx&quot;,</span><br><span class="line">  last_name: &quot;xx&quot;,</span><br><span class="line">  phone_number: &quot;+86 18888888888&quot;,</span><br><span class="line">  email_address: &quot;xxxx&quot;,</span><br><span class="line">  demo_user: &quot;test1@test.com&quot;,</span><br><span class="line">  demo_password: &quot;test123&quot;</span><br><span class="line">)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/867b397c7939" target="_blank" rel="noopener">fastlane工具 之 build_app 和 upload_to_app_store</a></p><p>最后，附上一个Fastfile脚本和一些自定义Actions：<br><a href="https://github.com/thierryxing/Fastfiles" target="_blank" rel="noopener">https://github.com/thierryxing/Fastfiles</a></p><p>另外，Fastlane也提供了一些国外团队的Example：<br><a href="https://github.com/fastlane/examples" target="_blank" rel="noopener">https://github.com/fastlane/examples</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;打包到-AppStore&quot;&gt;&lt;a href=&quot;#打包到-AppStore&quot; class=&quot;headerlink&quot; title=&quot;打包到 AppStore&quot;&gt;&lt;/a&gt;打包到 AppStore&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;&quot;&gt;上篇文章&lt;/a&gt; 我们已经成功的打包app到蒲公英了。那么我们也可以尝试将app上传到AppStore.&lt;br&gt;废话不多说，先简单的打包一个 ipa 到 AppStore 。  &lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Fastlane 安装 和 发布到蒲公英</title>
    <link href="https://476139183.github.io/2018/09/18/Fastlane-%E5%AE%89%E8%A3%85/"/>
    <id>https://476139183.github.io/2018/09/18/Fastlane-安装/</id>
    <published>2018-09-18T06:53:54.000Z</published>
    <updated>2018-10-11T08:35:17.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h1><blockquote><p>在使用Fastlane打包之前，你的项目必须是正确的。我的意思是说，你得用原生的方式成功Archive，并可以upload你的测试项目！否则会导致Fastlane打包失败<br><a id="more"></a><br>当你看到这篇文章的时候，说明你已经厌烦不停的打包等一系列<code>没有技术含量的、乏味</code>的工作,然后会去寻找偷懒的方法，于是找到了 <code>Fastlane</code> ，因为 <a href="https://github.com/fastlane/fastlane" target="_blank" rel="noopener">Fastlane</a> 在网上有很多资料，也介绍了蛮多，这里只是简单的点出一些重点。        </p></blockquote><p>Fastlane命令是一个流程控制的命令行工具(CLI)，通过内部集成action和第三方的action完成一系列控制流程。运行Fastlane命令行工具，会读取当前目录或者 <code>./fastlane</code> 目录下的 <code>Fastfile</code> 配置文件。</p><blockquote><p>在Fastfile中：</p></blockquote><blockquote><blockquote><p><code>action</code> :  Fastlane中的每一条命令都是一个扩展(action)，下面提到的deliver，sigh之类的工具本身是CLI，但是在Fastlane中内嵌了对他们支持的action<br><code>lane</code> : Fastlane中流程的合集，每一个动作即可以是action，也可以是其他的lane。语法和ruby中的rake非常像</p></blockquote></blockquote><h1 id="Fastlane组件"><a href="#Fastlane组件" class="headerlink" title="Fastlane组件"></a>Fastlane组件</h1><p><code>不是一个人的王者，而是团队的荣誉</code>, Fastlane 是一套基于 Ruby 的工具集合，它包括了诸多工具:</p><ul><li>测试<ul><li><code>scan</code> =&gt; 自动运行测试工具，并且可以生成漂亮的HTML报告 </li></ul></li><li>证书，配置文件<ul><li><code>cert</code> =&gt; 自动创建管理iOS代码签名证书</li><li><code>sigh</code> =&gt; 是用来创建、更新、下载、修复Provisioning Profile的工具</li><li><code>pem</code> =&gt; 自动生成、更新推送配置文件</li><li><code>match</code> =&gt; 一个新的证书和配置文件管理工具,它会把所有需要用到的证书传到git私有库上，任何需要配置的机器直接用match同步回来就不用管证书问题了，小团队福音啊！</li></ul></li><li>截图<ul><li><code>snapshot</code> =&gt; 用Xcode7推出的UI test功能实现自动化截图</li><li><code>frameit</code> =&gt; 可以把截的图片自动套上一层手机的物理边框</li></ul></li><li>编译<ul><li><code>gym</code> =&gt; Fastlane家族的自动化编译工具，和其他工具配合的非常默契</li></ul></li><li>发布<ul><li>produce =&gt; 如果你的产品还没在iTunes Connect(iTC)或者Apple Developer Center(ADC)建立，produce可以自动帮你完成这些工作</li><li>deliver =&gt; 自动上传截图，APP的元数据，二进制(ipa)文件到iTunes Connect</li></ul></li><li>TestFlight管理<ul><li><code>pilot</code> =&gt; 管理TestFlight的测试用户，上传二进制文件</li><li><code>boarding</code> =&gt; 建立一个添加测试用户界面，发给测试者，可自行添加邮件地址，并同步到iTC</li></ul></li></ul><blockquote><p>更多工具可以去查看<a href="https://docs.fastlane.tools" target="_blank" rel="noopener">官方文档</a></p></blockquote><h1 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h1><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><h4 id="检查-Xcode-CLT-是否安装"><a href="#检查-Xcode-CLT-是否安装" class="headerlink" title="检查 Xcode CLT 是否安装"></a>检查 Xcode CLT 是否安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure><p>如果终端提示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select: error: command line tools are already installed, use &quot;Software Update&quot; to install updates</span><br></pre></td></tr></table></figure></p><p>说明已经安装成功</p><h4 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h4><p>确保已经安装好 <code>ruby</code>、<code>rubygems</code>、<code>bundler</code>，Fastlane要求Ruby版本，当前最新版本要求ruby版本&gt;=2.1。使用以下命令查看ruby版本:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ruby -v</span><br></pre></td></tr></table></figure></p><p>相关链接:      </p><p><a href="http://www.cnblogs.com/foxting/p/4520829.html" target="_blank" rel="noopener">《MAC机中安装RUBY环境》</a><br><a href="https://blog.csdn.net/maojudong/article/details/7918291/" target="_blank" rel="noopener">《Ruby系列文章之6 —OS X 10.8.1 系统 HomeBrew 的安装和简单使用》</a></p><h3 id="安装fastlane"><a href="#安装fastlane" class="headerlink" title="安装fastlane"></a>安装fastlane</h3><p>最新的安装命令如下：<a href="https://blog.csdn.net/top_roboo/article/details/52087192" target="_blank" rel="noopener">解决方法</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install -n /usr/local/bin fastlane</span><br></pre></td></tr></table></figure><p>彻底解决方法 <a href="https://www.macx.cn/thread-2167166-1-5.html?mod=viewthread&amp;tid=2167166&amp;extra=page%253D5&amp;page=1" target="_blank" rel="noopener">解除 OSX 10.11 Rootless 的方法</a> </p><blockquote><p>该命令可以用来更新fastlane</p></blockquote><p>如果不是最新版本 还可以在项目文件里面执行指定版本来更新</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo gem install -n /usr/local/bin/ fastlane --version2.104.0</span><br></pre></td></tr></table></figure><p>检查版本 fastlane    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">fastlane -v</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">安装参考于该[文章](https://www.jianshu.com/p/abc2063f0981)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 初始化 ###</span><br><span class="line">打开[Terminal(终端)](sudo launchctl load -w /System/Library/LaunchDaemons/ssh.plist)，进入项目根目录下，初始化fastlane</span><br></pre></td></tr></table></figure><p>fastlane init<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">出现如下选项，`一般选择第4项`：      </span><br><span class="line">![](https://ws1.sinaimg.cn/large/006tNbRwgy1fvelhb6udrj30ve0k8zor.jpg) </span><br><span class="line"> 选项含义:</span><br><span class="line">    </span><br><span class="line"> * ① 自动化截图</span><br><span class="line"> * ② 将测试版分发自动化到TestFlight</span><br><span class="line"> * ③ 自动上传、发布到App Store</span><br><span class="line"> * ④ 手动设置 - 手动设置您的项目以使您的任务自动化</span><br><span class="line"> </span><br><span class="line">然后，输入开发者账号密码      </span><br><span class="line"></span><br><span class="line">![](https://upload-images.jianshu.io/upload_images/1533163-1fd4760349f624e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/587)</span><br><span class="line"></span><br><span class="line">以上就表示成功安装了Fastlane</span><br><span class="line"></span><br><span class="line">如果遇到下面的问题，一直卡在不动</span><br><span class="line">![](https://ws1.sinaimg.cn/large/006tNbRwgy1fveljinsb7j30vo0aiq50.jpg)</span><br><span class="line"></span><br><span class="line">那么可以不用管他，`关闭终端`或者`终止命令`即可。</span><br><span class="line"></span><br><span class="line">![](https://ws4.sinaimg.cn/large/006tNbRwgy1fvello1s6ej305i03j74m.jpg)</span><br><span class="line">## 发布到蒲公英（可选）##</span><br><span class="line">详情请移步[蒲公英](https://www.pgyer.com/doc/view/fastlane)</span><br><span class="line"></span><br><span class="line">### 安装蒲公英的 fastlane 插件 ###</span><br><span class="line">在`项目根`目录下，安装蒲公英插件:</span><br></pre></td></tr></table></figure></p><p>fastlane add_plugin pgyer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">稍等几秒钟</span><br><span class="line">如果出现类似下面的信息，就说明安装成功了：</span><br><span class="line">![](https://ws1.sinaimg.cn/large/006tNbRwgy1fvet3cqvatj30vc08i40m.jpg)</span><br><span class="line">期间会询问是否可以修改文件信息，选择`y`即可</span><br><span class="line"></span><br><span class="line">### 编辑 ###</span><br><span class="line">Fastlane 会自动在 App 目录中生成 fastlane 目录，其中就会有 Fastlane 的配置文件 fastlane/Fastfile，这里，我们用 vim 打开：</span><br></pre></td></tr></table></figure></p><p>vim ./fastlane/Fastfile<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">然后，我们找到我们在用的工作流（action），在 build_app 指令后，加入蒲公英插件的配置信息。例如：</span><br></pre></td></tr></table></figure></p><p>lane :beta do<br>  build_app(export_method: “development”)<br>  pgyer(api_key: “7f15xxxxxxxxxxxxxxxxxx141”, user_key: “4a5bcxxxxxxxxxxxxxxx3a9e”)<br>end<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; 注意：</span><br><span class="line"></span><br><span class="line">&gt;以上的 `api_key` 和 `user_key`，请开发者在自己账号下的 `应用管理` - `App概述` - `API` 中可以找到，并替换到以上相应的位置。</span><br><span class="line">&gt;在 Xcode 8.3 和 Xcode 8.3 以后的版本中，对于 `build_app` 的 `export_method` 的值，需要根据开发者的打包类型进行设置，可选的值有：`app-store`、`ad-hoc`、`development`、`enterprise`。对于 Xcode 8.3 以下的版本，则不需要设置 `export_method`。</span><br><span class="line"></span><br><span class="line">### 打包并自动上传 App 到蒲公英 ###</span><br><span class="line">经过以上配置后，就可以使用 Fastlane 来打包 App，并自动上传到蒲公英了。在终端下，定位到项目所在目录，输入以下命令即可：</span><br></pre></td></tr></table></figure></p><p>fastlane beta<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后就充满激情的等待      </span><br><span class="line"></span><br><span class="line">![](https://ws2.sinaimg.cn/large/006tNbRwgy1fvdrmzvucwg305a05aq3g.gif)      </span><br><span class="line"></span><br><span class="line">最后打包成功提示</span><br><span class="line"></span><br><span class="line">![蒲公英](https://ws1.sinaimg.cn/large/006tNbRwgy1fvelgi3hnaj30vi0cmjsz.jpg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 其他 #</span><br><span class="line"></span><br><span class="line">### 卸载 ####</span><br></pre></td></tr></table></figure></p><p>gem/brew uninstall fastlane<br><code>`</code></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>在项目中手动删除 fastlane文件夹即可。</p><h1 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h1><h4 id="插件安装格式"><a href="#插件安装格式" class="headerlink" title="插件安装格式"></a>插件安装格式</h4><p>fastlane add_plugin [name], 需要到项目根目录下执行。</p><p>fastlane update_plugins [name], 插件更新，同上，需要cd到项目根目录下。</p><p>完成了发布到蒲公英之后肯定不再仅仅满足于此，毕竟 Fastlane 是集成一系列的自动化工具的，后面会进行一些详细的操作，比如上传到 <code>APP Store Connect</code>.详情请移步 <a href="">Fastlane (二)</a>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前沿&quot;&gt;&lt;a href=&quot;#前沿&quot; class=&quot;headerlink&quot; title=&quot;前沿&quot;&gt;&lt;/a&gt;前沿&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在使用Fastlane打包之前，你的项目必须是正确的。我的意思是说，你得用原生的方式成功Archive，并可以upload你的测试项目！否则会导致Fastlane打包失败&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="工具" scheme="https://476139183.github.io/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="自动化" scheme="https://476139183.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"/>
    
      <category term="Fastlane" scheme="https://476139183.github.io/tags/Fastlane/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL EL (二)</title>
    <link href="https://476139183.github.io/2018/09/18/OpenGL-EL-%E4%BA%8C/"/>
    <id>https://476139183.github.io/2018/09/18/OpenGL-EL-二/</id>
    <published>2018-09-18T01:19:50.000Z</published>
    <updated>2018-12-13T05:57:40.762Z</updated>
    
    <content type="html"><![CDATA[<p>Open GL 是不可能再学了，这辈子都不可能，学又学不会，只能随便贴一些图凑才能维持的了生活。幸好百度里面有很多大佬，个个都是人才，说话又好听，还乐于助人，写了很多教程，我超喜欢抄袭百度里面的东西。</p><a id="more"></a><p>是的，很遗憾，我还是咬牙继续看下去。</p><p><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fvpgwbrpcsg30f709tqv7.gif" alt=""></p><p>退后，我要开始装逼了。。。</p><h2 id="前沿"><a href="#前沿" class="headerlink" title="前沿"></a>前沿</h2><p><a href="https://476139183.github.io/2018/09/06/OpenGL-ES-一/">上一篇 OpenGL ES (一) </a> 提到了一些基本的概念，这一次不出意外，还是继续了解一些基本的 Api 或者 使用流程</p><h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>和任何程序一样，OpenGL程序需要输入，然后经过渲染管线，即一系列的着色器（着色器贯穿本书的始终），最后得到一个二维图像（像素矩阵），见下图。</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fy52sq6qrkj30n509qdgj.jpg" alt=""></p><p>所以在调用OpenGL API进行绘制图像之前，先将所需数据加载到显存中，以便于OpenGL在绘制时对其进行相关处理。填充后的代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"> 1 #include &lt;iostream&gt;</span><br><span class="line"> 2 #include &quot;StdAfx.h&quot;</span><br><span class="line"> 3 </span><br><span class="line"> 4 GLuint Buffer_ID;</span><br><span class="line"> 5 const int BUFFER_NUMBER = 1;</span><br><span class="line"> 6 </span><br><span class="line"> 7 GLuint VAO_ID;</span><br><span class="line"> 8 GLuint VAO_NUMBER = 1;</span><br><span class="line"> 9 </span><br><span class="line">10 const int VERTICES_NUMBER = 6;</span><br><span class="line">11 const int vPosition = 0;</span><br><span class="line">12 </span><br><span class="line">13 void Initialize()</span><br><span class="line">14 &#123;</span><br><span class="line">15     //---------------------准备数据-------------------------------</span><br><span class="line">16     GLfloat vertices[VERTICES_NUMBER][2] = </span><br><span class="line">17     &#123;</span><br><span class="line">18         &#123; -0.90, -0.90 &#125;,</span><br><span class="line">19         &#123;  0.85, -0.90 &#125;,</span><br><span class="line">20         &#123; -0.90,  0.85 &#125;,</span><br><span class="line">21 </span><br><span class="line">22         &#123;  0.90, -0.85 &#125;,</span><br><span class="line">23         &#123;  0.90,  0.90 &#125;,</span><br><span class="line">24         &#123; -0.85,  0.90 &#125;</span><br><span class="line">25     &#125;;</span><br><span class="line">26 </span><br><span class="line">27     // 生成缓存对象</span><br><span class="line">28     glGenBuffers(BUFFER_NUMBER, &amp;Buffer_ID);</span><br><span class="line">29 </span><br><span class="line">30     // 绑定缓存对象</span><br><span class="line">31     glBindBuffer(GL_ARRAY_BUFFER, Buffer_ID);</span><br><span class="line">32 </span><br><span class="line">33     // 填入数据</span><br><span class="line">34     glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">35 </span><br><span class="line">36     //-------------------设置顶点数据属性------------------------------</span><br><span class="line">37     // 生成顶点数组对象</span><br><span class="line">38     glGenVertexArrays(VAO_NUMBER, &amp;VAO_ID);</span><br><span class="line">39 </span><br><span class="line">40     // 绑定顶点数组对象</span><br><span class="line">41     glBindVertexArray(VAO_ID);</span><br><span class="line">42 </span><br><span class="line">43     // 设置顶点属性</span><br><span class="line">44     glVertexAttribPointer(vPosition, 2, GL_FLOAT, GL_FALSE, 0, BUFFER_OFFSET(0));</span><br><span class="line">45     glEnableVertexAttribArray(vPosition);</span><br><span class="line">46 &#125;</span><br><span class="line">47 </span><br><span class="line">48 void display()</span><br><span class="line">49 &#123;</span><br><span class="line">50     glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">51 </span><br><span class="line">52     glBindVertexArray(VAO_ID);</span><br><span class="line">53     glDrawArrays(GL_TRIANGLES, 0, VERTICES_NUMBER);</span><br><span class="line">54 </span><br><span class="line">55     glFlush();</span><br><span class="line">56 &#125;</span><br><span class="line">57 </span><br><span class="line">58 int main(int argc, char **argv)</span><br><span class="line">59 &#123;</span><br><span class="line">60     glutInit(&amp;argc, argv);</span><br><span class="line">61     glutInitDisplayMode(GLUT_RGBA);</span><br><span class="line">62     glutInitWindowSize(512, 512);</span><br><span class="line">63     glutInitContextVersion(3, 3);</span><br><span class="line">64     glutInitContextProfile(GLUT_CORE_PROFILE);</span><br><span class="line">65     glutCreateWindow(argv[0]);</span><br><span class="line">66 </span><br><span class="line">67     glewExperimental = TRUE;</span><br><span class="line">68     if (glewInit())</span><br><span class="line">69     &#123;</span><br><span class="line">70           std::cerr &lt;&lt; &quot;Unable to initialize GLEW... Exiting...&quot; &lt;&lt; std::endl;</span><br><span class="line">71         std::exit(EXIT_FAILURE);</span><br><span class="line">72     &#125;</span><br><span class="line">73 </span><br><span class="line">74     Initialize();</span><br><span class="line">75     glutDisplayFunc(display);</span><br><span class="line">76     glutMainLoop();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="数据输入步骤"><a href="#数据输入步骤" class="headerlink" title="数据输入步骤"></a>数据输入步骤</h2><p>任何系统都有输入输出（I/O）系统，如计算机硬件系统中有输入设备和输出设备；每一个编程语言都有自己的输入命令（类）和输出命令（类）；对于一个算法来说，也有其输入和输出。</p><p>对于我们图形绘制系统来说，自然也少不了输入和输出。由于数据的输入只需要执行一次就可以，故写在Initialize函数中，并在main函数是执行。</p><p>本例要绘制两个三角形，输入的数据自然就是两个三角形的顶点数据。由于绘制的是平面三角形，我们可以不指定z方向的坐标值（深度值）。16~25行的二维顶点数组是存放在内存中的，图形绘制是在显卡中执行的，所以需要将这些数据加载到显存中。这里出现了OpenGL编程中第一个重要的概念—— <code>缓存对象（Buffer Object）</code>。顾名思义，这一对象主要就是用来存放数据的，在这里，我们使用缓存来存放顶点数据。下面，我们来看看程序中是怎么使用缓存对象来加载顶点数据的。</p><p>加载顶点数据到显存用了3条OpenGL API来实现数据的加载。</p><h3 id="声明一个缓存对象ID"><a href="#声明一个缓存对象ID" class="headerlink" title="声明一个缓存对象ID"></a>声明一个缓存对象ID</h3><p>I：使用 <code>glGenBuffer</code> 声明一个缓存对象ID。编程语言中通过变量的方式来标识内存中的数据；操作系统中通过各种ID来感知各个实体，如进程标识符PID来标识进程，线程标识符TID来标识线程。OpenGL也是通过ID来标识各种对象。由于这里只要使用一个缓存对象，所以只要生成一个缓存ID即可，但要注意，这条指令可以生成多个缓存对象。</p><h3 id="绑定其中一个缓存"><a href="#绑定其中一个缓存" class="headerlink" title="绑定其中一个缓存"></a>绑定其中一个缓存</h3><p>II：使用glBindBuffer来绑定其中一个缓存。刚才已经提到，缓存对象可以有多个，那OpenGL怎么知道要当前操作的是哪个缓存对象呢？这就需要使用glBindBuffer命令——这个命令的作用就是激活（Activate）其中一个缓存对象。参数很简单，就是刚才生成的缓存ID。</p><h3 id="分配内存并拷贝数据到显存"><a href="#分配内存并拷贝数据到显存" class="headerlink" title="分配内存并拷贝数据到显存"></a>分配内存并拷贝数据到显存</h3><p>III：使用glBufferData来分配内存并拷贝数据到显存。这一步是我们最终目的——将数据从内存拷贝至显存。这个函数和C语言中内存拷贝memcpy很类似，函数签名为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void glBufferData(GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);</span><br></pre></td></tr></table></figure><blockquote><p>target　　—— 刚才绑定（激活）的缓存对象，这可以看做memcpy的目的地址；</p></blockquote><blockquote><p>size　　　—— 这就是数据的大小，这和memcpy中的数据大小是一样的；</p></blockquote><blockquote><p>data　　 —— 源数据的指针，这和memcpy中的源数据指针是一样的；</p></blockquote><blockquote><p>usage　　—— 这个参数指定这个数据的用法，主要是为了优化OpenGL的内存管理——根据使用方法确定最优显存分配方案。 </p></blockquote><p>通过使用上述三条OpenGL API，我们就完成了数据从内存加载到缓存的功能。到此为止，故事还没有结束，OpenGL在获取顶点数据时并不知道缓存对象中的数据如何解析，所以需要告诉OpenGL，刚才上传的数据的格式是怎么样的。这就引入了第二个对象——顶点数组对象及顶点属性的概念。顶点数组对象就是用来描述刚才上传的顶点数据特征的一个对象，下面就继续来分析与顶点数组对象的相关API。</p><p>I：使用glGenVertexArray声明一个顶点数组对象ID。这和缓存对象ID是一样的，都是为了便于OpenGL的组织管理；</p><p>II：使用glBindVertexArray来激活其中的一个顶点数组对象，和缓存对象也是类似的；</p><p>III：使用glVertexAttribPointer接口来填充当前绑定的顶点数组对象。这个函数的功能和缓存对象的glBindBuffer命令是一样的，只是对于缓存对象来说，只要拷贝一下数据就可以了，而这里需要填充顶点属性数据（就像填充一个结构体一样）。这个函数的参数比较多，其函数签名为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">void glVertexAttribPointer(GLuint index, GLsize size, GLint size, GLenum type, GLboolean normalized, GLsizei stribe, const GLvoid *pointer);</span><br></pre></td></tr></table></figure><blockquote><p>index　　  　　——这是指定在该顶点在着色器中的属性。</p></blockquote><blockquote><p>size　　   　　  ——该参数指定了每个顶点有几个分量，本例中二维顶点，故设为2；</p></blockquote><blockquote><p>type　　  　　  ——该参数指定了顶点中分量的数据类型，这里顶点的坐标分量是浮点型数据，故设为GL_FLOAT；</p></blockquote><blockquote><p>normalized　　——该参数表示顶点存储前是否需要进行归一化；</p></blockquote><blockquote><p>stride　　　　  ——该参数指定两个顶点数据之间间隔的字节数，在本例中，顶点是连续存储的，故设为0；</p></blockquote><blockquote><p>pointer　　　　——顶点数据在缓存对象中起始地址，在本例中，因为缓存对象中只存放了一个顶点数组，所以这一值设为0。</p></blockquote><p>IV: 使用glEnableVertexAttribArray来启用与index索引相关联的顶点数组。虽然前面设置了顶点数组属性，但如果没有启用的话，数据依然无法被OpenGL拿到。</p><ol start="2"><li>图形绘制步骤</li></ol><p>数据及其格式设置后之后，就是根据这一数据进行图形的绘制。这部分代码是写在display函数中的，这一函数可能会调用多次。在这个显示函数中，最重要的一个OpenGL API就是glDrawArray函数——绘制基本图形，其函数签名如下：</p><p>void glDrawArray(GLenum mode, GLint first, GLsizei count);</p><p>mode　　——指定你要绘制的图元类型，比如三角形是GL_TRIANGLES，直线就是GL_LINES，闭合的直线就是GL_LINE_LOOP，顶点就是GL_POINTS。本例中要绘制三角形，故设为GL_TRIANGLES。</p><p>first　　　——指定绘制图形时的起始顶点，本例中从第0个顶点开始；</p><p>count　　——要绘制的顶点数，本例中设置为6。</p><p>给这个函数设置不同的值，将出现不同的效果——可以使用不同的顶点来绘制不同的图形。</p><p>剩下的，三个接口：</p><p>glClear(GLbitfield mask);</p><p>清空指定的缓存数据。每一次新的绘制，当然需要将上一次绘制过程中产生的一些数据给清空，以防止其对后一次绘制产生影响。在OpenGL中有三种缓存数据，分别是颜色缓存，深度缓存和模板缓存。其中深度缓存只有在三维的情形中才用到。本例中清空了颜色缓存。</p><p>glFlush()；</p><p>这个接口是一个同步接口——等待绘制完成再往下执行。这里需要说明的是，OpenGL采用的是客户机-服务器模式运作的——我们的应用程序就是客户机，显卡就是服务器。每一次执行OpenGL API相当于给显卡发送一条命令，一般情况下，这些命令是以异步的方式执行的。如果我们应用程序需要等显卡命令执行完毕才能往下执行，就需要调用这个函数。</p><p>最后一个，glBindVertexArray——绑定操作对象，即glDrawArray绘制的是当前绑定的顶点数组。在本例中（只限本例）是可以不调用的，因为在Initialize函数中已经调用过了，并且display函数中没有其他的绑定。</p><p>至此，我们运行程序，应该能够看到绘制出来的是两个白色的三角形。</p><h2 id="第三步：添加着色器"><a href="#第三步：添加着色器" class="headerlink" title="第三步：添加着色器"></a>第三步：添加着色器</h2><p>我们先来看看OpenGL中的绘制管线，如下图所示：</p><p>&lt;未完成 待续&gt;</p><p>参考文章:<br><a href="https://www.cnblogs.com/android-blogs/p/5454698.html" target="_blank" rel="noopener">OpenGL学习之路</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Open GL 是不可能再学了，这辈子都不可能，学又学不会，只能随便贴一些图凑才能维持的了生活。幸好百度里面有很多大佬，个个都是人才，说话又好听，还乐于助人，写了很多教程，我超喜欢抄袭百度里面的东西。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://476139183.github.io/categories/iOS/"/>
    
    
      <category term="进阶" scheme="https://476139183.github.io/tags/%E8%BF%9B%E9%98%B6/"/>
    
      <category term="OpenGL" scheme="https://476139183.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL ES (一)</title>
    <link href="https://476139183.github.io/2018/09/06/OpenGL-ES-%E4%B8%80/"/>
    <id>https://476139183.github.io/2018/09/06/OpenGL-ES-一/</id>
    <published>2018-09-06T07:34:08.000Z</published>
    <updated>2018-10-09T03:29:19.481Z</updated>
    
    <content type="html"><![CDATA[<!--<div align=center>![1](http://d-pic-image.yesky.com/1080x-/uploadImages/2017/014/00/FP43CP909564.jpg)<div>--><p>最近，斗破苍穹电视剧上映的，里面的梗就不用多提， <code>三十年河东，三十年河西，莫欺少年穷</code> 指不定口碑低开高走呢。<br>人生也是一样, 无法预料,学历代表你的过去，能力代表你的现在，学习代表你的将来.<br>所以学无止境，需精益求精，不断的学习，才能蹒跚前行。    </p><a id="more"></a><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>OpenGL ES （Open Graphics Library for Embedded Systems）是访问类似 iPhone 和 iPad 的现代嵌入式系统的 2D 和 3D 图形加速硬件的标准。<br>把程序提供的几何数据转换为屏幕上的图像的过程叫做渲染。<br>GPU 控制的缓存是高效渲染的关键。容纳几何数据的缓存定义了要渲染的点、线段和三角形。<br>OpenGL ES 3D 的默认坐标系、顶点和矢量为几何数据的描述提供了数学基础。<br>渲染的结果通常保存在帧缓存中。有两个特别的帧缓存，前帧缓存和后帧缓存，它们控制着屏幕像素的最终颜色。<br>OpenGL ES 的上下文保存了 OpenGL ES 的状态信息，包括用于提供渲染数据的缓存地址和用于接收渲染结果的缓存地址。</p></blockquote><p>OpenGL ES 是 OpenGL 的子集，它移除了 OpenGL 中冗余的函数，使其更易学也更容易在移动图形硬件中实现。</p><p>OpenGL ES 是基于 C 语言的 API ，所以可以无缝移植到 Objective—C 中，然后通过创建上下文来接收命令和操纵帧缓存。</p><p>在 iOS 中，使用 OpenGL ES 时，还可以使用 GLKit 框架中的 GLKView 将 OpenGL ES 绘制的内容渲染到屏幕上，并且可以使用 GLKViewController 来管理 GLKView 视图。另外，还可以使用 CAEAGLLayer 图层将动画与视图相结合。</p><blockquote><p>但是，需要注意的是，当应用处于后台状态时，不能调用 <em>OpenGL ES</em> 中的函数，否则应用便会被终止，而且 OpenGL ES 中的上下文也不支持在同一时刻被不同的线程访问。</p></blockquote><p>作为新手入门，我打算先了解一下 OpenGL 的一些基本概念</p><h2 id="渲染管道-Graphics-Pipeline"><a href="#渲染管道-Graphics-Pipeline" class="headerlink" title="渲染管道 (Graphics Pipeline)"></a>渲染管道 (Graphics Pipeline)</h2><p>管道，英文名叫Pipeline，相信用过FaceBook图片加载库的同学对这个管道并不陌生，因为SimpleImageDrawee里面也是用的管道来对图片进行的一个处理。由于其底层也是C，因此我可以大胆的猜想，FaceBook图片加载库的设计思路可能有参考OpenGL（这当然纯属臆想^_^）。<br>管道用正确的计算机语言来描述就是：<br>显卡执行的、从几何体到最终渲染图像的、数据传输处理计算的过程。</p><p>即是管道，那就得有先后顺序。整体是从上游流到下游。<br>在OpenGL ES1.x中，它是固定管道，整体是封闭的，中间的各道工艺按固定的流程顺序走。看下图： </p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fw0vcoxubsj30qm0gvdi1.jpg" alt=""></p><p>从上图可以看出，这些工艺顺序是固定的。整个过程又可以分成三部分：<code>处理顶点</code> 、<code>处理片元</code> 、<code>验证片元信息并存入内存</code> 。       </p><p>Rasterizer:光栅化处理，当顶点处理完后，会交给rasterizer来进行光栅化处理，结果会把顶点的坐标信息转换成能在屏幕显示的像素信息即片元(fragments)。生成片元后，接下来就是对fragments片元的各种验证，即过滤掉无用的片元，裁剪掉不在视野内的片元，最终把有效片元存储入内存中。</p><h2 id="OpenGL-组成"><a href="#OpenGL-组成" class="headerlink" title="OpenGL 组成"></a>OpenGL 组成</h2><p> OpengGL 主要包括三个要素： 原件（Primitives） 缓冲区（Buffers） 光栅化（Rasterisation）</p><h3 id="原件-图元装配"><a href="#原件-图元装配" class="headerlink" title="原件(图元装配)"></a>原件(图元装配)</h3><blockquote><p>在顶点着色器程序输出顶点坐标之后，各个顶点被按照绘制命令中的图元类型参数，以及顶点索引数组被组装成一个个图元。</p></blockquote><p>原件 包括 点, 线 三角形。有的OpenGL版本还包括四边形，但在OpengGL ES中只有这三种原件,</p><p>OpenGL 绘制的都是图形，包括形状和填充，基本形状是三角形。其它的复杂图元都是基于这些基本图元来绘成的<br>每个形状都有顶点，Vertix，顶点的序列就是一个图形。<br>图形有所谓的正反面，如果我们看向一个图形，它的顶点序列是逆时针方向，那我们看到的就是正面。</p><p>在 <code>图元装配(Primitive Assembly)</code>阶段，那些经过顶点着色器(VertexShader)处理过的顶点数组或缓冲区的数据(VertexArrays/Buff Objects),被组装到一个个独立的几何图形中(eg:点，线，三角形等)。       </p><p>对装配好的每一个图元，都必须确保它在世界坐标系（即能显示在屏幕的可见区域）中，而对于不在世界坐标系中的图元，就必须进行裁剪，使其处在世界坐标系中才能流到下一道工序(光栅化处理)。   </p><p>在这里注意下还有一个剔除操作（Cull），前提是这个功能的开关是打开的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLES20.glEnable(GLES20.GL_CULL_FACE); //剔除的是图元的背影，阴影，背面等。</span><br></pre></td></tr></table></figure><h3 id="缓存区"><a href="#缓存区" class="headerlink" title="缓存区"></a>缓存区</h3><p>缓冲区包括三个概念: <code>帧缓冲区</code>(Frame Buffers)   <code>渲染缓冲区</code>(Render Buffers)  <code>缓冲区对象</code>(Buffer Objects)</p><ul><li><p>帧缓冲区 <code>是GL储存渲染结果的地方,为GPU指定存储渲染结果的区域</code>，它可以包含多个图像，也就是包含多个 <code>渲染缓冲区</code>, 它存储着 OpenGL ES 绘制每个像素点最终的所有信息：颜色，深度和模板值。更通俗点，可以理解成存储屏幕上最终显示的一帧画面的区域.      </p></li><li><p>渲染缓冲区 也就是一个图像，也被称作颜色缓冲区.因为它本质上是存储要显示的颜色.例如颜色图像，深度图像，模版图像（决定每一个位置是可以的掩膜）等。多个纹理对象或多个渲染缓存对象，可通过连接点（attachment points）连接到帧缓存对象上。</p></li><li><p>缓冲区对象 就是程序员提供给OpenGL的数据，分为结构类和索引类。前者被称为 “数组缓冲区对象” 或者 “顶点缓冲对象”（“Array Buffer Object or Vertex Buffer Object”），即用来描述模型的数组，如顶点数组，纹理数组等；后者被称为 “索引缓冲区对象”（“Index Buffer Object”），是对上述数组的索引。</p></li></ul><blockquote><p>可以同时存在很多帧缓冲区，并且可以通过 OpenGL ES 让 GPU 把渲染结果存储到任意数量的帧缓冲中。但是，只有将内容绘制到视窗体提供的帧缓冲中，才能将内容输出到显示设备。视图系统提供的帧缓冲通常由两个缓存对象组成，一个前端缓存，一个后端缓存。</p></blockquote><blockquote><p>前帧缓存决定了屏幕上显示的像素颜色。程序的渲染结果通常保存在后帧缓存在内的其他帧缓存，当渲染后的后帧缓存包含一个完成的图像时，前后帧缓存会立即互换，前帧缓存变成新的后帧缓存，后帧缓存变成新的前帧缓存。</p></blockquote><blockquote><blockquote><p>但是前后帧我们无法去操纵，它是由系统控制的。我们只能显式的告诉系统，要展示哪个帧缓存了，然后由系统去完成前后帧的切换。</p></blockquote></blockquote><h3 id="Rasterizer-Rasterization-（光栅化）"><a href="#Rasterizer-Rasterization-（光栅化）" class="headerlink" title="Rasterizer/Rasterization （光栅化）"></a>Rasterizer/Rasterization （光栅化）</h3><p><img src="https://ws3.sinaimg.cn/large/006tNbRwgy1fw0v3o0cl2j30ch05pdfu.jpg" alt="光栅化"></p><p>光栅化的过程就是根据缓冲区对象里提供的数据 经过渲染 从3D模型得到2D模型的过程。得到的2D图像会根据帧缓冲区的配置来决定是直接送到屏幕显示 或是 做别的用处。    </p><blockquote><p>简单点，就是把矢量图形转化成像素点儿的过程。我们屏幕上显示的画面都是由像素组成，而三维物体都是点线面构成的。要让点线面，变成能在屏幕上显示的像素，就需要Rasterize这个过程。就是从矢量的点线面的描述，变成像素的描述。如上图   </p></blockquote><p><code>在光栅化阶段，基本图元被转换为供片段着色器使用的片段（Fragment</code>），Fragment 表示可以被渲染到屏幕上的像素，它包含位置，颜色，纹理坐标等信息，这些值是由图元的顶点信息进行插值计算得到的。这些片元接着被送到片元着色器中处理。 <code>这是从顶点数据到可渲染在显示设备上的像素的质变过程</code>。</p><p>在片段着色器运行之前会执行裁切（Clipping）。裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p><h2 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h2><p>从2.0版本开始，OpenGL支持可变的流水线，也就是说，程序员 可以通过 Shader（一种程序，一段包含着色信息的源代码字符串）来控制GPU渲染的过程。</p><p>Shader 也叫着色器，用来描述如何绘制（渲染）， GLSL 是 OpenGL 的 编程语言，全称全称就叫 OpenGL Shader Language。</p><p> Shader 分为 <code>Vertex Shader</code> 和 <code>Fragment Shader</code>。这两种Shader是成对出现的，GPU先执行前者，后执行后者。</p><h3 id="Vertex-Shader（顶点着色器）"><a href="#Vertex-Shader（顶点着色器）" class="headerlink" title="Vertex Shader（顶点着色器）"></a>Vertex Shader（顶点着色器）</h3><p>Vertex Shader 对于3D模型网格的每一个顶点执行一次，主要是确定改顶点的最终位置。Vertex Shader 还会准备并输出一些变量，传给 Fragment Shader 使用。 简单点就是 控制顶点的绘制，指定坐标、变换等。</p><h3 id="Fragment-Shader（片元着色器）"><a href="#Fragment-Shader（片元着色器）" class="headerlink" title="Fragment Shader（片元着色器）"></a>Fragment Shader（片元着色器）</h3><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fw0v2srjiaj30j10e9wfp.jpg" alt=""></p><p>Fragment Shader(也叫片段着色器) 对于最终得到的2D图像的每一个像素处理一次。3D物体的表面最终显示成什么样将有它决定。例如为模型的可见表面添加纹理，处理光照 阴影的影响等等，都在这里做。 Fragment Shader 的输出是一个 RGBA 格式的像素颜色值。 简单点就是 控制形状内区域渲染，纹理填充内容。 <code>片元着色器的主要作用是计算每一个片元最终的颜色值（或者丢弃该片段）。</code></p><blockquote><p>在片段着色器之前的阶段，渲染管线都只是在和顶点，图元打交道。在 3D 图形程序开发中，贴图是最重要的部分，程序可以通过 GL 命令上传纹理数据至 GL 内存中，这些纹理可以被片段着色器使用。片段着色器可以根据顶点着色器输出的顶点纹理坐标对纹理进行采样，以计算该片段的颜色值。</p></blockquote><blockquote><p>另外，片段着色器也是执行光照等高级特效的地方，比如可以传给片段着色器一个光源位置和光源颜色，可以根据一定的公式计算出一个新的颜色值，这样就可以实现光照特效。</p></blockquote><h3 id="着色器的使用流程"><a href="#着色器的使用流程" class="headerlink" title="着色器的使用流程"></a>着色器的使用流程</h3><p>着色器源代码和OpenGL源代码不是一起编译的，所以要特别强调我刚才说的“着色器是一段包含着色信息的源代码字符串”。所以，OpenGL源代码肯定是和工程一起编译的，但是着色器源代码是在运行期编译的。你可能会问，着色器的源代码是一个字符串怎么编译呢？所以OpenGL ES提供了一套运行期动态编译的流程：</p><p>（1）创建着色器：glCreateShader</p><p>（2）指定着色器源代码字符串：glShaderSource</p><p>（3）编译着色器：glCompileShader</p><p>（4）创建着色器可执行程序：glCompileShader</p><p>（5）向可执行程序中添加着色器：glAttachShader</p><p>（6）链接可执行程序：glLinkProgram</p><h2 id="纹理"><a href="#纹理" class="headerlink" title="纹理"></a>纹理</h2><blockquote><p>纹理是一个用来保存图像的色值的 OpenGL ES 缓存。</p></blockquote><p>现实生活中，纹理最通常的作用是装饰我们的物体模型，它就像是贴纸一样贴在物体表面，使得物体表面拥有图案。</p><p>但实际上在 OpenGL 中，纹理的作用不仅限于此，它可以用来存储大量的数据。一个典型的例子就是利用纹理存储画笔笔刷的 mask 信息。</p><h2 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h2><p>弄清楚坐标系很重要，它可以把几何图像和代数方程关联起来，也是是我们图像绘制的 布局的开始。    </p><p>OpenGL 渲染管线整个流程中，涉及了多个坐标系变化，看起来非常繁琐。但是针对 2D 图像处理，我们其实不需要关心这些变化，我们只需要了解 <code>标准化设备坐标</code> 即可。</p><h3 id="iOS-手机坐标系"><a href="#iOS-手机坐标系" class="headerlink" title="iOS 手机坐标系"></a>iOS 手机坐标系</h3><p>二维坐标系，原点在左上角，x 轴向右，y 轴向下，x y 取值范围为屏幕分辨率：</p><p><img src="http://farm6.staticflickr.com/5192/7420067916_889152557b.jpg" alt="手机坐标"></p><h3 id="OpenGL-坐标系"><a href="#OpenGL-坐标系" class="headerlink" title="OpenGL 坐标系"></a>OpenGL 坐标系</h3><p>三维坐标系，原点在中间，x 轴向右，y 轴向上，z 轴朝向我们，x y z 取值范围都是 [-1, 1]：</p><p><img src="https://ws1.sinaimg.cn/large/006tNbRwgy1fw0ue5kq8lj306e05p0so.jpg" alt="OpenGL坐标"></p><h3 id="纹理（texture）-坐标"><a href="#纹理（texture）-坐标" class="headerlink" title="纹理（texture） 坐标"></a>纹理（texture） 坐标</h3><p>为了能够把纹理映射到三角形，我们需要指定三角形的每一个顶点各自对应纹理的哪个部分。这样每一个顶点就会关联着一个纹理坐标，用来标明该从纹理图像的那一个人部分采样（采集片段颜色）。之后再图形的其他片段上进行片段插值。    </p><p>纹理坐标是二维坐标系，使用纹理坐标获取纹理颜色叫做采样，其原点在左下角，s（x）轴向右，t（y）轴向上，x y 取值范围都是 [0, 1]。<br>下面的图片展示了我们是如何把纹理坐标映射到三角形上：</p><p><img src="https://ws4.sinaimg.cn/large/006tNbRwgy1fw0ug0humaj30920723yu.jpg" alt="纹理坐标"></p><h2 id="OpenGL-有关概念"><a href="#OpenGL-有关概念" class="headerlink" title="OpenGL 有关概念"></a>OpenGL 有关概念</h2><p>OpenGL 提供一组API，各显卡制造商和系统制造商来实现这组API。       </p><p>EGL 是另一组API，主要是系统制造商实现，它负责OpenGL和原生窗口系统之间的接口，用于把OpenGL 渲染的结果显示在屏幕上。      </p><p>EGAL 是Apple公司对EGL做了修改，自己实现的一套屏幕显示接口，一般只用于iOS和 OS X 系统中。</p><p>关系如下图所示</p><p><img src="https://ws2.sinaimg.cn/large/006tNbRwgy1fv0xlv41zej30sg0lcwjc.jpg" alt="关系图"></p><p>参考文章：      </p><p><a href="https://www.2cto.com/kf/201706/647894.html" target="_blank" rel="noopener">https://www.2cto.com/kf/201706/647894.html</a>   </p><p><a href="https://blog.csdn.net/wangyuchun_799/article/details/7736928" target="_blank" rel="noopener">https://blog.csdn.net/wangyuchun_799/article/details/7736928</a>  </p><p><a href="https://www.jianshu.com/p/ce287a5460cd" target="_blank" rel="noopener">https://www.jianshu.com/p/ce287a5460cd</a></p><p><a href="https://www.zhihu.com/question/29163054" target="_blank" rel="noopener">如何理解 OpenGL 中着色器、渲染管线、光栅化等概念？</a></p>]]></content>
    
    <summary type="html">
    
      &lt;!--
&lt;div align=center&gt;![1](http://d-pic-image.yesky.com/1080x-/uploadImages/2017/014/00/FP43CP909564.jpg)&lt;div&gt;
--&gt;
&lt;p&gt;最近，斗破苍穹电视剧上映的，里面的梗就不用多提， &lt;code&gt;三十年河东，三十年河西，莫欺少年穷&lt;/code&gt; 指不定口碑低开高走呢。&lt;br&gt;人生也是一样, 无法预料,学历代表你的过去，能力代表你的现在，学习代表你的将来.&lt;br&gt;所以学无止境，需精益求精，不断的学习，才能蹒跚前行。    &lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="https://476139183.github.io/categories/iOS/"/>
    
    
      <category term="进阶" scheme="https://476139183.github.io/tags/%E8%BF%9B%E9%98%B6/"/>
    
      <category term="OpenGL" scheme="https://476139183.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>《AV Foundation 开发秘籍》之 数据的采集和编码</title>
    <link href="https://476139183.github.io/2018/09/04/%E3%80%8AAV-Foundation-%E5%BC%80%E5%8F%91%E7%A7%98%E7%B1%8D%E3%80%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://476139183.github.io/2018/09/04/《AV-Foundation-开发秘籍》（一）/</id>
    <published>2018-09-04T08:23:20.000Z</published>
    <updated>2018-09-28T01:59:25.716Z</updated>
    
    <content type="html"><![CDATA[<h2 id="AVFoundation简介"><a href="#AVFoundation简介" class="headerlink" title="AVFoundation简介"></a>AVFoundation简介</h2><p>AVFoundation是苹果在iOS和OS X系统中用于处理基于时间的媒体数据的Objective-C框架. 供使用者来开发媒体类型的应用程序。</p><p><img src="/2018/09/04/《AV-Foundation-开发秘籍》（一）/avfoundation.png" alt=""></p><a id="more"></a><p>如果只是进行简单的视频录制，使用UIKit中的<code>UIImagePickerController</code>就可以了。如果需要播放视频，使用AVKit框架也足够了。但是如果需要进行视频文件的处理等更灵活等操作，就需要使用到AVFoundation等底层的框架了。</p><ul><li><p><code>Core Audio</code> : 处理所有音频事件.是由多个框架整合在一起的总称,为音频和MIDI内容的录制,播放和处理提供相应接口.尤其是 <code>Audio Units</code> 接口，提供针对音频信号进行完全控制的功能,也可以通过它来构建一些复杂的音频处理.</p></li><li><p><code>Core Video</code> : 针对数字视频所提供的管道模式。Core Video为其相对的Core Media提供图片缓存和缓存池支持，提供了一个能够对数字视频逐帧访问的接口。</p></li><li><p><code>Core Media</code> : 是AVFoundation所用到低层级媒体管道的一部分.提供音频样本和视频帧处理所需的低层级数据类型和接口.</p></li><li><p><code>Core Animation</code> : 合成及动画相关框架, 封装了支持OpenGL和OpenGL ES功能的Obj-C的各种类. AVFoundation可以利用CoreAnimation让开发者能够在视频的编辑和播放过程中添加动画和图片效果.</p></li></ul><h2 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h2><h3 id="采集过程"><a href="#采集过程" class="headerlink" title="采集过程"></a>采集过程</h3><p>为了管理从相机或者麦克风等这样的设备捕获到的信息，我们需要输入对象(input)和输出对象(output)，并且使用一个会话(AVCaptureSession)来管理 input 和 output 之前的数据流：</p><p><img src="/2018/09/04/《AV-Foundation-开发秘籍》（一）/capture.png" alt=""></p><p>通过单个 session，也可以管理多个 input 和 output 对象之间的数据流，从而得到视频、静态图像和预览视图。input 可以有一个或多个输入端口，output 也可以有一个或多个数据来源(比如视频+音频)。</p><p>当添加 input 和 output 到 session 中时，session 会自动建立起一个连接(AVCaptureConnection)。我们可以使用这个 connection 来设置从 input 或者 从 output 得到的数据的有效性，也可以用来监控在音频信道中功率的平均值和峰值。</p><p><img src="/2018/09/04/《AV-Foundation-开发秘籍》（一）/connection.png" alt=""></p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>仅录制音频      </p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> audioSettings = [<span class="type">AVFormatIDKey</span>: kAudioFormatLinearPCM, <span class="comment">// 格式      </span></span><br><span class="line">                     <span class="type">AVSampleRateKey</span>: <span class="number">44100</span>, <span class="comment">// 采样率      </span></span><br><span class="line">                     <span class="type">AVNumberOfChannelsKey</span>: <span class="number">1</span>, <span class="comment">// 声道数      </span></span><br><span class="line">                     <span class="type">AVLinearPCMBitDepthKey</span>: <span class="number">16</span>] <span class="comment">// 位深度      </span></span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(fileURLWithPath: <span class="string">"\(NSHomeDirectory())/tmp/audio.pcm"</span>)       </span><br><span class="line"><span class="keyword">do</span> &#123;      </span><br><span class="line">    <span class="keyword">let</span> recorder = <span class="keyword">try</span> <span class="type">AVAudioRecorder</span>(url: url, settings: audioSettings)       </span><br><span class="line">    recorder.record()       </span><br><span class="line">&#125; <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;       </span><br><span class="line">    <span class="built_in">print</span>(error)       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>录制视频</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">let</span> session = <span class="type">AVCaptureSession</span>()</span><br><span class="line"><span class="keyword">if</span> session.canSetSessionPreset(.hd1280x720) &#123;</span><br><span class="line">    session.sessionPreset = .hd1280x720</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">self</span>.session = session</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加视频源</span></span><br><span class="line"><span class="keyword">let</span> videoDevice = <span class="type">AVCaptureDevice</span>.<span class="keyword">default</span>(<span class="keyword">for</span>: .video)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> device = videoDevice &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> input = <span class="keyword">try</span> <span class="type">AVCaptureDeviceInput</span>(device: device)</span><br><span class="line">        <span class="keyword">if</span> session.canAddInput(input) &#123;</span><br><span class="line">            session.addInput(input)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;</span><br><span class="line">        <span class="built_in">print</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加音频源</span></span><br><span class="line"><span class="keyword">let</span> audioDevice = <span class="type">AVCaptureDevice</span>.<span class="keyword">default</span>(<span class="keyword">for</span>: .audio)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> device = audioDevice &#123;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> input = <span class="keyword">try</span> <span class="type">AVCaptureDeviceInput</span>(device: device)</span><br><span class="line">        <span class="keyword">if</span> session.canAddInput(input) &#123;</span><br><span class="line">            session.addInput(input)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> <span class="keyword">let</span> error &#123;</span><br><span class="line">        <span class="built_in">print</span>(error)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 输出每一帧</span></span><br><span class="line"><span class="keyword">let</span> dataOutput = <span class="type">AVCaptureVideoDataOutput</span>()</span><br><span class="line">dataOutput.videoSettings = [kCVPixelBufferPixelFormatTypeKey: kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange] <span class="keyword">as</span> [<span class="type">String</span> : <span class="type">Any</span>]</span><br><span class="line">dataOutput.setSampleBufferDelegate(<span class="keyword">self</span>, queue: <span class="type">DispatchQueue</span>.main)</span><br><span class="line"><span class="keyword">if</span> session.canAddOutput(dataOutput) &#123;</span><br><span class="line">    session.addOutput(dataOutput)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 输出为文件</span></span><br><span class="line"><span class="keyword">let</span> fileOutput = <span class="type">AVCaptureMovieFileOutput</span>()</span><br><span class="line"><span class="keyword">if</span> session.canAddOutput(fileOutput) &#123;</span><br><span class="line">    session.addOutput(fileOutput)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> connection = fileOutput.connection(with: .video)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> conn = connection, conn.isVideoStabilizationSupported &#123;</span><br><span class="line">    conn.preferredVideoStabilizationMode = .auto</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> url = <span class="type">URL</span>(fileURLWithPath: <span class="string">"\(NSHomeDirectory())/tmp/movie.mov"</span>)</span><br><span class="line"><span class="comment">// 开始录制</span></span><br><span class="line">fileOutput.startRecording(to: url, recordingDelegate: <span class="keyword">self</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> previewLayer = <span class="type">AVCaptureVideoPreviewLayer</span>(session: session)</span><br><span class="line">previewLayer.frame = view.bounds</span><br><span class="line">view.layer.addSublayer(previewLayer)</span><br><span class="line"></span><br><span class="line">session.startRunning()</span><br></pre></td></tr></table></figure><p><code>AVCaptureMovieFileOutput</code>和<code>AVCaptureVideoDataOutput</code>的区别在于，前者是把采集到到数据直接写入到文件，而后者通过下面到代理方法将每一帧到图像数据发送过来，以便于进行一些处理。</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">captureOutput</span><span class="params">(<span class="number">_</span> output: AVCaptureOutput, didOutput sampleBuffer: CMSampleBuffer, from connection: AVCaptureConnection)</span></span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(sampleBuffer)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="音频采集相关概念"><a href="#音频采集相关概念" class="headerlink" title="音频采集相关概念"></a>音频采集相关概念</h3><p>音频的采集过程主要是通过设备将环境中的模拟信号转换成<code>PCM</code>编码的原始数据，然后编码压缩成<code>MP3</code>、<code>AAC</code>、<code>WMA</code>、<code>m4a</code>、<code>APE</code>、<code>FLAC</code>等格式。</p><h4 id="PCM"><a href="#PCM" class="headerlink" title="PCM"></a>PCM</h4><blockquote><p>PCM全称Pulse Code Modulation，中文名为脉冲编码调制。脉冲编码调制就是对模拟信号先抽样，再对样值幅度量化，编码的过程。</p></blockquote><p>衡量一个音频文件的质量的一个重要指标是比特率(码率)，单位为bps(bit per second)，也就是单位时间内传输的比特数。</p><p>而影响比特率的因素有：</p><ol><li>采样率(Sample Rate)：采样的频率，采样的频率越高，数据量就越大，音质就越高。</li></ol><p><img src="/2018/09/04/《AV-Foundation-开发秘籍》（一）/pcm.jpg" alt=""></p><ol start="2"><li><p><a href="https://zhidao.baidu.com/question/1575028964185733420.html" target="_blank" rel="noopener">位深度(Bit Depth)</a>：表示每一个采样点所需要的数值的大小。可以是4bit、8bit、16bit等，位数越多，采样点表示的精度就越高，音质就越高，数据量也会成倍的增加。</p></li><li><p>声道数(Number of Channels)：由于音频的采集和播放是可以叠加的，因此，可以同时从多个音频源采集声音，并分别输出到不同的扬声器，故声道数一般表示声音录制时的音源数量或回放时相应的扬声器数量。声道数为 1 和 2 分别称为单声道和双声道。</p></li></ol><p>根据采样率 量化 声道 我们就可以计算出一个采样率为44100Hz，位深度为16bit，时长为3分钟的单声道CD歌曲的数据量为：<br><code>44100Hz x 16bit x 5 x 60s x 2 = 423360000bit = 52.9MB</code><br>比特率为：<code>423360000bit / (5 x 60s) = 1441kbps</code><br>这样的数据大小显然是不能接受的，所以才有了上面提到的<code>MP3</code>、<code>AAC</code>、<code>WMA</code>、<code>m4a</code>、<code>APE</code>、<code>FLAC</code>这些压缩格式的出现。</p><p>音频的压缩分为无损压缩和有损压缩，简单的来说，有损压缩就是通过删除一些已有数据中不太重要的数据来达到压缩目的；无损压缩就是通过优化排列方式来达到压缩目的。</p><p><code>MP3</code>、<code>AAC</code>、<code>WMA</code>、<code>m4a</code>都属于有损压缩，假设把上面的歌曲压缩为码率128kpbs的普通音质的MP3，压缩比为<code>1441kpbs / 128kbps = 11</code>，因此压缩后的文件大小为<code>52.9MB / 11 = 5MB</code>。</p><p><code>APE</code>、<code>FLAC</code>属于无损压缩，文件相对较大。</p><h3 id="图像采集相关概念"><a href="#图像采集相关概念" class="headerlink" title="图像采集相关概念"></a>图像采集相关概念</h3><p>图像采集的图片结果组合成一组连续播放的动画，即构成视频中可肉眼观看的内容。图像的采集过程主要由摄像头等设备拍摄成 YUV 编码的原始数据，然后经过编码压缩成 H.264 等格式的数据分发出去。常见的视频封装格式有：MP4、3GP、AVI、MKV、WMV、MPG、VOB、FLV、SWF、MOV、RMVB 和 WebM 等。</p><p>图像数据质量的同样可以通过码率来进行衡量，而影响码率的因素主要有：</p><ol><li>图像的分辨率(Resolution)：视频采集过程中的原始分辨率决定了视频整体的清晰度，分辨率越高，视频越清晰。常见的分辨率有<code>480p</code>、<code>720</code>、<code>1080p</code>、<code>4k</code>。</li><li>图像的格式：视频图像一般采用YUV格式存储原始的数据信息，而不是采用常见的RGB格式。</li><li>帧率(Frame Rate)：单位时间内捕获到到图像到数量，帧率越高，画面的流畅度就越高。一般的视频的帧率为30fps。延时摄影就是以远低于普通帧率的频率进行图像的采集然后以正常的帧率进行播放，就会有一种加速的效果。而高速摄影（慢动作）就是以远高于普通帧率的频率进行图像的采集，然后以正常的帧率进行播放，就会有一种变慢的效果。</li><li>传输通道数：一般情况下都只有一个摄像头进行数据的采样，而随着VR和AR技术的发展，要拍摄一个360度的视频，就需要多个摄像头来同时进行采集了。</li></ol><h4 id="图像的位深度"><a href="#图像的位深度" class="headerlink" title="图像的位深度"></a>图像的位深度</h4><p>我们知道对于一个普通的不包含Alpha通道的位图图像而言，每一个像素点的数据都可以通过R、G、B三个分量数据来进行表示。每个数据用用多大的数值来表示就决定了这个图像的位深度，也即图像的色彩范围。色彩越丰富，‘位’越多。假设我们用1个字节来表示一个分量的数值，即24位真彩色，那么总共就有<code>2^8 x 2^8 x 2^8 = 1600万</code>种颜色，而如果对RGB分别用3bit、3bit、2bit也即8位色来表示的话 只有<code>2^3 x 2^3 x 2^2 = 256</code>种颜色。</p><p><img src="/2018/09/04/《AV-Foundation-开发秘籍》（一）/24bit.png" alt=""></p><p>24位色的图片</p><p><img src="/2018/09/04/《AV-Foundation-开发秘籍》（一）/8bit.png" alt=""></p><p>8位色的图片</p><h4 id="YUV格式"><a href="#YUV格式" class="headerlink" title="YUV格式"></a>YUV格式</h4><p>与我们所熟知的RGB类似，YUV也是一种颜色的编码方法，主要用于视频领域。它将亮度信息(Y)与色彩信息(UV也称CbCr)分离，没有UV信息一样可以显示完整的图像，只不过是黑白的。这样的设计很好地解决了彩色电视机与黑白电视的兼容问题。并且，YUV不像RGB那样要求三个独立的视频信号同时传输，所以用YUV方式传送占用极少的频宽。我们人眼对于亮度的感知比对色彩的感知更为强烈，所以可以通过减少色彩信息(UV)的采样来减少数据量。这就是二次采样</p><p><img src="/2018/09/04/《AV-Foundation-开发秘籍》（一）/chroma.png" alt=""></p><p>色彩信息(UV)</p><p><img src="/2018/09/04/《AV-Foundation-开发秘籍》（一）/luma.png" alt=""></p><p>亮度和色度的对比</p><p>YUV码流的存储格式其实与其采样的方式密切相关，主流的采样方式有三种，YUV4:4:4、YUV4:2:2、YUV4:2:0，如下图所示：</p><p><img src="/2018/09/04/《AV-Foundation-开发秘籍》（一）/yuv.png" alt=""></p><p>对于YUV 4:4:4采样，每一个Y分量对应一组UV分量<br>对于YUV 4:2:2采样，每两个Y分量公用一组UV分量<br>对于YUV 4:2:0采样，每四个Y分量公用一组UV分量       </p><p>YUV格式有两大类：planar和packed。<br>对于planar的YUV格式，先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V。<br>对于packed的YUV格式，每个像素点的Y,U,V是连续交叉存储的。</p><p>一般移动平台视频录制使用的是YUV 4:2:0，而根据各个分量的排列顺序不同又分为<code>YV12</code>、<code>I420(YU12)</code>、<code>NV12</code>、<code>NV21</code>。</p><p><code>YV12</code>和<code>I420</code>也称为YUV420P，即planar平面格式。YV12和I420的区别仅在与UV顺序的不同。顾名思义，YV12中Y平面后面紧跟的是V平面，然后是U平面，12表示它的位深度为12，也就是一个像素占12bit。而I420(YU12)顺序刚好与之相反。</p><p><code>NV12</code>和<code>NV21</code>都属于YUV420SP，即Y分量平面格式，UV分量打包格式。也即先存储Y平面，后面是UV分量交错存储。iOS平台使用的是<code>NV21</code>格式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">I420: YYYYYYYY UU VV  =&gt; YUV420P</span><br><span class="line">YV12: YYYYYYYY VV UU  =&gt; YUV420P</span><br><span class="line">NV12: YYYYYYYY UVUV   =&gt; YUV420SP</span><br><span class="line">NV21: YYYYYYYY VUVU   =&gt; YUV420SP</span><br></pre></td></tr></table></figure><p>I420(Planar)的单帧结构示意图如下：(I420 ： 亮度（行×列） +U（行×列/4) + V（行×列/4）)</p><p><img src="/2018/09/04/《AV-Foundation-开发秘籍》（一）/i420p.png" alt=""></p><p>NV12(Planar)的单帧结构示意图如下:</p><p><img src="/2018/09/04/《AV-Foundation-开发秘籍》（一）/nv12.png" alt=""></p><p>根据上图所示：</p><p>一张分辨率为6 x 4的图片采用YUV420的方式存储所占的空间为<code>6 x 4 + 6 + 6 = 36</code>个字节，而如果采用RGB的方式存储就需要占用<code>6 x 4 x 3 = 72</code>个字节，数据量减少了一半。(本文中像素的采样位数一律为8bit。由于1Byte=8bit，所以一个像素的一个分量的采样值占用1Byte)</p><p>如果以YUV420的方式编码一部720p、帧率为30fps、时长两小时的高清电影所需要的空间为</p><p><code>12bit x 1280 x 720 x 30 x 120 x 60 = 2.38 x 10^12bit = 298.6GB</code></p><p>这个大小显然是不能接受的，经过编码我们可以把它压缩到2G左右，而画面到清晰度不会有多少损失。</p><h3 id="视频编码"><a href="#视频编码" class="headerlink" title="视频编码"></a>视频编码</h3><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>为什么视频文件的压缩比可以达到100:1甚至更高？核心的思想就是去除冗余信息。</p><p>视频文件中的冗余信息分为以下几类：</p><ol><li>空间冗余：每一帧图像相邻像素之间有较强的关联性</li><li>时间冗余：视频相邻帧之间的内容相似</li><li>编码冗余：不同像素值出现的概率不同</li><li>视觉冗余：人眼对于某些细节不敏感</li><li>知识冗余：规规律性的结构可由先验知识和背景知识得到</li></ol><p>对于视频文件最简单的压缩方式就是对每一帧图像进行压缩，叫做帧内压缩。有一种比较古老的 MJPEG 编码就是这种编码方式。可以理解为把视频的每一帧当作一张图片，然后按照JPEG的方式来进行压缩。这样的压缩方式只处理了空间冗余信息，离理想的压缩比还差得远。</p><p>视频的图像的相邻帧之间具有很大的相似性，因此去除时间冗余信息对于提高压缩比有很大的提升空间。比如说一些高级的编码器可以采用帧间编码，简单点说就是通过搜索算法选定了帧上的某些区域，然后通过计算当前帧和前后参考帧的向量差进行编码的一种形式，通过下面两个图 2 连续帧我们可以看到，滑雪的同学是向前位移的，但实际上是雪景在向后位移。后面的帧就可以参考前面的帧进行编码，这样后面的帧编码的结果就非常小，压缩比很高。</p><p><img src="/2018/09/04/《AV-Foundation-开发秘籍》（一）/time-redundancy.jpg" alt=""></p><p>去除其他的冗余信息这里就不多说了。</p><h4 id="常用编码器"><a href="#常用编码器" class="headerlink" title="常用编码器"></a>常用编码器</h4><h5 id="H-264"><a href="#H-264" class="headerlink" title="H.264"></a>H.264</h5><blockquote><p>H.264/AVC 是现在使用最广泛的编码标准。与旧标准相比，它能够在更低带宽下提供优质视频（换言之，只有 MPEG-2，H.263 或 MPEG-4 第 2 部分的一半带宽或更少），也不增加太多设计复杂度使得无法实现或实现成本过高。另一目的是提供足够的灵活性以在各种应用、网络及系统中使用，包括高、低带宽，高、低视频分辨率，广播，DVD 存储，RTP/IP 网络，以及 ITU-T 多媒体电话系统。</p></blockquote><h5 id="H-265"><a href="#H-265" class="headerlink" title="H.265"></a>H.265</h5><p>2017年6月6日凌晨召开WWDC 2017大会上苹果在iOS11上推出了HEVC，用来取代H.264</p><blockquote><p>高效率视频编码（High Efficiency Video Coding，简称HEVC）是一种视频压缩标准，被视为是 ITU-T H.264/MPEG-4 AVC 标准的继任者。2004 年开始由 ISO/IEC Moving Picture Experts Group（MPEG）和 ITU-T Video Coding Experts Group（VCEG）作为 ISO/IEC 23008-2 MPEG-H Part 2 或称作 ITU-T H.265 开始制定。第一版的 HEVC/H.265 视频压缩标准在 2013 年 4 月 13 日被接受为国际电信联盟（ITU-T）的正式标准。HEVC 被认为不仅提升视频质量，同时也能达到 H.264/MPEG-4 AVC 两倍之压缩率（等同于同样画面质量下比特率减少了 50%），可支持 4K 分辨率甚至到超高清电视（UHDTV），最高分辨率可达到 8192×4320（8K分辨率）。</p></blockquote><h4 id="硬件编解码和软件编解码"><a href="#硬件编解码和软件编解码" class="headerlink" title="硬件编解码和软件编解码"></a>硬件编解码和软件编解码</h4><p>iOS8开始，苹果通过<code>Video ToolBox</code>开放了系统的硬件编解码能力。在这之前，开发者基本上都是使用的是一个叫做<a href="https://www.ffmpeg.org/" target="_blank" rel="noopener">FFmpeg</a>的多媒体库，利用CPU做视频的编解码，俗称软解码。</p><blockquote><p>FFmpeg 是一个自由软件，可以运行音频和视频多种格式的录影、转换、流功能，包含了 libavcodec ——这是一个用于多个项目中音频和视频的解码器库，以及 libavformat —— 一个音频与视频格式转换库。</p></blockquote><h4 id="视频容器-格式"><a href="#视频容器-格式" class="headerlink" title="视频容器(格式)"></a>视频容器(格式)</h4><p>所谓容器，就是把编码器生成的多媒体内容（视频，音频，字幕，章节信息等）混合封装在一起的标准。容器使得不同多媒体内容同步播放变得很简单，而容器的另一个作用就是为多媒体内容提供索引，也就是说如果没有容器存在的话一部影片你只能从一开始看到最后，不能拖动进度条（当然这种情况下有的播放器会花比较长的时间临时创建索引），而且如果你不自己去手动另外载入音频就没有声音。</p><p><img src="/2018/09/04/《AV-Foundation-开发秘籍》（一）/mov-atom.gif" alt=""></p><p>MOV文件的结构</p><p>常见的视频容器格式有：</p><ul><li><p>AVI 格式（后缀为 .AVI）: 它的英文全称为 Audio Video Interleaved ，即音频视频交错格式。它于 1992 年被 Microsoft 公司推出。<br>这种视频格式的优点是图像质量好。由于无损AVI可以保存 alpha 通道，经常被我们使用。缺点太多，体积过于庞大，而且更加糟糕的是压缩标准不统一，最普遍的现象就是高版本 Windows 媒体播放器播放不了采用早期编码编辑的AVI格式视频，而低版本 Windows 媒体播放器又播放不了采用最新编码编辑的AVI格式视频，所以我们在进行一些AVI格式的视频播放时常会出现由于视频编码问题而造成的视频不能播放或即使能够播放，但存在不能调节播放进度和播放时只有声音没有图像等一些莫名其妙的问题。</p></li><li><p>QuickTime File Format 格式（后缀为 .MOV）: 美国Apple公司开发的一种视频格式，默认的播放器是苹果的QuickTime。<br>具有较高的压缩比率和较完美的视频清晰度等特点，并可以保存alpha通道。</p></li><li><p>MPEG 格式（文件后缀可以是 .MPG .MPEG .MPE .DAT .VOB .ASF .3GP .MP4等) : 它的英文全称为 Moving Picture Experts Group，即运动图像专家组格式，该专家组建于1988年，专门负责为 CD 建立视频和音频标准，而成员都是为视频、音频及系统领域的技术专家。<br>MPEG 文件格式是运动图像压缩算法的国际标准。MPEG 格式目前有三个压缩标准，分别是 MPEG－1、MPEG－2、和MPEG－4 。MPEG－1、MPEG－2 目前已经使用较少，着重介绍 MPEG－4，其制定于1998年，MPEG－4 是为了播放流式媒体的高质量视频而专门设计的，以求使用最少的数据获得最佳的图像质量。目前 MPEG-4 最有吸引力的地方在于它能够保存接近于DVD画质的小体积视频文件。</p></li><li><p>Real Video 格式（后缀为 .RM .RMVB）: Real Networks 公司所制定的音频视频压缩规范称为Real Media。<br>用户可以使用 RealPlayer 根据不同的网络传输速率制定出不同的压缩比率，从而实现在低速率的网络上进行影像数据实时传送和播放。RMVB 格式：这是一种由RM视频格式升级延伸出的新视频格式，当然性能上有很大的提升。RMVB 视频也是有着较明显的优势，一部大小为700MB左右的 DVD 影片，如果将其转录成同样品质的 RMVB 格式，其个头最多也就 400MB 左右。大家可能注意到了，以前在网络上下载电影和视频的时候，经常接触到 RMVB 格式，但是随着时代的发展这种格式被越来越多的更优秀的格式替代，著名的人人影视字幕组在2013年已经宣布不再压制 RMVB 格式视频。</p></li><li><p>Matroska 格式（后缀位 .MKV）:是一种新的多媒体封装格式，这个封装格式可把多种不同编码的视频及16条或以上不同格式的音频和语言不同的字幕封装到一个Matroska Media档内。它也是其中一种开放源代码的多媒体封装格式。Matroska同时还可以提供非常好的交互功能，而且比MPEG更方便、强大。</p></li></ul><h4 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h4><p>   在完整的数字音频生产流程流程中，最终的成品品质是由信号采样量化,信号编码，信号传输，信号同步，信号处理，信号存储等多个环节共同决定的，<br>   很大程度依赖与软硬件的性能指标，而工作者对与采样量化相关概念的明确，是音频质量的一道重要的保障，总的来说 工作中选择采样率与量化位深的原则有几点</p><p>   1.在高精度和系统性能之间选取平衡点<br>   2.一般不低于 24bit/44.1kHz规格<br>   3.尽可能减少流程中采样率转换的次数<br>   4.在降低量化位深时，进行有效的技术补偿          </p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;AVFoundation简介&quot;&gt;&lt;a href=&quot;#AVFoundation简介&quot; class=&quot;headerlink&quot; title=&quot;AVFoundation简介&quot;&gt;&lt;/a&gt;AVFoundation简介&lt;/h2&gt;&lt;p&gt;AVFoundation是苹果在iOS和OS X系统中用于处理基于时间的媒体数据的Objective-C框架. 供使用者来开发媒体类型的应用程序。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2018/09/04/《AV-Foundation-开发秘籍》（一）/avfoundation.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS 组件化+热切换+热更新+MVVM 架构思想漫谈</title>
    <link href="https://476139183.github.io/2018/09/03/iOS-%E6%9E%B6%E6%9E%84%E6%80%9D%E6%83%B3%E6%BC%AB%E8%B0%88/"/>
    <id>https://476139183.github.io/2018/09/03/iOS-架构思想漫谈/</id>
    <published>2018-09-03T08:45:46.000Z</published>
    <updated>2018-09-18T06:59:29.406Z</updated>
    
    <content type="html"><![CDATA[<p>移动互联网发展10余年来，移动应用也谁之发生了翻天覆地的变化。从最初的几M小应用到现在动则几十上百M；从最初的一个人几个小功能，到现在的几十上百号人，比PC网页还要齐全还要强大的功能。在此过程中，原有的单Project，MVC架构，一个月一发版，已经远远不能满足当前移动应用的开发。于是乎，一个新的名词便诞生了–移动架构师。<br><a id="more"></a><br>   总有开发者朋友问我，得具备什么样的水平，多长的工作经验，做过多大的项目才能成为一个架构师啊。的确，这个问题很难回答。架构，在很大程度上并不具有具体的角色定位，架构师亦然。能够独立做出一个APP，可以称为这个APP的架构师。能够把控一个超级APP的所有技术解决方案，可以称为这个超级APP的架构师。</p><p>   总有开发者朋友问我，什么样的架构才是好架构。在很长一段时间，C/S架构独领风骚，随后B/S架构横空出世，一时风头无两，但是随着移动互联网的出现和发展，C/S架构又成为移动应用的主流，再次焕发初生命地光彩，重拾其荣耀，但与此同时B/S却也依然坚挺。这就是架构，只有适合，没有好坏。</p><p>   同样，我们今天所谈论的这套宏伟的iOS架构，是绝对不适合只有几个页面的小APP的。至于如何抉择，3人以上的开发团队可以组建化，百万级别日活可以热切换，百万级别用户量可以热更新，需求频繁、功能分布零散，高耦合可以用MVVM。</p><p>   数据持久化方案，网络方案，MODEL方案，这些也是架构，怎么今天不谈呢？因为这是技术，而我们今天所谈论的是思想。</p><p>   APP组件化，我总结了两种方案。总线+分线、分线+分线。第一种，总线+分线方案，对应IOS APP，即多个子模块加一个主模块，主模块负责所有子模块间的组合和通信，必不可少；第二钟，分线+分线，即任意两个子模块都可以组合构成一个独立的APP。对于这两种方案，第一种便于理解和实现，第二种灵活性更高，优势虐势都很明显，至于取舍，选则自己擅长的便是。</p><p>   APP组件化的具体实现，我推荐使用 <code>CocoaPods私有Pod</code> 来实现各个组件，理由有下，技术成熟、资料众多，使用者众。具体实现方式亦有两种。<br>   第一种，将各个组件做为LocalPod，方便调适，维护。<br>   第二种，像第三方Pod一样作为外部组件引入，优势是便于把控。同时，这两种方式也可以结合使用，与业务毫无关联的基础组件，可以作为第三方Pod引入，由团队专人维护，而将业务模块作为LocalPod引入，可以方便调适、维护。<br>   至于具体实现，请参看文章末尾的Git项目。</p><p>   APP热切换，即在用户使用APP的过程中，出现某一个或者多个功能无法使用时，直接将该功能切换为React-Native的实现，或者H5的实现。前提是你有React-Native或者H5的备份可供下发，并且APP提供了所有正常功能的访问权限和方法。实现难度不高，但是成本巨大，除非著名大厂高日活APP，否则没有太大的实现必要。唯一一点实现难度，主要体现在各端数据格式的统一。打个比方，如果你的一个页面出现了Bug，并且该页面为了用户体验是使用原生编写，而该页面的必要初始化参数通过上一页面带入，此时你临时将页面切换成RN或者H5的实现，则你所传递的参数必定要被其数据结构所认可。所以，如果要实现APP的热切换，最好是各个功能、页面都只使用一个identity字段作为初始化的请求参数。至于具体实现，请参看文章末尾的Git项目。</p><p>   APP热更新，即无需发版，可做紧急Bug修复，和功能更新，在去年早些时候还有JSPatch等直接替换OC方法的方案来修复Bug，但是很不幸，现在已经被苹果所禁用。目前主流的方案是使用RN构筑View和实现业务逻辑，然后做有限的功能更新、和Bug修复，即通过RN对你APP所有原生功能做重新的排列组合，而修复一些不是由你的原生基础库所导致的Bug。目前主要有两种实现方案，一种是原生提供所有的基础功能和库，由RN实现页面和业务逻辑，需要从零开始开发；另一种是把RN作为一个组件，植入到现有原生APP中，并为RN提供主要原生页面和功能的访问支持，部分业务场景使用RN编写，这样实现有点类似于原生+H5，优点是性能高于H5，缺点是成本比H5更大。</p><p>   MVVM架构，即Model-View-ViewModel的分层架构方案，但凡对架构稍有了解的都不会觉得陌生。但在iOS项目的具体实现中ViewController绝对是必不可少的，所以我们在iOS项目中也不妨将它理解为Model-View-ViewModel-ViewController。Model、View这两层一个是实体模型，一个是显示和操作实体模型，在实际情况中Model中的数据和View中的数据往往存在差异，比如Model中有一个100，在View中却要显示为100元，在View中有一个选项菜单，选择的是具体菜单名，在Model中却要保存为菜单名+菜单ID，在Model中有一个详细信息的数组，在View中却要根据该信息的长度来控制列表上不同Cell的高度。在MVC架构中这些操作往往通过Controller来完成，但随着业务的增加Controller却又会变得无比的庞大，并且功能模块难以复用。如果将这些操作交给View让其自己去实现的话又会影响到View的可复用性。所以，为了解决这样的问题，ViewModel便应运而生了，ViewModel主要负责将业务和View关联起来，其本质是对数据流的操作，其关注点亦是数据流。即数据发生改变，ViewModel刷新视图，数据不同VIewModel提供不同的显示方案，用户操作视图，VIewModel更新数据；同一个视图，不同的ViewModel绑定不同的数据便做到了视图的复用；不同的ViewController使用同一个ViewModel便做到了功能的复用和解耦；你也可以将ViewModel理解为对业务的封装；所以ViewModel应当具有如下功能，数据的取得、数据的处理、视图的更新、数据的更新。即，ViewModel应当同时持有View和Model，或者ViewModel应当同时绑定View和Model。第三方开源模块Rective Cocoa，提供非常简便的绑定能力，个人推荐使用。至于具体实现，请参看文章末尾的Git项目。</p><p>  所谓架构，本质上是为了实现业务而对技术和人员的最有效排列组合。架构思想，则是从哲学的角度对经验的总结和归纳。如果你把代码看成有血有肉有思想的生命，那么，架构思想，即创造代码的哲学。你的代码，即你的思想。</p><p> <a href="https://blog.csdn.net/bsn1928/article/details/79436556" target="_blank" rel="noopener">来源</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;移动互联网发展10余年来，移动应用也谁之发生了翻天覆地的变化。从最初的几M小应用到现在动则几十上百M；从最初的一个人几个小功能，到现在的几十上百号人，比PC网页还要齐全还要强大的功能。在此过程中，原有的单Project，MVC架构，一个月一发版，已经远远不能满足当前移动应用的开发。于是乎，一个新的名词便诞生了–移动架构师。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>object-c编码规范</title>
    <link href="https://476139183.github.io/2018/09/03/object-c%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>https://476139183.github.io/2018/09/03/object-c编码规范/</id>
    <published>2018-09-03T03:02:54.000Z</published>
    <updated>2018-09-04T09:16:32.051Z</updated>
    
    <content type="html"><![CDATA[<h1 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h1><p>参考资料<a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-objc-styleguide/" target="_blank" rel="noopener">Google Objective-C Style Guide</a>   </p><p>   老大是一位重度代码洁癖的处女座，对代码规范非常苛刻，以前经常改动我的代码就为了他能看的顺眼。我记得曾在我提交的茫茫代码行中愣是指出某处的空格少了一个(囧)。<br>    其实我们花时间在某一方面，必然在某一方面有所收获，在代码上花时间，那么必然对技术有所提升，对泡妞上花时间，必然在泡妞上有更多的心得。。。  写博客也是因为老大的建议，即便写的不深，很是粗糙，但是经常写博客，花时间总结，可以记录自己的整个学习过程，也有助于自我思考，自我表达。&lt; 屁话太多了吧(路过人员的心声) &gt;      </p><pre><code>前沿：其实 每一门开发语言都有自己的代码规范，我们应该遵循它的代码规范去使用它，这就是这篇文章的来源。    </code></pre><a id="more"></a> <h2 id="背景知识"><a href="#背景知识" class="headerlink" title="背景知识"></a>背景知识</h2><p> Objective-C是一个C语言的扩展语言，非常动态，非常的“面向对象”，它被设计成既拥有复杂的面向对象设计理念又可以轻松使用与阅读的语言，也是Mac OS X和iPhone开发的首选语言。</p><p>   Cocoa是Mac OS X的主要应用框架，提供迅速开发各种功能的Mac OS X应用的Objective-C类集合。</p><p>  Apple已经有一个很好也被广泛接受的Objective-C的编码规范，Google也有类似的C++编码规范，这份Objective-C编码规范很自然是Apple和Google的共同推荐的组合。所以，在阅读本规范前，确保你已经阅读了:</p><ul><li><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/FrameworkImpl.html" target="_blank" rel="noopener">Apple’s Cocoa Coding Guidelines</a>     </li><li><p><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/contents/" target="_blank" rel="noopener">Google’s Open Source C++ Style Guide</a> </p><blockquote><p>注意所有已在Google的C++编码规范里的禁用条款在Objective-C里也适用，除非本文档明确指出反对意见。 </p></blockquote></li></ul><p>本文档旨在描述可供可适用于所有Mac OS X代码的Objective-C(包括Objective-C++)编码规范和实践。规范中的许多条款已经改进也不断的被其他的项目和团队所证明其指导性。Google的相关开源项目都遵守此规范。</p><p>  Google已经发布了一份作为<a href="https://code.google.com/p/google-toolbox-for-mac/" target="_blank" rel="noopener">Google Toolbox for Mac project</a> (文档中简称为<code>GTM</code>)的组成部分的遵守本规范的开源代码。这份开放代码也是本文很好的例证(原文看不太懂－－Code meant to be shared across different projects is a good candidate to be included in this repository. )</p><p>  注意本文不是Objective-C的教学指南，我们假设读者已经了解语言。如果你是一个Objective-C的初学者或需要重温，请阅读<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjectiveC/Introduction/introObjectiveC.html" target="_blank" rel="noopener">The Objective-C Programming Language</a> .</p><p>示例 </p><p> 人们说一个例子胜过千言万语，所以就让我们用例子来让你感受以下编码规范的风格，留间距，命名等等。</p><p> 下例是一份头文件，展示对@interface 声明正确的注释和留间距    </p><p>iOS代码 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  GTMFoo.h  </span></span><br><span class="line"><span class="comment">//  FooProject  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">//  Created by Greg Miller on 6/13/08.  </span></span><br><span class="line"><span class="comment">//  Copyright 2008 Google, Inc. All rights reserved.  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">``` objc</span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// A sample class demonstrating good Objective-C style. All interfaces,  </span></span><br><span class="line"><span class="comment">// categories, and protocols (read: all top-level declarations in a header)  </span></span><br><span class="line"><span class="comment">// MUST be commented. Comments must also be adjacent to the object they're  </span></span><br><span class="line"><span class="comment">// documenting.  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">// (no blank line between this comment and the interface)  </span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GTMFoo</span> : <span class="title">NSObject</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">@private</span>  </span><br><span class="line">  <span class="built_in">NSString</span> *foo_;  </span><br><span class="line">  <span class="built_in">NSString</span> *bar_;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Returns an autoreleased instance of GMFoo. See -initWithString: for details  </span></span><br><span class="line"><span class="comment">// about the argument.  </span></span><br><span class="line">+ (<span class="keyword">id</span>)fooWithString:(<span class="built_in">NSString</span> *)string;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Designated initializer. |string| will be copied and assigned to |foo_|.  </span></span><br><span class="line">- (<span class="keyword">id</span>)initWithString:(<span class="built_in">NSString</span> *)string;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Gets and sets the string for |foo_|.  </span></span><br><span class="line">- (<span class="built_in">NSString</span> *)foo;  </span><br><span class="line">- (<span class="keyword">void</span>)setFoo:(<span class="built_in">NSString</span> *)newFoo;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Does some work on |blah| and returns YES if the work was completed  </span></span><br><span class="line"><span class="comment">// successfuly, and NO otherwise.  </span></span><br><span class="line">- (<span class="built_in">BOOL</span>)doWorkWithString:(<span class="built_in">NSString</span> *)blah;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p> <strong>注意：有朋友喜欢在全局变量命名时以_开头，其实我不建议，比如 NSString *_foo; 因为在阅读时很容易让人误会是property属性，我们应该尽量让阅读者可以方便的理解代码，而不是出现诱导因素。</strong></p><p>  下例是一份源文件，展示对接口的@implementation 的实现的正确注释和留间隔。它也包括了主要方法如getters,setters,init ,和dealloc 的相关实现。  </p><p>iOS代码    </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">//  GTMFoo.m  </span></span><br><span class="line"><span class="comment">//  FooProject  </span></span><br><span class="line"><span class="comment">//  </span></span><br><span class="line"><span class="comment">//  Created by Greg Miller on 6/13/08.  </span></span><br><span class="line"><span class="comment">//  Copyright 2008 Google, Inc. All rights reserved.  </span></span><br><span class="line"><span class="comment">//</span></span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">"GTMFoo.h"</span>  </span></span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">GTMFoo</span>  </span></span><br><span class="line">  </span><br><span class="line">+ (<span class="keyword">id</span>)fooWithString:(<span class="built_in">NSString</span> *)string &#123;  </span><br><span class="line">  <span class="keyword">return</span> [[[<span class="keyword">self</span> alloc] initWithString:string] autorelease];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// Must always override super's designated initializer.  </span></span><br><span class="line">- (<span class="keyword">id</span>)init &#123;  </span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">self</span> initWithString:<span class="literal">nil</span>];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">- (<span class="keyword">id</span>)initWithString:(<span class="built_in">NSString</span> *)string &#123;  </span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;  </span><br><span class="line">    foo_ = [string <span class="keyword">copy</span>];  </span><br><span class="line">    bar_ = [[<span class="built_in">NSString</span> alloc] initWithFormat:<span class="string">@"hi %d"</span>, <span class="number">3</span>];  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;    </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;  </span><br><span class="line">  [foo_ release];  </span><br><span class="line">  [bar_ release];  </span><br><span class="line">  [<span class="keyword">super</span> dealloc];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">- (<span class="built_in">NSString</span> *)foo &#123;  </span><br><span class="line">  <span class="keyword">return</span> foo_;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">- (<span class="keyword">void</span>)setFoo:(<span class="built_in">NSString</span> *)newFoo &#123;  </span><br><span class="line">  [foo_ autorelease];  </span><br><span class="line">  foo_ = [newFoo <span class="keyword">copy</span>];    </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">- (<span class="built_in">BOOL</span>)doWorkWithString:(<span class="built_in">NSString</span> *)blah &#123;  </span><br><span class="line">  <span class="comment">// ...  </span></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NO</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="间隔与格式化"><a href="#间隔与格式化" class="headerlink" title="间隔与格式化"></a>间隔与格式化</h2><h3 id="空格对tab键"><a href="#空格对tab键" class="headerlink" title="空格对tab键"></a>空格对tab键</h3><p>  仅使用空格，缩进两个。</p><p>  我们使用空格用于缩进，不要在编码时使用tab键，你应该设置你的编辑器将tab键转换成对应的空格。</p><h3 id="行长度"><a href="#行长度" class="headerlink" title="行长度"></a>行长度</h3><p>  代码中的每行文本不要超过80个字符的长度。</p><p>  尽管Objective-C正变得比C++更加繁冗，为了保持规范的互通性，我们还是决定保持80字符长度的限制。这比你想象中的更容易做到。</p><p>  我们知道本条款是有争议的，但已有此多的代码已经遵从了本条款，即使只是保持一致性也是一个充足的理由。</p><p>  你可以在Xcode里清楚地发现代码中的违规，设置  Xcode &gt; Preferences &gt; Text Editing &gt; Show page guide. (之后就可以在代码编辑区域里看到一条指定字符长度的指示线了)</p><h2 id="方法声明与定义"><a href="#方法声明与定义" class="headerlink" title="方法声明与定义"></a>方法声明与定义</h2><p>  留一个空格在 - 或 + 和 返回类型 之间，但参数列表里的参数之间不要留间隔。<br> 方法应该写成这样:    </p><p>iOS代码 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doSomethingWithString:(<span class="built_in">NSString</span> *)theString &#123;  </span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>星号前的空格是可选的，你可以根据原来的代码风格自行决定。</p><p>如果参数过多，推荐每个参数各占一行。使用多行的情况下，以参数前的冒号用于对齐:<br>        (很遗憾这里仅有Google Chrome浏览器能看出是冒号对齐的……)     </p><p>iOS代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)doSomethingWith:(GTMFoo *)theFoo  </span><br><span class="line">                   rect:(<span class="built_in">NSRect</span>)theRect  </span><br><span class="line">               interval:(<span class="keyword">float</span>)theInterval &#123;  </span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当第一个关键字比其他的短时，后续行至少缩进四个空格。这样你可以让后续的关键字垂直对齐，而不是用冒号对齐:<br>iOS代码 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)short:(GTMFoo *)theFoo  </span><br><span class="line">    longKeyword:(NSRect)theRect  </span><br><span class="line">    evenLongerKeyword:(float)theInterval &#123;  </span><br><span class="line">  ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p> 方法调用的格式和方法声明时的格式时一致的，如果格式风格可选，遵从原有代码的风格。</p><p> 调用应该将所有参数写在一行:   </p><p>iOS代码 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[myObject doFooWith:arg1 name:arg2 error:arg3];</span><br></pre></td></tr></table></figure><p> 或者每个参数一行，用冒号对齐:(对齐效果如前说明)    </p><p>iOS代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[myObject doFooWith:arg1  </span><br><span class="line">               name:arg2  </span><br><span class="line">              error:arg3];</span><br></pre></td></tr></table></figure><p>注意:不要使用如下风格的写法</p><p>iOS代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[myObject doFooWith:arg1 name:arg2  <span class="comment">// some lines with &gt;1 arg  </span></span><br><span class="line">              error:arg3];  </span><br><span class="line">  </span><br><span class="line">[myObject doFooWith:arg1  </span><br><span class="line">               name:arg2 error:arg3];  </span><br><span class="line">  </span><br><span class="line">[myObject doFooWith:arg1  </span><br><span class="line">          name:arg2  <span class="comment">// aligning keywords instead of colons  </span></span><br><span class="line">          error:arg3];</span><br></pre></td></tr></table></figure><p>在声明和定义时，如果因为关键字长度使就算有四个空格在前仍然无法用冒号对齐，那么就让后续行缩进四个空格而不是冒号对齐:    </p><p>iOS代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[myObj short:arg1  </span><br><span class="line">    longKeyword:arg2  </span><br><span class="line">    evenLongerKeyword:arg3];</span><br></pre></td></tr></table></figure><h3 id="public-和-private"><a href="#public-和-private" class="headerlink" title="@public 和 @private"></a>@public 和 @private</h3><p>权限控制符@public 和@private 缩进一个空格.</p><p>类似C++的public,protected,private:</p><p>iOS代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">@public</span>  </span><br><span class="line">  ...  </span><br><span class="line"> <span class="keyword">@private</span>  </span><br><span class="line">  ...  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>每个异常标签的@ 和开括号({ )写在统一行，标签和开括号间隔一个空格，同样适用于@catch 语句。</p><p>如果你决定使用Objective-C的异常，那么就按如下格式，不过你最好先看看Avoid Throwing Exceptions(见后)条款，了解为何你不应使用异常。    </p><p>iOS代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@try &#123;  </span><br><span class="line">  foo();  </span><br><span class="line">&#125;  </span><br><span class="line">@catch (NSException *ex) &#123;  </span><br><span class="line">  bar(ex);  </span><br><span class="line">&#125;  </span><br><span class="line">@finally &#123;  </span><br><span class="line">  baz();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>命名规则对于维护代码来说是非常重要的。Objective-C方法名往往很长，不过这也有好处，读代码就像读散文(放屁),让很多注释变得毫无意义。</p><p>写纯Objective-C代码时，我们基本上遵守标准Objective-C naming rules ，这些规则和C++的规则有很大的不同。比如Google的C++代码规范推荐变量名构词之间使用下划线隔开，而本文档推荐驼峰法，也是Objective-C社区的标准。</p><p>所有类，类别, 方法，以及变量如包括缩写，则缩写部分使用全大写的缩写(Initialisms )形式。这遵守Apple的标准，比如URL,TIFF以及EXIF。</p><p>  当写Objective-C++代码时，情况就不是那么单一了。许多项目需要实现带一些Objective-C代码的跨平台的C++APIs或者连接后台的C++代码与前台的原生Cocoa代码.这会造成两种规范直接冲突。</p><p>  我们的解决方法是根据方法/函数风格来决定。如果在@implementation 块，就使用Objective-C的命名规则；如果在C++的方法实现块，就使用C++的命名规则。避免了实体变量和本地变量在一个函数内命名规则冲突的情况，而这种情况是对可读性的极大损害。</p><h3 id="文件命名"><a href="#文件命名" class="headerlink" title="文件命名"></a>文件命名</h3><p>  文件名反映了它所包含的实现类的名字，遵从你所在项目的习惯。</p><p>  文件扩展名使用如下规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.h     C/C++/Objective-C header file</span><br><span class="line"> </span><br><span class="line">.m     Objective-C implementation file</span><br><span class="line"> </span><br><span class="line">.mm    Objective-C++ implementation file</span><br><span class="line"> </span><br><span class="line">.cc    Pure C++ implementation file</span><br><span class="line"> </span><br><span class="line">.c     C implementation file</span><br></pre></td></tr></table></figure><p>类别的文件名应该包含扩展类的名字，比如 <code>GTMNSString+Utils.h</code> or <code>GTMNSTextView+Autocomplete.h</code> </p><h3 id="Objective-C"><a href="#Objective-C" class="headerlink" title="Objective-C++"></a>Objective-C++</h3><p>在一份源文件里，Objective-C++代码遵守当前方法/函数的风格</p><p>为了尽量减少不同命名风格间的冲突，使用当前方法的风格。如果在@implementation块，使用Objective-C命名规则，如果在C++类的函数实现块，使用C++命名规则。    </p><p>iOS代码 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: cross_platform_header.h  </span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">class</span> CrossPlatformAPI &#123;  </span><br><span class="line"> public:  </span><br><span class="line">  ...  </span><br><span class="line">  <span class="keyword">int</span> DoSomethingPlatformSpecific();  <span class="comment">// impl on each platform  </span></span><br><span class="line"> private:  </span><br><span class="line">  <span class="keyword">int</span> an_instance_var_;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file: mac_implementation.mm  </span></span><br><span class="line"><span class="meta">#include <span class="meta-string">"cross_platform_header.h"</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// A typical Objective-C class, using Objective-C naming.  </span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyDelegate</span> : <span class="title">NSObject</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">@private</span>  </span><br><span class="line">  <span class="keyword">int</span> instanceVar_;  </span><br><span class="line">  CrossPlatformAPI* backEndObject_;  </span><br><span class="line">&#125;  </span><br><span class="line">- (<span class="keyword">void</span>)respondToSomething:(<span class="keyword">id</span>)something;  </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyDelegate</span>  </span></span><br><span class="line">- (<span class="keyword">void</span>)respondToSomething:(<span class="keyword">id</span>)something &#123;  </span><br><span class="line">  <span class="comment">// bridge from Cocoa through our C++ backend  </span></span><br><span class="line">  instanceVar_ = backEndObject-&gt;DoSomethingPlatformSpecific();  </span><br><span class="line">  <span class="built_in">NSString</span>* tempString = [<span class="built_in">NSString</span> stringWithInt:instanceVar_];  </span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, tempString);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// The platform-specific implementation of the C++ class, using  </span></span><br><span class="line"><span class="comment">// C++ naming.  </span></span><br><span class="line"><span class="keyword">int</span> CrossPlatformAPI::DoSomethingPlatformSpecific() &#123;  </span><br><span class="line">  <span class="built_in">NSString</span>* temp_string = [<span class="built_in">NSString</span> stringWithInt:an_instance_var_];  </span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, temp_string);  </span><br><span class="line">  <span class="keyword">return</span> [temp_string intValue];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类命名"><a href="#类命名" class="headerlink" title="类命名"></a>类命名</h3><p>   类名(不包括类别和协议名)应该用大写开头的驼峰命名法。</p><p>   在应用级别的代码里，尽量不要使用带前缀的类名。每个类都有相同的前缀不能提高可读性。不过如果是编写多个应用间的共享代码，前缀就是可接受并推荐的做法了(型如 GTMSendMessage )。（注：笔者建议加入前缀，因为这并不是单单为了提高可读性，也为了与引入进来的类做区分，所以合适的前缀是有必要的）</p><h3 id="类别命名"><a href="#类别命名" class="headerlink" title="类别命名"></a>类别命名</h3><p>   类别命名应该以两三个字符的分类前缀作为一个项目或通用的公用部分。类别名应该包含类的扩展。</p><p>   举个例子，如果我们想要创建一个基于NSString 的类别用于解析，我们应该把类别放到名字是GTMNSString+Parsing.h 的文件里，而类别本身的名字则是GTMStringParsingAdditions (是的，我们明白这个类别和其文件名字不匹配，但这个文件可能还包括其他用于解析相关的类别)。类别的方法应该都使用一个前缀(型如gtm_myCategoryMethodOnAString ),以防止Objective-C代码在单名空间里冲突。如果代码本来就不考虑共享或在不同的地址空间(address-space)，方法命名规则就没必要恪守了。</p><h3 id="Objective-C-方法命名"><a href="#Objective-C-方法命名" class="headerlink" title="Objective-C 方法命名"></a>Objective-C 方法命名</h3><p>   方法使用小写开头的驼峰法命名，每个参数都应该小写开头。</p><p>   方法名应该尽可能读起来像一句话，参数名就相对方法名的补充说明(比如convertPoing:fromRect: 或者 replaceCharactersInRange:withString: )，详见Apple’s Guide to Naming Methods </p><p>   存取(Accessor)方法应该一致的在”取(getting)”的时候直接用变量名而不是在签名加”get”,如下:    </p><p>iOS代码 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (id)getDelegate;  // AVOID  </span><br><span class="line">  </span><br><span class="line">- (id)delegate;    // GOOD</span><br></pre></td></tr></table></figure><p>   不过这仅针对Objective-C代码，C++代码仍然遵循自己的代码规范。</p><h3 id="变量命名"><a href="#变量命名" class="headerlink" title="变量命名"></a>变量命名</h3><p>   变量名使用小写开头的驼峰法，类成员变量名最后加一个下划线，比如:myLovalVariable, myInstanceVariable_ . 下面看不懂，原文Members used for KVO/KVC bindings may begin with a leading underscore iff use of Objective-C 2.0’s @property isn’t allowed. </p><h4 id="一般变量命名"><a href="#一般变量命名" class="headerlink" title="一般变量命名"></a>一般变量命名</h4><p>   不要使用匈牙利命名法去标记语法，比如静态类型或变量类型(int或pointer之类的)。使变量名尽量可以推测其用途属性具有描述性。别一心想着少打几个字母，让你的代码可以迅速被理解更加重要。比如:</p><p>iOS代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// AVOID  </span><br><span class="line">int w;  </span><br><span class="line">int nerr;  </span><br><span class="line">int nCompConns;  </span><br><span class="line">tix = [[NSMutableArray alloc] init];  </span><br><span class="line">obj = [someObject object];  </span><br><span class="line">p = [network port];  </span><br><span class="line">  </span><br><span class="line">// GOOD  </span><br><span class="line">int numErrors;  </span><br><span class="line">int numCompletedConnections;  </span><br><span class="line">tickets = [[NSMutableArray alloc] init];  </span><br><span class="line">userInfo = [someObject object];  </span><br><span class="line">port = [network port];</span><br></pre></td></tr></table></figure><h4 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h4><p>   实例变量用驼峰法命名并后缀下划线，就像 <code>usernameTextField_</code> . 然而我们允许一种例外就是用KVO/KVC去绑定一个实体变量而Objective-C 2.0 不能用(因为操作系统的限制)的情况，此时也可用前缀下划线的方法给每个变量命名。如果可以使用Objective-C 2.0，<code>@property</code> 和 <code>@synthesize</code> 提供了遵守命名规范的解决方法。</p><h4 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h4><p>   常量(预定义，枚举，局部常量等)使用小写k开头的驼峰法，比如 <code>kInvalidHandle</code> , <code>kWritePerm</code> . </p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>尽管写起来很痛苦，但注释仍然是使代码保持可读性的极端重要的方式。下面的条款描述了你应该注释什么以及在哪里做注释。但是记住:即使注释是如此重要，最好的代码还是自说明式的。起一个有意义的名字比起一个晦涩的名字然后在用注释去解释它好的多。</p><p>   当你写注释的时候，记住注释是写给读者，即下一个要理解你的代码并继续开发的人。”下一个”完全可能就是你自己。</p><p>   同样，所有C++编码规范的条款仍然适用，只是增加了一些条款，如下.</p><h3 id="文件注释"><a href="#文件注释" class="headerlink" title="文件注释"></a>文件注释</h3><p>   每个文件的开头都是版权声明，接着是文件内容的描述。</p><p>   法律声明和作者栏 </p><p>   每个文件都应该包含如下信息:</p><p>   一份版权声明(比如 Copyright 2008 Google Inc .)<br>   许可版本 为项目选择合适的许可版本(比如Apache 2.0, BSD, LGPL, GPL)</p><p>   如果你把别人写的文件做了相当大的改动，就把自己添加到作者栏去。这样别的开发者就方便联系这个文件的实际开发人员了。</p><h3 id="声明部分注释"><a href="#声明部分注释" class="headerlink" title="声明部分注释"></a>声明部分注释</h3><p>   每个接口，类别，协议都必须伴随描述它的用途以及如何整合的注释。</p><p>iOS代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A delegate for NSApplication to handle notifications about app  </span></span><br><span class="line"><span class="comment">// launch and shutdown. Owned by the main app controller.  </span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyAppDelegate</span> : <span class="title">NSObject</span> </span>&#123;  </span><br><span class="line">  ...  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>   如果已经在文件的顶部写了接口的详细描述，你也可以简单的写如”见文件顶部的完整描述”，当然要有这些注释的顺序安排。</p><p>   此外public接口的每个方法都应该添加关于函数，参数，返回值以及副作用的注释。       </p><p>   文档默认类都是同步的，如果类实例可以多线程访问，必须要加上额外的说明。     </p><h3 id="实现部分注释"><a href="#实现部分注释" class="headerlink" title="实现部分注释"></a>实现部分注释</h3><p>  使用竖线引用变量或符号，而不是用引号。    </p><p>   这可以减少歧义，特别是当符号本身就是个常见的词时，可能使句子显得支离破碎，比如符号是”count”:    </p><p>iOS代码     </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// Sometimes we need |count| to be less than zero.</span><br></pre></td></tr></table></figure><p>   或者是对于那些已经存在引号的情况     </p><p>iOS代码    </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Remember to call |StringWithoutSpaces("foo bar baz")|</span></span><br></pre></td></tr></table></figure><h3 id="对象所有权"><a href="#对象所有权" class="headerlink" title="对象所有权"></a>对象所有权</h3><p>   使指针所有权的模型尽可能清晰，当它属于Objective-C的使用惯例时(不懂，原文是Make the pointer ownership model as explicit as possible when it falls outside the most common Objective-C usage idioms. )</p><p>   实例变量指向NSObject派生类的对象时都假定是retain的，如果它们不是retain的则需要加上”weak”的文档说明。对应的，实体变量如果标记上IBOutlets则是假定为非retain的，若实际上用了retain，就必须加上”strong”的说明。</p><p>   当实例变量指向核心库，C++或其他非Objective-C对象时，必须永远用注释说明是strong还是weak的。必须注意为了支持Objective-C对象里的自动化C++对象的封装是默认被关闭的的(这句话有歧义，原文是Be mindful that support for automatic C++ objects encapsulated in Objective-C objects is disabled by default)，这里 有说明。</p><p>  strong和weak说明的文档示例:</p><p>  iOS代码 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyDelegate</span> : <span class="title">NSObject</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">@private</span>  </span><br><span class="line">  <span class="keyword">IBOutlet</span> <span class="built_in">NSButton</span>* okButton_;  <span class="comment">// normal NSControl  </span></span><br><span class="line">  <span class="keyword">IBOutlet</span> <span class="built_in">NSMenu</span>* myContextMenu_;  <span class="comment">// manually-loaded menu (strong)  </span></span><br><span class="line">  </span><br><span class="line">  AnObjcObject* doohickey_;  <span class="comment">// my doohickey  </span></span><br><span class="line">  MyController* controller_;  <span class="comment">// so we can send msgs back (weak, owns me)  </span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// non-NSObject pointers...  </span></span><br><span class="line">  CWackyCPPClass* wacky_;  <span class="comment">// some cross-platform object (strong)  </span></span><br><span class="line">  <span class="built_in">CFDictionaryRef</span>* dict_;  <span class="comment">// (strong)  </span></span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strong</span><br><span class="line">对象会在类中retain </span><br><span class="line">weak</span><br><span class="line">对象不会在类中retain   (比如一个委托)</span><br></pre></td></tr></table></figure><h2 id="Cocoa和Objective-C特性"><a href="#Cocoa和Objective-C特性" class="headerlink" title="Cocoa和Objective-C特性"></a>Cocoa和Objective-C特性</h2><h3 id="成员变量应该定义为-private"><a href="#成员变量应该定义为-private" class="headerlink" title="成员变量应该定义为@private"></a>成员变量应该定义为@private</h3><p>iOS代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface MyClass : NSObject &#123;  </span><br><span class="line"> @private  </span><br><span class="line">  id myInstanceVariable_;  </span><br><span class="line">&#125;  </span><br><span class="line">// public accessors, setter takes ownership  </span><br><span class="line">- (id)myInstanceVariable;  </span><br><span class="line">- (void)setMyInstanceVariable:(id)theVar;  </span><br><span class="line">@end</span><br></pre></td></tr></table></figure><h3 id="明确指定初始化函数"><a href="#明确指定初始化函数" class="headerlink" title="明确指定初始化函数"></a>明确指定初始化函数</h3><ul><li><p>注释并说明指定的初始化。</p><p>明确指定初始化对想要子类化你的类的时候时很重要的。那样，子类化时只需要做一个或多个初始化去保证初值即可。这也有助于在以后调试你的类时明了初始化流程。</p></li></ul><h3 id="重写指定初始化函数"><a href="#重写指定初始化函数" class="headerlink" title="重写指定初始化函数"></a>重写指定初始化函数</h3><p>   当重写一个子类并需要init… 方法，注意要重写父类的指定初始化方法。</p><p>   如果你没有正确重写父类的指定初始化方法，你的初始化方法可能不会被调用，这会导致很多微妙而难以排除的错误。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>   没必要在初始化方法里把变量初始化为0 或者nil ,这是多余的。</p><p>   所有新分配内存的对象内容都初始化为0(除了 isa )，所以不要在init 方法里做无谓的重初始化为0的操作。</p><h3 id="保持公有API简明"><a href="#保持公有API简明" class="headerlink" title="保持公有API简明"></a>保持公有API简明</h3><p>   保持你的类简单，避免”厨房水槽”似的APIs，如果一个方法没必要公开就不要公开。使用私有类别保证公开头文件的简洁。</p><p>   和C++不同，Objective-C无法区分公有私有方法，因为它全是公有的。因此，除非就是为了让用户调用所设计，不要把其他的方法放到公有API里。这样可以减少不期调用的可能性。这还包括重写父类的方法。对于那些内部实现的方法，在实现文件里使用类别而不是将方法定义在公有头文件里。</p><p>iOS代码    </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// GTMFoo.m  </span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"GTMFoo.h"</span>  </span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">GTMFoo</span> (<span class="title">PrivateDelegateHandling</span>)  </span></span><br><span class="line">- (<span class="built_in">NSString</span> *)doSomethingWithDelegate;  <span class="comment">// Declare private method  </span></span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">GTMFoo</span>(<span class="title">PrivateDelegateHandling</span>)  </span></span><br><span class="line">...  </span><br><span class="line">- (<span class="built_in">NSString</span> *)doSomethingWithDelegate &#123;  </span><br><span class="line">  <span class="comment">// Implement this method  </span></span><br><span class="line">&#125;  </span><br><span class="line">...  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>   在Objective-C 2.0之前，如果你在私有@interface 里声明了一个方法，但忘记在主@implementation 文件里实现了，编译器不会有什么反应(这是因为你没有在不同的类别里实现这些私有方法)。解决方案在是把函数写到@implementation 里并指明类别。</p><p>   如果你用的是 Objective-C 2.0，你应该使用类扩展 而不是声明私有类别，如下:</p><p>iOS代码    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@interface GMFoo () &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>   如此就可以保证函数做了声明但没有在@implememtation 里实现的时候编译器会警报。</p><p>   再者，”private”方法并不是真正的private，你可能会无意间重写了父类的一个”private”方法，这回导致bug的涌现。总的来说，私有方法应该使用更特别的名字以阻止子类化时并不期望的重写。</p><p>   最后，对于绝大多数类而言，Objective-C的类别是将@implelemtation做可理解的分块，添加新的应用级别的功能的最佳途径。比如，与其在你的项目里随便找个类来实现字符串的”中间截断”功能，不如创建一个新的NSString 类别。</p><h2 id="import-和-include"><a href="#import-和-include" class="headerlink" title="#import 和 #include"></a>#import 和 #include</h2><p>   用 #import 导入Objective-C 或 Objective-C++头 文件，用 #include 导入C或C++头 文件</p><h3 id="根据头文件的语言去选择合适的导入方式。"><a href="#根据头文件的语言去选择合适的导入方式。" class="headerlink" title="根据头文件的语言去选择合适的导入方式。"></a>根据头文件的语言去选择合适的导入方式。</h3><p>   当导入的头文件使用Objective-C或Objective-C++语言时，使用#import .<br>   当导入标准C或 C++头文件时，使用#include . 头文件应该使用自己的#define 重加载保护</p><p>   有些Objective-C头文件没有#define 重加载保护，所以只应该用#import 导入。因此Objective-C头文件只应该被Objective-C源文件或其他的Objective-C头文件所导入。这种情况下全部使用#import 是合适的。</p><p>   标准C和C++头文件不包含任何Objective-C元素都可以被一般的C或C++文件导入。因为标准C和C++里根本没有#import ，所以也只能用#include 导入。在Objective-C代码中使用#include 一致的导入这些头文件。</p><p>   本条款有助于跨平台项目的无意错误。一位Mac开发者引入一份新C或C++头文件时可能会忘记添加#define重加载保护，因为在Mac上用#import 导入文件不会引发问题，但在别的使用#include 的平台就可能出问题。在所有平台一致的使用#include 意味着要么全部成功要么全部失败，避免了那种另人沮丧的一些平台上可以运作而另一些不行的情况。</p><p> iOS代码 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Cocoa/Cocoa.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#include <span class="meta-string">&lt;CoreFoundation/CoreFoundation.h&gt;</span>  </span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"GTMFoo.h"</span>  </span></span><br><span class="line"><span class="meta">#include <span class="meta-string">"base/basictypes.h"</span></span></span><br></pre></td></tr></table></figure><h3 id="使用框架根"><a href="#使用框架根" class="headerlink" title="使用框架根"></a>使用框架根</h3><p>   导入框架根的头文件而不是分别导入框架头文件</p><p>   看起来从Cocoa或Foundation这些框架里导入个别的文件很不错，但实际上你直接导入框架根头文件效率更高。框架根已经被预编译故可更快的被加载。还有，记住用#import 指令而不是#include 导入Objective-C的框架。</p><p>iOS代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/Foundation.h&gt;</span>     // good  </span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/NSArray.h&gt;</span>        // avoid  </span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;Foundation/NSString.h&gt;</span>  </span></span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">### 构建时即设定autorelease ###</span></span><br><span class="line"></span><br><span class="line">   当创建新的临时对象时，在同一行代码里就设定autorelease而不是写到这个方法的后面几行去</span><br><span class="line"></span><br><span class="line">   即使这样可能会造成一些轻微的延迟，但这样避免了谁不小心把release 去掉，或在release 之前就<span class="keyword">return</span> 而造成的内存泄露，如下</span><br><span class="line">   </span><br><span class="line">iOS代码    </span><br><span class="line"></span><br><span class="line">``` objc </span><br><span class="line"><span class="comment">// AVOID (unless you have a compelling performance reason)  </span></span><br><span class="line">MyController* controller = [[MyController alloc] init];  </span><br><span class="line"><span class="comment">// ... code here that might return ...  </span></span><br><span class="line">[controller release];  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// BETTER  </span></span><br><span class="line">MyController* controller = [[[MyController alloc] init] autorelease];</span><br></pre></td></tr></table></figure><p>   优先autorelease而非retain </p><h3 id="对象赋值时尽量采用autorelease-而不是retian-模式。"><a href="#对象赋值时尽量采用autorelease-而不是retian-模式。" class="headerlink" title="对象赋值时尽量采用autorelease 而不是retian 模式。"></a>对象赋值时尽量采用autorelease 而不是retian 模式。</h3><p>   当把一个新创建的对象赋予一个变量的时候，第一件要做的事情就是先释放原来变量指向的对象以防止内存泄露。这里也有很多”正确的”方法去做这件事。我们选择autorelease时因为它更不倾向于出错。小心在密集的循环里可能会很快填满autorelease池，而且它也确实会降低效率，但权衡下来还是可以接受的。</p><p>iOS代码  </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setFoo:(GMFoo *)aFoo &#123;  </span><br><span class="line">  [foo_ autorelease];  <span class="comment">// Won't dealloc if |foo_| == |aFoo|  </span></span><br><span class="line">  foo_ = [aFoo <span class="keyword">retain</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   以声明时的顺序dealloc处理实例变量 </p><p>   dealloc 应该用在@interface 声明时同样的顺序处理实例变量，这也有助于评审者鉴别。</p><p>   代码评审者检查或修正dealloc 的实现要确保所有retain 的实例变量都获得了释放。</p><p>   为了简化评审dealloc ，将释放retain 的实例变量代码保持和@interface 里声明的顺序一致。如果dealloc 调用了其他方法去释放实例变量，添加注释说明那些实例变量被这些方法所处理了。</p><h3 id="Setters-copy-NSStrings"><a href="#Setters-copy-NSStrings" class="headerlink" title="Setters copy NSStrings"></a>Setters copy NSStrings</h3><p>   在NSString 上调用Setters 方法时，永远使用copy 方式。(不太懂，原文是Setters taking an NSString, should always copy  the string it accepts. )</p><p>   永远不要retain 一个字符串，这可以防止调用者在你不知到的情况下修改了字符串。不要以为你可以改变NSString 的值，只有NSMutableString 才能做到。</p><p>iOS代码 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setFoo:(<span class="built_in">NSString</span> *)aFoo &#123;  </span><br><span class="line">  [foo_ autorelease];  </span><br><span class="line">  foo_ = [aFoo <span class="keyword">copy</span>];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 避免抛出异常 </p><p>   不要 @throw Objective-C的异常，不过你还是要做好准备捕获第三方以及系统调用抛出的异常。</p><p>   我们的确在编译时加入了-fobjc-exceptions 指令(主要是为了获得@synchronized )，但我们并不@throw 。当然在使用第三方库的时候是允许使用@try，@catch, 以及@finally 的。如果你确实使用了，请务必明确到文档中哪个方向你想抛出什么异常。</p><p>   除非你写的代码想要泡在MacOS 10.2或更之前，否则不要使用NS_DURING, NS_HANDLER, NS_ENDHANDLER, NS_VALUERETURN and NS_VOIDRETURN 这些宏。</p><p>   另外你要小心当写Objective-C++代码的时候，如果抛出Objective-C异常，那些栈上的对象不会被清理。示例:</p><p>iOS代码 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> exceptiontest &#123;  </span><br><span class="line"> public:  </span><br><span class="line">  exceptiontest() &#123; <span class="built_in">NSLog</span>(<span class="string">@"Created"</span>); &#125;  </span><br><span class="line">  ~exceptiontest() &#123; <span class="built_in">NSLog</span>(<span class="string">@"Destroyed"</span>); &#125;  </span><br><span class="line">&#125;;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">void</span> foo() &#123;  </span><br><span class="line">  exceptiontest a;  </span><br><span class="line">  <span class="built_in">NSException</span> *exception = [<span class="built_in">NSException</span> exceptionWithName:<span class="string">@"foo"</span>  </span><br><span class="line">                                                   reason:<span class="string">@"bar"</span>  </span><br><span class="line">                                                 userInfo:<span class="literal">nil</span>];  </span><br><span class="line">  <span class="keyword">@throw</span> exception;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) &#123;  </span><br><span class="line">  GMAutoreleasePool pool;  </span><br><span class="line">  <span class="keyword">@try</span> &#123;  </span><br><span class="line">    foo();  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">@catch</span>(<span class="built_in">NSException</span> *ex) &#123;  </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"exception raised"</span>);  </span><br><span class="line">  &#125;  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   将会有如下输出:    </p><p>   iOS代码    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2006-09-28 12:34:29.244 exceptiontest[23661] Created         </span><br><span class="line">2006-09-28 12:34:29.244 exceptiontest[23661] exception raised</span><br></pre></td></tr></table></figure><p>   注意这里的析构函数永远没有机会被调用。这是在你想用栈上的智能指针比如shared_ptr,linked_ptr ,还有STL对象的时候不得不关注的一个核心问题。我们不得不痛心地说，如果你一定要在Objective-C++代码里抛出异常，那就请一定使用C++的异常。永远不要重新抛出一个Objective-C的异常，也不允许在异常块即@try,@catch,@finally 里生成栈上的 C++对象(比如std::string, std::vector 等).</p><h3 id="nil检查"><a href="#nil检查" class="headerlink" title="nil检查"></a>nil检查</h3><p>   仅在校验逻辑流程时做nil检查。</p><p>   使用nil检查不是为了防止程序崩溃，而是校验逻辑流程。向一个空对象发送一条消息是由Objective-C运行时处理的。方法没有返回结果，你也可以安心走下去.然而这里也有一种，依执行架构不同而返回尺寸和OS X的版本(这段不懂)(见)Apple’s documentation for specifics 。</p><p>   注意这里和C/C++的空指针检查是完全不同的，在那些环境里，并不处理空指针情况并可能导致你的应用程序崩溃。不过你仍要自己确保提领的指针不为空。</p><h3 id="BOOL类型陷阱"><a href="#BOOL类型陷阱" class="headerlink" title="BOOL类型陷阱"></a>BOOL类型陷阱</h3><p>  整形的转换为 BOOL 型的时候要小心。不要直接和YES做比较。</p><p>   BOOL 在Objective-C里被定义为unsigned char，这意味着它不仅仅只有YES (1)和NO (0)两个值。不要直接把整形强制转换为BOOL 型。常见的错误发生在把数组大小，指针的值或者逻辑位运算的结果赋值到BOOL型中，而这样就导致BOOL 值的仅取决于之前整形值的最后一个字节，有可能出现整形值不为0但被转为NO的情况。应此把整形转为BOOL型的时候请使用ternery操作符，保证返回YES 或NO 值。</p><p>   在BOOL，_BOOL 以及bool (见C++ Std 4.7.4, 4.12以及C99 Std 6.3.1.2)之间可以安全的交换值或转型。但BOOL 和Boolean 之间不可，所以对待Boolean 就像上面讲的整形一样就可以了。在Objective-C函数签名里仅使用BOOL 。</p><p>   对BOOL值使用逻辑运算(&amp;&amp;, ||, ! )都是有效的，返回值也可以安全的转为BOOL型而不需要ternery操作符。</p><p>iOS代码 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// AVOID  </span><br><span class="line">- (BOOL)isBold &#123;  </span><br><span class="line">  return [self fontTraits] &amp; NSFontBoldTrait;  </span><br><span class="line">&#125;  </span><br><span class="line">- (BOOL)isValid &#123;  </span><br><span class="line">  return [self stringValue];  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">// GOOD  </span><br><span class="line">- (BOOL)isBold &#123;  </span><br><span class="line">  return ([self fontTraits] &amp; NSFontBoldTrait) ? YES : NO;  </span><br><span class="line">&#125;  </span><br><span class="line">- (BOOL)isValid &#123;  </span><br><span class="line">  return [self stringValue] != nil;  </span><br><span class="line">&#125;  </span><br><span class="line">- (BOOL)isEnabled &#123;  </span><br><span class="line">  return [self isValid] &amp;&amp; [self isBold];  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>   还有，不要把 BOOL 型变量直接与 YES 比较。这样不仅对于精通C的人很有难度，而且此条款的第一点也说明了这样做未必能得到你想要的结果。</p><p>iOS代码 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// AVOID  </span><br><span class="line">BOOL great = [foo isGreat];  </span><br><span class="line">if (great == YES)  </span><br><span class="line">  // ...be great!  </span><br><span class="line">  </span><br><span class="line">// GOOD  </span><br><span class="line">BOOL great = [foo isGreat];  </span><br><span class="line">if (great)  </span><br><span class="line">  // ...be great!</span><br></pre></td></tr></table></figure><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>   属性总的来说是遵循如下告诫的: 属性是Objective-C 2.0的特性，所以只能跑在iPhone以及MacOS X 10.5(leopard)或更高的版本。点表示法访问属性是不被允许的。</p><h3 id="命名-1"><a href="#命名-1" class="headerlink" title="命名"></a>命名</h3><p>   一个有属性关联实例变量都要在后面加下划线，而该属性的名称就是实例变量不加尾部的下划线的名字。</p><p>   使用@synthesize 标识以正确的重命名属性。</p><p>iOS代码</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">@private</span>  </span><br><span class="line">  <span class="built_in">NSString</span> *name_;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;  </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span>  </span></span><br><span class="line"><span class="keyword">@synthesize</span> name = name_;  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><p>   在类接口声明里，属性的声明必须紧挨着实例变量块声明之后。类定义里，属性的定义必须紧挨着@implementation块。缩进和@interface或@implementation是一样的。    </p><p>iOS代码 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> </span>&#123;  </span><br><span class="line"> <span class="keyword">@private</span>  </span><br><span class="line">  <span class="built_in">NSString</span> *name_;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSString</span> *name;  </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span>  </span></span><br><span class="line"><span class="keyword">@synthesize</span> name = name_;  </span><br><span class="line">- (<span class="keyword">id</span>)init &#123;  </span><br><span class="line">...  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="对字符串使用拷贝特性"><a href="#对字符串使用拷贝特性" class="headerlink" title="对字符串使用拷贝特性"></a>对字符串使用拷贝特性</h3><p>   NSString 类型的属性应该永远声明为带有copy attribute </p><p>   这点是因为NSString 的setters 永远使用copy 而不是retain 。</p><p>   永远不要对CFType属性使用synthesize </p><p>   CFType类型应该永远遵守@dynamic的实现规则。</p><p>   因为CFType类型不能有reatin 属性特性，开发者必须自己维护。(下面不懂，原文In the rare case that you do actually want assignment it is better to make that completely clear by actually implementing the setter and getter and commenting why that is the case. )</p><p>  列出所有的实现指令 </p><p>  为所有属性使用实现指令，即使默认是@dynamic</p><p>  尽管@dynamic是默认的，显式的列出所有属性实现指令还是让类中的每个属性更加清楚。</p><p>iOS代码 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AVOID  </span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span>  </span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name;  </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span>  </span></span><br><span class="line">.  </span><br><span class="line">.  </span><br><span class="line">.  </span><br><span class="line">- (<span class="built_in">NSString</span>*)name &#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="string">@"foo"</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// GOOD  </span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span>  </span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>) <span class="built_in">NSString</span> *name;  </span><br><span class="line"><span class="keyword">@end</span>  </span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span>  </span></span><br><span class="line"><span class="keyword">@dynamic</span> name;  </span><br><span class="line">.  </span><br><span class="line">.  </span><br><span class="line">.  </span><br><span class="line">- (<span class="built_in">NSString</span>*)name &#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="string">@"foo"</span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>   属性使用过犹不及。默认情况，所有的synthesized setters 以及 getters  默认都是原子性的，显然所有的get，set方法都过度使用了同步方法。所以除非你确实需要原子性，否则都将你的属性声明为nonatomic </p><h3 id="点表示法"><a href="#点表示法" class="headerlink" title="点表示法"></a>点表示法</h3><p>   我们禁止使用点表示法是基于如下理由的:      </p><ul><li>点表示法不过是标准函数调用的语法糖，它的可读性很有争议。也不过就是换个形式调用函数而已。      </li><li>它使得提领操作含糊不请.首先看: [foo setBar:1] 很清楚你就明白这是Objective-C对象上的操作。那么看 foo.bar = 1 就不太清楚到底是对Objective-C的对象还是结构体/公用体/C++类进行操作了。      </li><li>它使得函数调用看起来就像getters         </li></ul><p>iOS代码 </p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *upperCase = <span class="string">@"foo"</span>.uppercaseString;</span><br></pre></td></tr></table></figure><p>   不仅使人困惑，也很难在代码审核的时候检查出来。     </p><ul><li><p>它隐藏了函数调用</p><p>iOS代码 </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bar.value += 10;</span><br></pre></td></tr></table></figure><p> 这实际上做了两次函数调用(一次get一次set)，而如果你的类很复杂的话，你发现一大堆事都在幕后做完了。</p><h2 id="Cocoa模式"><a href="#Cocoa模式" class="headerlink" title="Cocoa模式"></a>Cocoa模式</h2><h3 id="委托模式"><a href="#委托模式" class="headerlink" title="委托模式"></a>委托模式</h3><p> 委托对象不应该是retain </p><p> 一个实现委托模式的类应该:    </p><ol><li>实例变量命名为delegate_ 以显示这是个委托       </li><li>因此，访存方法名就为delegate 和setDelegate      </li><li>delegate_ 变量不能设为retain       </li></ol><h3 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h3><ul><li><p>将模型与视图分离，将控制器从视图和模型中分离，回调APIs使用@protocol </p></li><li><p>模型与视图分离: 不要对模型或数据源的表现形式做任何假设。保持数据与表现层的接口的抽象性。模型不对视图有任何了解(一个好的实践就是询问你自己是否能对数据有多个不同形式的表现方法)</p></li><li><p>控制器从视图和模型中分离: 不要把”业务逻辑”放到视图相关的类；这会导致代码可复用性下降。让控制器的类承管代码，但不要对表现形式做太多假设。</p></li><li><p>用@protocol 定义回调APIs: 如果不是所有的方法都必须实现就使用@optional (例外:在Objecitve-C 1.0的时候，@optional 还不可用，所以用类别去定义一个”非标准协议(informal protocol)”)</p></li></ul><p>最后的最后，这篇文章会尽量的完善，不停的矫正，以便让自己形成一个良好的代码习惯</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;总览&quot;&gt;&lt;a href=&quot;#总览&quot; class=&quot;headerlink&quot; title=&quot;总览&quot;&gt;&lt;/a&gt;总览&lt;/h1&gt;&lt;p&gt;参考资料&lt;a href=&quot;https://zh-google-styleguide.readthedocs.io/en/latest/google-objc-styleguide/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Google Objective-C Style Guide&lt;/a&gt;   &lt;/p&gt;
&lt;p&gt;   老大是一位重度代码洁癖的处女座，对代码规范非常苛刻，以前经常改动我的代码就为了他能看的顺眼。我记得曾在我提交的茫茫代码行中愣是指出某处的空格少了一个(囧)。&lt;br&gt;    其实我们花时间在某一方面，必然在某一方面有所收获，在代码上花时间，那么必然对技术有所提升，对泡妞上花时间，必然在泡妞上有更多的心得。。。  写博客也是因为老大的建议，即便写的不深，很是粗糙，但是经常写博客，花时间总结，可以记录自己的整个学习过程，也有助于自我思考，自我表达。&amp;lt; 屁话太多了吧(路过人员的心声) &amp;gt;      &lt;/p&gt;
&lt;pre&gt;&lt;code&gt;前沿：其实 每一门开发语言都有自己的代码规范，我们应该遵循它的代码规范去使用它，这就是这篇文章的来源。    
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
